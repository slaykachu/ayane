; <<<<<<<< Instrument selector >>>>>>>>>
; 2025 
; -- v0au --
  ; Nov 14 ui_get_instr#: set to 99
         ; Clear 
      ; 10 s/dev_checks/dev_checks' to avoid ambiguity
; -- v0ap --
  ; Sep 18: Don't change instr# in status here anymore
; -- v0ao --
       ; 7: Remove instr_selector_process:
             ; - use /extra_handler/
             ; - so we can use gerenic uiloop and test instr (piano)
          ; Use instr_change for status update
          ; cancel: don't restore instr
                ; 'esc' to exit page shouldn't have side-effect
                ; less code!
          ; Fix selector_ui': w_multiline now needs insert+delete

; -- v0am -- 
  ; Aug 20: Remove import "uiloop" (not needed)
      ; 02: Use instrui.instr_change
  ; Jul 14: Move manual test in instrstt.o 
; v0.0a 6 Mar 25

to_be_implemented = &BE00
dev_checks' = 1
need_rom = 1

      IMPORT "const.i"
      IMPORT "memmap.i"
      IMPORT "macro.i"

      IMPORT "chung.o"  ; Model (instr get/set row)
      IMPORT "ged.o"

instrsel_code
instr_selector_init
          ASSERT($ == instrsel_code) ; avoid jump table 

; --- Gedeihen setup ---
          call gedeihen_init
 ; For now, keep default (firmware hooks)
 ;     call gedeihen_set_hooks 
          ld hl,selector_ui
          call setup_widget
; -- refresh_all
      IF need_room
 ; factorize with instrui
      END
          ld hl,&0101:call txt_set_cursor
          call gedeihen_disp
          ld hl,&0101:call txt_set_cursor
          ld hl,selector_ui
          jp gedeihen_enter

; -------------------------------------------------
selector_ui
      BYTE w_key_handler
      WORD selector_ui'
      WORD extra_handler

selector_ui'
      BYTE w_multiline
      WORD instr_id_ui
      WORD ui_get_instr#
      WORD ui_select_instr
      WORD 0            ; no delete
      WORD 0            ; no insert
      BYTE 10           ; Height (vampire1.chp: 9 instr)
      BYTE 0            ; scroll offset (margin)

ui_get_instr#
;Hack for now. Do i have song_get_instr# ?
          ld a,MAX_INSTRS
;todo: instr# + 1 (so entry with empty_instr)
          ret

ui_select_instr
          inc a         ; start from 1
          call Song_select_instr
          scf           ; Carry means ok
          ret

extra_handler
      BYTE kreturn:WORD select_instr
      BYTE kesc:WORD cancel
      BYTE 0:WORD 0

instr_id_ui
; Display instr id (future: name and graphic preview!)
      BYTE w_text_dyn
      WORD instr_title

instr_title
;Out: hl= txt to print
          call Song_get_instr
          call _deci_byte_to_buffer
          push hl
          call instr_does_exist
          jr z,.empty
;toto: print name 
          pop hl
          push hl
          call skip_nt
          ex de,hl
          ld b,18
          jr .clear_right

.empty
          ld hl,.empty_txt
          call append_to_buffer
          ld b,18 - .empty_txt_
.clear_right
      IF todo
; Check for buffer overrun, or have the disp routine doing the padding
      END
          ld a," "
          dec de
.lp       ld (de),a:inc de:djnz .lp
          xor a
          ld (de),a
          pop hl
          ret

.empty_txt BYTE " <New instr>",0
.empty_txt_ = $ - .empty_txt - 1

cancel
          UNHANDLED(kesc) ; Caller can process exit
          ret

select_instr
          UNHANDLED(kreturn) ;Caller will enter instrui
          ret

