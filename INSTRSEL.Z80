; <<<<<<<< Instrument selector >>>>>>>>>
; 2026
; -- alpha2 --
  ; Jan 14 edit instr name 
         ; deactivate f5/f8 (fix bug instr changed in selector line)
; 2025 
; -- v0au --
  ; Nov 14 ui_get_instr#: set to 99
         ; Clear 
      ; 10 s/dev_checks/dev_checks' to avoid ambiguity
; -- v0ap --
  ; Sep 18: Don't change instr# in status here anymore
; -- v0ao --
       ; 7: Remove instr_selector_process:
             ; - use /extra_handler/
             ; - so we can use gerenic uiloop and test instr (piano)
          ; Use instr_change for status update
          ; cancel: don't restore instr
                ; 'esc' to exit page shouldn't have side-effect
                ; less code!
          ; Fix selector_ui': w_multiline now needs insert+delete

; -- v0am -- 
  ; Aug 20: Remove import "uiloop" (not needed)
      ; 02: Use instrui.instr_change
  ; Jul 14: Move manual test in instrstt.o 
; v0.0a 6 Mar 25

dev_checks' = 1
need_rom = 1

      IMPORT "const.i"
      IMPORT "memmap.i"
      IMPORT "macro.i"

      IMPORT "chung.o"  ; Model (instr get/set row)
      IMPORT "song.o"   ; Song_get_instr
      IMPORT "gedwidid.i"
      IMPORT "ged.o"

instrsel_code
instr_selector_init
          ASSERT($ == instrsel_code) ; avoid jump table 

; --- Gedeihen setup ---
          call gedeihen_init
 ; For now, keep default (firmware hooks)
 ;     call gedeihen_set_hooks 
          ld hl,selector_ui
          call setup_widget
; -- refresh_all
      IF need_room
 ; factorize with instrui
      END
          ld hl,&0101:call txt_set_cursor
          call gedeihen_disp
          ld hl,&0101:call txt_set_cursor
          ld hl,selector_ui
          jp gedeihen_enter

; -------------------------------------------------
selector_ui
      BYTE w_key_handler
      WORD selector_ui'
      WORD extra_handler

selector_ui'
      BYTE w_multiline
      WORD instr_entry_ui
      WORD ui_get_instr#
      WORD ui_select_instr
      WORD 0            ; no delete
      WORD 0            ; no insert
      BYTE 10           ; Height (vampire1.chp: 9 instr)
      BYTE 0            ; scroll offset (margin)

ui_get_instr#
;Hack for now. Do i have song_get_instr# ?
          ld a,MAX_INSTRS
;todo: instr# + 1 (so entry with empty_instr)
          ret

ui_select_instr
          inc a         ; start from 1
          call Song_select_instr
          scf           ; Carry means ok
          ret

extra_handler
      BYTE kreturn:WORD select_instr
      BYTE kesc:WORD cancel
      BYTE kf+5:WORD swallow
      BYTE kf+8:WORD swallow
      BYTE 0:WORD 0

instr_entry_ui
      BYTE w_struct
      WORD instr_id_ui
      WORD instr_name_ui
      WORD 0

instr_id_ui
; Display instr id
      BYTE w_text_dyn   ; w_deci would be R/W!
      WORD instr_id

instr_name_ui
      BYTE w_text_field
      WORD ui_set_name
      WORD ui_get_name
      BYTE instr_name_width

instr_id
;Out: hl= txt to print
          call Song_get_instr
          jp _deci_byte_padded_to_buffer

ui_set_name
;when name entered: create instr if needed
          push hl
          call Song_get_instr
          ld b,a
          call instr_does_exist
          ld a,b
          call z,New_instr_ayane
          pop hl
          call instr_set_name
          scf
          ret

ui_get_name
          call instr_does_exist
          ld hl,.empty_txt
          ret z
          jp instr_get_name

.empty_txt BYTE "<New instr>",0

cancel
          UNHANDLED(kesc) ; Caller can process exit
          ret

select_instr
          UNHANDLED(kreturn) ;Caller will enter instrui
          ret

swallow
;no-op 
          call refresh_focus
          GED_HANDLED()
          ret
