; ====== Handling of phrases and rows ======
do_add_empty_row = 0
      IF do_add_empty_row
 !! A bit inconvenient. must fix phrasnrt, chipn, salo ... 
      END

; 2025    
 ; -- alpha 1 --
dev_checks' = 1
todo  = 1
makeroom = 1

; -------------------------------------------------------------
; --- Song handling ---
; This are the highest level routines
; -------------------------------------------------------------
  ; phrase_reset
  ; song_select_new_phrase
  ; song_select_phrase
  ; Get_phrase
  ; song_get_current_phrase
  ; song_get_phrases#

; -------------------------------------------------------------
; --- Phrase handling ---
; All those routines expect a phrase to be currently selected
; -------------------------------------------------------------
  ; phrase_set_params
  ; phrase_select_new_row
  ; phrase_select_row_at
  ; phrase_set_blank_row_at 
  ; phrase_get_rows#
  ; phrase_get_row_position
  ; phrase_get_row_at
  ; phrase_get_duration
  ; --phrase_select_next_row-- in track.o (since might change phrase)

; -------------------------------------------------------------
; --- Row handling ----
; All those routines expect a row to be currently selected
; -------------------------------------------------------------
  ; row_add_duration
  ; row_set_note  
  ; row_get_note  
  ; row_set_vol
  ; row_get_vol
  ; row_set_instr
  ; row_get_instr

      IMPORT "const.i"
      IMPORT "memmap.i"
      IMPORT "macro.i"

      IMPORT "assert.o"
      IMPORT "memcpc.o"
      IMPORT "chunk.o"

pos_flags = 1           ; Duration: 1 byte only
flags_sz = 1
; Hack to avoid ambiguous label?
phrase_start = chunk_start + clip_header_size

      IF phrase_start - chunk_start:ELSE
!!! must review is_end_of_phrase
      END

;-- Tables -----------------
;!! in new table: fix chunks_in_base_bk
;7000-...: free 
      IF phrases_ - &7600
 !!! inconsistent
      END
phrases_idx = &7600     ; start chunk for each phrase &100 ** word 
      IF phrases_idx AND &01FF
 !! must be multiple of #200
      END
phrases_rows = &7800    ; nb rows for each phrase
;nb: for now, no discrimination between tables (arp, instr, ...)
;-> we should keep it that way (more flexible, less ram & code needed)

;==============================================
      MACRO INIT_LENGTH
      IF todo
; rename s/lenght/duration (or better term)
      END
      IF pos_flags - 1
 !! a revoir
      END
          ld (hl),a:inc l
      ENDM

      MACRO SKIP_LENGTH
          pos_flags ** inc l
      ENDM

      MACRO SKIP_LENGTH_DE
          pos_flags ** inc e
      ENDM

      MACRO CP_COPY_LENGTH
          pos_flags ** call cp_copy
      ENDM

      MACRO SKIP_RESERVED
          reserved_byte ** inc l
      ENDM

;==============================================
phrase_code

phrase_reset
;-----------
          call connect_bk_phrase
          ld a,delai_ui_default
          call set_delai_ui

          ld hl,def:ld de,var:ld bc,def_size:ldir ; non-zero vars
          ex de,hl
          ld b,zero_size:xor a:call fillb
; Reset index. Easier to see if phrase already allocated or not.
; song_select_new_phrase relies on that for checks.
          ld hl,phrases_idx
          call fill
          inc h
;enchaine
fill      ld (hl),a:inc l:jr nz,fill
          ret
fillb     ld (hl),a:inc hl:djnz fillb
          ret

song_select_new_phrase
;---------------------
; Create and select a fresh phrase, from 0 to 254
; !! UI must add empty row to avoid infinite auto loop in ply
; (as do_add_empty_row=0, convenient for chipn and salo)
; Init /_header/:index, type, name (null for now), color (idx+1 for now)
; IN: A = phrase ID: - needed by chip.o since non contiguous patterns
                            ; by salo.o 
                   ; - useful for user (use ids as he likes)

          call scope_bk_phrase

;Must set header value **before** new_phrase_chunk which 'install' them
;We store idx, so that track can directly point to phrase (using pnt)
;(faster for player), but we still know the phrase# for UI purpose.
          ld (phrase_idx),a
          ld (va_current_phrase),a
          inc a:call z,err_toomuchphrases
          ld (phrase_color),a

          call new_phrase_chunk:ret nc ; Exit if memory full
      IF dev_checks'
          ld a,l:cp BK_PHRASE:call nz,mess
      END
          ex de,hl      ; DE= phrase chunk ID.
;Must updates vars **after** new_phrase_chunk,
;in case mem full -> no change.
          call connect_bk_phrase
          ld hl,(va_current_phrase) ; for l
          ld h,phrases_rows/&0100:ld (hl),0 ; rows # 
          ld h,phrases_idx/&0200:sla l:rl h
          ld (hl),e:inc l
      IF dev_checks'
; !! Right now we assume it's a brand new phrase.
; When it's not the case anymore (e.g. user input), either
; return current as is (no new_phrase_chunk) or free it (TBD).
          ld a,(hl):or a:call nz,mess
      END
          ld (hl),d
; Here and below: mustn't change flag Z!

      IF do_add_empty_row
; Create empty row:
   ; - Avoid infinite loop with ply (since phrase autoloop)
   ; - Setup va_row_pnt (more generic)
          ld a,&80      ; arbitrary duration > 0
; Only for existing phrase!
          call phrase_select_new_row
      END

          ; NZ (for _set_row_pnt)
          jr _set_row_pnt


song_select_phrase
;-----------------
; In: A: phrase number (from 0)
; Out: Like /Get_phrase/
  ; !! Current phrase changed even when non-initialised. Nevermind?

          call scope_bk_phrase
          ld (va_current_phrase),a
          call Get_phrase
_set_row_pnt
; Selecting first row seems to be a better solution than
; resetting va_row_pnt (then calling e.g. row_add_duration would
; silently add a row via connect_current_row)   
          push af
          ld hl,0
; Non-existing phrase don't have a start
          call nz,connect_phrase_begin
          ld (va_row_pnt),hl
          pop af
; Is carry really needed if we use exception mecanism?
          scf
          ret


song_get_phrases#
;----------------
;Out: A= number of phrases
      IF todo
;!!! BUG: if 256 phrases, returns 0
      END
          call scope_bk_phrase

;Scan all phrases, and count non-empty
          ld bc,0       ;c = cnt
.lp
          ld a,b
          call Get_phrase
          jr z,.next
          inc c
.next
          djnz .lp
          ld a,c
          ret

err_toomuchphrases
      BRK

song_get_empty_phrase
;--------------------
;Out: A= id empty phrase
          call scope_bk_phrase

;Scan all phrases, and count non-empty
          ld c,0
.lp
          ld a,c
          call Get_phrase
          jr z,.found
          inc c
          jr nz,.lp
          call memory_full
.found
          ld a,c
          ret

phrase_clone
;In: phrase selected
;Out: id phrase clone
          call scope_bk_phrase
          call connect_phrase_begin
          push hl
          call song_get_empty_phrase
          call song_select_new_phrase
          call connect_phrase_begin
          ex de,hl
          pop hl
          push de       ; start
          call copy_chunk_raw
; copy linked chunks
.copylp
          ld a,(hl):inc l
          ld h,(hl):ld l,a
          or h:jr z,.done
; hl: src
; de: dest
          push hl
          ld h,d
          ld l,BK_PHRASE
          call insert_new_chunk_from_id_
          ld l,chead_next+1
          ld d,(hl)
          ld e,chunk_start
          call set_eoc_link
          pop hl
          ld l,e
          call copy_chunk_raw
          jr .copylp

.done
; set loop to start of cloned pharse
          ex de,hl
          pop de
          call set_eoc_link
          jp song_get_current_phrase

copy_chunk_raw
;Copy data as-is (doesn't include header) and update chead_last
;Out: HL points to chead_next
          ld a,l
      IF dev_checks'
          cp e:call nz,mess
      END
          neg
      IF dev_checks'
          call z,mess
      END
          ld c,a:ld b,0
          ldir
          dec d:dec h
          ld l,chead_last
          ld a,(hl)
          ld e,l
          ld (de),a
          ld l,chead_next
          ret

set_eoc_link
; Set link at end of chunk (like /put_eoc/)
;In: HL: points in chunk
   ; DE: ID link
          ld l,chead_last
          ld l,(hl)
          ld (hl),d:dec l
          ld (hl),e
          ret

phrase_set_params
;----------------
; Note: done separately to prepare for alternatives
;In: hl: params (out of bank)
   ;  c: size params
          ld a,c:or a:ret z
          dec a:call nz,mess ; just 1 param for now (fc_color)
          call scope_bk_phrase
          ex de,hl
          call connect_phrase_begin
      IF fc_color - 4
 !! review 
      END
          ld l,chunk_start + fc_color
          ex de,hl
          ld b,0
      IF dev_checks'
; Check C was preserved
          ld a,c:or a:call z,mess
          cp 2:call nc,mess
      END
          ldir
          ret

phrase_select_new_row
;--------------------
; create (append) row in current phrase, and select it.
; In:  A = duration
; Out: exception if memory full

; TODO: check if there is actual a phrase selected

          call scope_bk_phrase
          push af
          ld hl,(va_current_phrase) ; for l only
          ld h,phrases_rows/&0100
          inc (hl)

          call connect_phrase_begin
          call goto_end
          ld e,l:ld d,h
          push de:pop ix
          pop af
          push af
row_size0 = 1+pos_flags+reserved_byte ; duration, flags, reserved
          ld c,row_size0 ; size without note, volume, instr or fx
          call shift_in_phrase_chunk
;pb: hl=pos where link was added
          pop af
          push hl
          INIT_LENGTH()
          ld (hl),0     ; flags
          pop hl
          ld (va_row_pnt),hl
          ret

unpack_row_at
;------------
; Flatten and reorder row at exactly time t
                  ; note, instr, vol  (-1 if absent)
; In: HL = t
    ; DE = dest buf (confined)
;Out: - If such row,    Carry, NZ
    ; - If no row at t  Carry, Z   
                      ; In both cases BC = time next (non-empty) row
    ; - If past phrase, NC, BC preserved
    ; HL, DE preserved
          call scope_bk_phrase
          push hl:push de
          ex de,hl      ; de = t
          call phrase_get_row_at
          pop de
          jr c,.ok
;past phrase: NC here
          pop hl
          ret

.ok
          ld bc,(row_t1):ld (time_next_row),bc
          jr z,_unpack_row_com

; When t0 < t, it means no row until t1    
          call skip_all
          ld (pnt_next_row),hl
          pop hl
          cp a          ; z
          scf           ; !! after cp a
          ret

_unpack_row_com
          push bc
          inc l         ; skip duration
          ld a,(hl):and &1F:call nz,mess ; no fx for now
          ld b,(hl):inc l
          ld c,-1
;instr encoded first, but put 2nd in buf
          ld a,c:bit bit_instr,b:jr z,$+4:ld a,(hl):inc l
          inc e:ld (de),a:dec e
          ld a,c:bit bit_note,b:jr z,$+4:ld a,(hl):inc l
          ld (de),a:inc e:inc e
          ld a,c:bit bit_vol,b:jr z,.okvol
          ld a,15:sub (hl):inc l
.okvol
          ld (de),a
          2 ** dec e    ; start of buf
          SKIP_RESERVED()
          ld (pnt_next_row),hl
          pop bc        ; time next row
          pop hl        ; t
          scf:sbc a     ; C, NZ
          ret

unpack_next_row
; Necesseraly called on non-empty row or at end of phrase
; IN: de = buffer
;Out: If such row,    Carry, NZ
                   ;  BC = time next row
    ; If past phrase, NC, BC preserved
    ; HL, DE preserved 
          call scope_bk_phrase
          push hl
          ld hl,(pnt_next_row)
          call follow_link_if_eoc
          jr z,.past
          ld a,(hl)     ; duration
          ld bc,(time_next_row)
          or a:jr nz,$+3:inc b ; 0 = &100
          add c:ld c,a:jr nc,$+3:inc b
          ld (time_next_row),bc
          jr _unpack_row_com

.past
          or a
          pop hl
          ret

phrase_select_row_at
;-------------------
; Create a new row at t (if not existing)
; and select it.  
; In: DE = t
;Out: row selected.     
    ; AF thrashed, all other registers preserved.
          call scope_bk_phrase
          push hl
          call phrase_set_blank_row_at
          ld (va_row_pnt),hl
          pop hl
          ret

      IF 0
phrase_get_row_position
;----------------------
          call scope_bk_phrase
          ld hl,(va_position)
          ret
      END

phrase_set_blank_row_at
;----------------------
; Create a new row at t (if not existing)
; In: DE = t
;Out: HL = pnt row

      IF todo
; factorize with add_duration?
      END
          call scope_bk_phrase
          ld (va_position),de
.retry
          call phrase_get_row_at
          jr nc,.new_row
.retry'
; BC:new duration of previous row = t - t0
; If 0, nothing to do.
          ret z
; intermediate row if t-t0 >= &100 
          inc b
.padlp
          dec b:jr z,.padok
;put max duration
          ld (hl),&FF
          call skip_all
          call insert_new_row
          inc bc        ; bc -= &ff (with dec b at padlp)
          jr .padlp

.padok
          ld a,(hl):push af ; previous duration for case = 0
          ld (hl),c
      IF dev_checks'
          call is_end_of_phrase:call z,mess
      END
          call skip_all

; Duration of new row = t1 - t
          call insert_new_row
          pop af
; Corner case: if duration was previously 0, 
; we interpret it as "forever". New row duration shall stay 0 as well.
; Note: it is slighty inconsistent with ply which interpret it as 65356
; (21 minutes at 50hz replay) -> nevermind.
; Anyway 0 duration should only be used for last row of phrase.
          or a
          ret z

          ld bc,(row_t1)
          ld a,c:sub e:ld c,a
          ld a,b:sbc d:call c,mess
 ; intermediate row if t1-t >= &100
          call nz,to_be_implemented
          ld a,c:or a:call z,mess ; should have t < t1  
          ld (hl),a
          ret

.new_row
; Empty phrase, or past finite duration
          push de
          call goto_last_row
          jr nz,.append
; empty: append new row
          xor a         ; infinite dur by default
          call phrase_select_new_row
          pop de
      IF dev_checks'
.check_entry
          call phrase_get_row_at
; since inf, cannot fail
          call nc,mess
          jr .retry'
      ELSE
          jr .retry
      END

.append
; Extend to inf dur. 
      IF dev_checks'
          ld a,(de):or a:call z,mess
      END
          xor a:ld (de),a
          pop de
      IF dev_checks'
          jr .check_entry
      ELSE
          jr .retry
      END

      IF 0
phrase_delete_row_at
;In:  DE= time
   ;   A= duration to remove
      IF todo
; See TODO goto_last_row
      END
          call scope_bk_phrase
          ld c,a
          call phrase_get_row_at
          jr nz,.okrow
;todo: empty row contents (remove note, instr...)
.okrow
          ld a,(hl):sub c:jr c,.remove
          jr z,.remove
          ld (hl),a
          ret

.remove
          push af       ; remaining <= 0
 ; must remove row itself
      BRK
          pop af
          neg
          ret z
; Remove remaining 
          ld c,a
          call goto_next_row
          jr nz,.okrow
          ret
      END


insert_new_row
;In:  HL= start of row
;Out: HL= same (start of inserted row)
      IF todo
; what if eoc, and new row doesn't fit?
      END
          push bc:push de
          ld e,l:ld d,h
          ld c,pos_flags+flags_sz+reserved_byte
          call shift_in_row
; setup row:
          ld (hl),0:inc l ; dur
          ld (hl),0     ; flags
;reserved byte: nevermind for now
          dec l
          pop de:pop bc
          ret

phrase_get_rows#
;---------------  
;In: Phrase selected
;Out:A = nb rows  (!! different API than instr_get_rows#, simpler code) 

          call scope_bk_phrase
          call connect_phrase_begin
          ld c,0
.lp
          call is_end_of_phrase
          jr z,.done
          inc c
          call skip_all
          jr .lp
.done
          ld a,c
          ret

phrase_seek_row_at
;-----------------
; like phrase_get_row_at, but reconnect bank for phrase_ui
          call scope_bk_base
          jr phrase_get_row_at

phrase_seek_last_row
;-------------------
          call scope_bk_base
;enchaine
phrase_get_last_row
;------------------
;!!! for now doesn't work for infinite
   ; nevermind as ui-wise we won't create such phrases
; In: N/A
;Out: like phrase_get_row_at
    ; except de = time last row

          call phrase_get_duration
      IF dev_checks'
          ld a,c:or a:call nz,mess ; not expecting >= &10000
          ld a,c:or d:or e:call z,mess ; not expecting empty phrase
      END
          dec de        ; last tick
          call phrase_get_row_at
      IF dev_checks'
          call nc,mess  ; must exists!
      END
; get again 
          ld de,(row_t0)
;enchaine
phrase_get_row_at
;----------------
; Pick row (t0, dur) such that t0 <= t < t1 (t0+dur)
;   Written at nu gulho (such a nice waitress, Raquel)
; In: DE = t (16 bits is enough, 1024 rows at delai 64)
;OUt: If such a row:
      ; Carry, HL = row start
             ; row_t0 = t0,  row_t1 = t0+dur
             ; BC = t - t0
             ;  Z if t = t0 (row exactly at t)
             ; NZ otherwise
    ; Otherwise, NC (empty phrase or past 
             ; 
    ; DE preserved in any case.

          call connect_phrase_begin
          ld bc,0       ; t0: current time
.lp
; loop while t1 <= t and eoc not met
          ld (row_t0),bc
          call is_end_of_phrase
          scf:ccf:ret z ; exit NC
; loop while t1 <= t and eoc not met
          ld a,(hl)
          add c:ld c,a:jr nc,$+3:inc b
          ld (row_t1),bc
;special case: handle 0 as 65536
          ld a,(hl)
          or a
          jr z,.found'
;Stop if bc (t1 = t0+dur) > de (t) 
          ex de,hl
          or a:sbc hl,bc:add hl,bc
          ex de,hl
          jr c,.found
          call goto_next_row
          jr nz,.lp
          or a
          ret           ; ret nc

.found'
; Indicate next row is at +inf (needed for phradisp)
          ld bc,&FFFF:ld (row_t1),bc
.found
; BC = t-t0, Z flag accordingly
          ld bc,(row_t0)
; BC := DE - BC
          push de
          ex de,hl
          or a:sbc hl,bc:ld c,l:ld b,h
          ex de,hl
          pop de
      IF dev_checks'
          call c,mess
      END
          scf
          ret

phrase_get_duration
;------------------
; Get total duration of the phrase
; For now we don't cache it (yagni, premature optimisation)
; IN: phrase selected
;OUT: cde = total 
    ; AF, HL preserved
; Note: returned on 24 bits to account for dur 0 = &10000,
      ; but we can only set row at 16 bits timestamp.
          call scope_bk_phrase
          push af:push hl
          call connect_phrase_begin
          ld de,0
          ld c,d
.lp
          call follow_link_if_eoc
          jr z,.done
; 0 duration means "inf" in some context (phrase_select_row_at),
; and &10000 for ply. Stick with ply:
  ; - that's the most sensitive tm-wise -> source of truth
  ; - smaller code
  ; - can harmonize the rest later
          ld a,(hl):or a:jr z,.big
          add e:ld e,a
          jr nc,.nxt
          inc d
          jr nz,.nxt
.big
          inc c
.nxt
          call skip_all
          jr .lp

.done
          pop hl:pop af
          ret


row_add_duration
;---------------
; Extend duration of current row
; IN: A= additional duration
          call scope_bk_phrase
          call connect_current_row
          add (hl):jr nc,.ok
; insert blank row **after** with length = 255
; (we don't use length 0 = 256)
          push af
          call skip_all
          call insert_new_row
          ld (hl),255
          call connect_current_row
          pop af
          inc a         ; remainder
;enchaine
.ok
          ld (hl),a
          ret

row_set_note
;-----------
; in: A= note
;out: A preserved

          call scope_bk_phrase
          push bc:push de:push hl
          call connect_current_row_skip_length'
          bit bit_note,(hl)
          push af
          call skip_fx_ins
          pop af
          jr nz,_change_byte

;insert                  
          push af
          ld c,1:call shift_in_row
          ex de,hl
          SKIP_LENGTH()
          set bit_note,(hl) ;cannot be done before
_change_com
          ex de,hl
          pop af
_change_byte
          ld (hl),a
          pop hl:pop de:pop bc
          ret


row_get_note
;-----------
; in: N/A
;out: NZ A= note  if any
    ; Z if no note defined here

          call scope_bk_phrase
          call connect_current_row_skip_length
          bit bit_note,(hl)
          ret z

          call skip_fx_ins
          xor a:inc a   ; NZ
          ld a,(hl)
          ret

row_del_note
;-----------
; in: N/A

          call scope_bk_phrase
          call connect_current_row_skip_length
          bit bit_note,(hl)
          ret z
          res bit_note,(hl)
          call skip_fx_ins
delete_byte
; In: hl : pos byte in chunk to be deleted
          ld e,l
          ld d,h
          inc l
          ld a,l:neg
      IF dev_checks'
          call z,mess
      END
          ld c,a
          ld b,0
          ldir
          dec h
          ld l,chead_last
          dec (hl)
          ret


row_set_vol
;----------
; in: A= volume (F=max)
;out: A as encoded
          cpl:add 15+1  ; Negative. 0=max 15=mute
row_set_vol_encoded     ; for salo
;------------------
          call scope_bk_phrase
          push bc:push de:push hl
          call connect_current_row_skip_length'
          bit bit_vol,(hl)
          push af
          call skip_fx_ins_note
          pop af
          jr nz,_change_byte

;insert                  
          push af
          ld c,1:call shift_in_row
          ex de,hl
          SKIP_LENGTH()
          set bit_vol,(hl) ;cannot be done before
          jr _change_com


row_get_vol
;----------
; in: N/A
;out: NZ A= vol if any
    ; Z if no vol defined here

          call scope_bk_phrase
          call connect_current_row_skip_length
          bit bit_vol,(hl)
          ret z

          call skip_fx_ins_note
          ld a,15:sub (hl)
          inc h         ; NZ
          ret

row_del_vol
;----------
          call scope_bk_phrase
          call connect_current_row_skip_length
          bit bit_vol,(hl)
          ret z
          res bit_vol,(hl)
          call skip_fx_ins_note
          jr delete_byte

row_set_instr
;------------
; in: A= ins
;out: A preserved
          call scope_bk_phrase
          push bc:push de:push hl
          call connect_current_row_skip_length'
          bit bit_instr,(hl)
          push af
          call skip_fx
          pop af
          jp nz,_change_byte

;insert 
          push af
          ld c,1:call shift_in_row
          ex de,hl
          SKIP_LENGTH()
          set bit_instr,(hl) ;CANNOT be done before
          jp _change_com

row_get_instr
; Out: If instr: NZ, A=instr id
     ; otherwise Z, A trashed
          call scope_bk_phrase
          call connect_current_row_skip_length
          bit bit_instr,(hl)
;If Z, read garbage: nevermind 
          push af       ; For Z/NZ
          call skip_fx
          pop af
          ld a,(hl)
          ret

row_del_instr
;------------
          call scope_bk_phrase
          call connect_current_row_skip_length
          bit bit_instr,(hl)
          ret z
          res bit_instr,(hl)
          call skip_fx
          jp delete_byte


      IF 0
row_set_no_param_fx_
          call scope_bk_phrase
row_set_no_param_fx
;.......................
; in: BK connected
    ;  A: fx nb (0, 1, 2, 3)
    ; DE: fx routine

          push de
          call connect_current_row_skip_length'
;on se place sur bon fx
          ld b,a
          call skip_nfx
          rra
          jr c,_change_fxnoparam
;insert 
          push bc
          ld c,2:call shift_in_row
          pop bc

          SKIP_LENGTH_DE()
          ld a,(de):or c:ld (de),a ;cannot be done before
          pop de:call ld_hl_de
          ret

_change_fxnoparam
      BRK               ; todo: remove previous fx!
          ret

row_set_byte_param_fx_
          call scope_bk_phrase
row_set_byte_param_fx
;..................
; in: BK connected
    ;  A: fx nb (0, 1, 2, 3)
    ; DE: fx routine
    ;  C: param

          push bc:push de
;on se place sur bon fx
          call connect_current_row_skip_length'
          ld b,a
          call skip_nfx
          rra
          jr c,_change_fx0
;insert     
          push bc
          ld c,3:call shift_in_row
          pop bc
          SKIP_LENGTH_DE()
          ld a,(de):or c:ld (de),a ;cannot be done before
          pop de:call ld_hl_de
          pop bc:ld (hl),c
          ret

_change_fx0
      BRK               ; todo: remove previous fx!
          ret


row_set_word_param_fx_
          call scope_bk_phrase
row_set_word_param_fx
;.......................
; in: BK connected
    ;  A: fx nb (0, 1, 2, 3)
    ; DE: fx routine
    ; BC: adr table/param

          push bc:push de
          call connect_current_row_skip_length'
;on se place sur bon fx
          ld b,a
          call skip_nfx
          rra
          jr c,_change_fx
;insert     
          push bc
          ld c,4:call shift_in_row
          pop bc
          SKIP_LENGTH_DE()
          ld a,(de):or c:ld (de),a ;cannot be done before
          pop de:call ld_hl_de
          pop bc:call ld_hl_bc
          ret

_change_fx
      BRK               ; todo: remove previous fx!
          ret


row_set_3_param_fx
;.......................
; in: BK connected
    ;  A: fx nb (0, 1, 2, 3)
    ; DE: fx routine
    ; C,B,L: parameter

          push hl:push bc:push de
          call connect_current_row_skip_length'
;on se place sur bon fx
          ld b,a
          call skip_nfx
          rra
          jr c,_change_fx3
;insert     
          push bc
          ld c,5:call shift_in_row
          pop bc
          SKIP_LENGTH_DE()
          ld a,(de):or c:ld (de),a ;cannot be done before
          pop de:call ld_hl_de
          pop bc:call ld_hl_bc
          pop bc:ld (hl),c
          ret

_change_fx3
      BRK               ; todo: remove previous fx!
          ret

      END

      IF 0
;-------------------------------
irow_set_type_vol
;----------------
; in: A= type + vol   ttttvvvv
;out: A preserved

          call scope_bk_phrase
          call connect_current_irow
          ld (hl),a
          ret

irow_set_period
; in: de= period (abs or rel depending on type)
          call scope_bk_phrase
          call connect_current_irow
; !! wip !! todo: reflechir comment set/update/sera fait + in bank.
      END

      IF 0
;-------------------------------
fx_append_byte
; For incremental fx construction (cf salo.o)
; In: row_set_fx (in fx.o) called previously
    ; A= byte   

          push af
          call connect_current_row
          ex de,hl      ; de=start for shift_in_row
          ld hl,(va_instr_pnt)
          ld a,l:or h:call z,mess
;insert     
          ld c,1:call shift_in_row
          pop af:ld (hl),a
          ret
      END

;-------------------------------
ld_hl_de
          ld (hl),e:inc hl
          ld (hl),d:inc hl
          ret

ld_hl_bc
          ld (hl),c:inc hl
          ld (hl),b:inc hl
          ret

skip_all
; See /goto_next_row/ to follow eoc as well
;In:  HL: start of row
;Out: HL: post skip. BC, DE preserved.
          SKIP_LENGTH()
skip_post_length
          call skip_fx_ins_note
          call _skip_byte ; vol
          SKIP_RESERVED()
          ret

skip_fx_ins
;In:  HL: post-length
;Out: HL: post skip. BC, DE preserved.
          call skip_fx
          rra           ; discard bit 4
      IF dev_checks'
          call c,mess
      END
;ins
_skip_byte
; In   A: flag in bit 0
          rra:jr nc,$+3:inc l
          ret

skip_fx_ins_note
;In: HL: post length
;Out: HL: post skip. BC, DE preserved.
          call skip_fx_ins
          jr _skip_byte ; note

      IF 0
_skip_word
; In   A: flag in bit 0
          rra:jr nc,$+3:inc l
          jr nc,$+3:inc l
          ret
      END

skip_fx
          push bc
          ld b,nb_fx_max
          call skip_nfx
          pop bc
          ret

skip_nfx
; In   B: nb fx to skip (can be 0)
    ; hl: points to flag
; Out  A: flags shifted B times
    ; hl: post N fx
    ;  C: mask corresponding to fx

          ld c,mask_fx0
          ld a,(hl):inc l
          ld (dbg1),hl
          ld (dbg2),a
          inc b:dec b
          ret z
skip_fxlp call skip_one_fx:sla c:djnz skip_fxlp
          ret

skip_one_fx
;In:   A: bit 0, current flag
;Out:  A: flag consumed

          rra:jr nc,scom_nop

          push af
          call get_fx_sign

; 000000-> no more param
; ????01-> byte
; ????10-> word
; ????11-> word (table)

sof_param_lp
          or a:jr z,sof_param_end

          inc hl
          srl a
          srl a:jr nc,sof_param_lp ; case 01
          inc hl
          jr sof_param_lp

sof_param_end
          pop af
          ret

scom_nop
;todo: TM management
          ret

get_fx_sign
; here we already point to fx_init
; out: hl+=2 (addr fx consumed)

          push de
          ld e,(hl):inc hl
          ld d,(hl):inc hl
          dec e

      IF dev_checks'
;Player (and then fxs) out of bank.
          ld a,d:cp &40:call nc,mess
      END
          ld a,(de)
          pop de
          ret



connect_current_row_skip_length
;In: bk base connected!
;Out: HL= post length
;don't change A !              
          call connect_current_row
          SKIP_LENGTH()
          ret

connect_current_row_skip_length'
;In: bk base connected!
;Out: HL= post length
    ; DE= start row
;don't change A !              
          call connect_current_row
          ld e,l:ld d,h
          SKIP_LENGTH()
          ret


connect_current_row
;In:  The row was selected.
   ;  If no row was selected, create blank one
     ; - Useful for chipn.o: we only create rows when notes
          ; - If first row is "...:..", we want a blank row to set delai
     ; - It's better to do a sensible thing rather can assert.
         ; - maybe not better: it was silently adding rows when
           ; re-selecting phrase + e.G. add_row-duration.
;Out: HL= start
    ; AF, BC, DE, DE unchanged
          ld hl,(va_row_pnt)
          push af
      IF dev_checks'
          ld a,h
          or a:jr z,.ok ; for now
          cp &40:call c,mess
          cp phrases_/&0100:call nc,mess
.ok
      END
          xor a         ; needed if calling phrase_select_new_row
          or h:call z,phrase_select_new_row
; Second chance when calling phrase_select_new_row
          ld hl,(va_row_pnt)
      IF dev_checks'
          inc h:dec h:call z,mess
      END
          pop af
          ret


err_invalid_arpg
      BRK
assert_fail
      BRK
err_invalid_row
      BRK
err_invalid_ins
      BRK
err_no_instr
      BRK
err_no_row_selected
      BRK

connect_phrase_header
;out: bk connected
    ; hl= phrase HEADER itself** (connected)
    ;  A=bk
    ; BC, DE preserved 
          call connect_phrase_begin
          ld l,chunk_start
          ret

connect_phrase_begin
;out: bk connected
    ; hl=chunk start **PAST phrase HEADER itself** (connected)
    ;  A=bk
    ; BC, DE preserved
          call song_get_current_phrase
      IF dev_checks'
          call z,mess
      END
          ld l,BK_PHRASE
          jp connect_phrase_from_id

song_get_current_phrase
; Get selected phrase
;OUT:If such phrase, NZ, HL= pointer (not connected), A=id 

          call scope_bk_phrase
          push bc
          ld a,(va_current_phrase)
          call Get_phrase
          ld a,(va_current_phrase) ; reload without touching F
          pop bc
          ret

Get_phrase
;In: A= phrase number
;OUT: If phrase exists:
        ; NZ, HL= pointer (non connected)
    ; Otherwise, Z, HL thrased. 
            ; Needed by compile.o to iterate among existing phrases.
    ; Reconnect caller's bank (handy for track.o to plug pnt).
    ; A trashed
          call scope_bk_phrase
          push bc
; legacy: ID with BK number
; todo: full pointer directly (to allow mini chunks, or no chunks
      ; at all -> big pool).
          ld l,a
          ld h,phrases_idx/&0200
          add hl,hl
          inc l
      IF dev_checks'
          ld a,(hl):or a:jr z,.ok0
          and &C0:cp &40:call nz,mess
          dec l
          ld a,(hl):cp BK_PHRASE:call nz,mess
          inc l
.ok0
      END
          ld h,(hl)
          ld l,chunk_start ; phrase header
          pop bc
;We can ask for non-existing phrase
;(needed for compile.o and song_get_phrases#)
;In that case, set Z flag.
          ld a,h:or a   ; Z/NZ
          ret


goto_last_row
;Out: If empty, Z
    ; If not empty, DE = last
    ; HL = pnt to eoc in both cases
          call connect_phrase_begin
      IF todo
; failing if we emptied chunk via phrase_delete_row_at,
  ; TODO: is_end_of_phrase should follow all eocs
      END
          call is_end_of_phrase
          ret z
.lp
          ld e,l:ld d,h
          call goto_next_row
          jr nz,.lp
          scf:sbc a     ; NZ
          ret

goto_end
;in  a= bank
;out b= bank
.lp
          ld b,a
          call connect_next_chunk ; if nz, a= bk
          jr nz,.lp
          ld l,chead_last
          ld a,(hl)
          sub tag_end_size-1
          ld l,a
          ret


  ; ------ memory helpers -------------

shift_in_row
; in de: start of row  (!! needed in case of relocation)
;    hl: position of insertion (current byte will be shifted)
;     c: shift size
; Out : like shift_in_chunk 
          push de
          push hl
          ex de,hl
          call skip_all
;here: hl:post, de:start
          ex (sp),hl
          pop ix
          pop de
;!! enchaine
shift_in_phrase_chunk
; Like /shift_in_chunk/ except whole row must be moved if chunk full.

; IN de: start of row
;    hl: position of insertion (current byte will be shifted)
;    ix: post row
;     c: shift size
    ; !! Chunk connected.
    ; Nb: de=hl=ix when actually inserting a row.
;out If ok, Carry and:
  ; de: start of row (unchanged, or might be in new chunk)
  ; hl: position of insertion (unchanged, or might be in new chunk)
      ; bk connect 

; nb: we always insert before phrase's endtag,
    ; so this one will always be moved properly

; TODO? factorize with orgams? No merge and some other differences tho

      IF dev_checks'
          ld a,c:or a:call z,mess
      END
          call try_shift_in_chunk
          ret c

; Chunk is full.
; Row in first half: move past row -> we have room here.
; Row in second half: move from row -> we have room in new chunk
; This is needed to handle each corner case, respectively:
       ;  - row is first
       ;  - row is last

          bit 7,e:jr nz,sicc_second

          push hl
          push ix:pop hl
          call move_tail_in_new_chunk
          pop hl
          jr sicc_com

sicc_second
          ld a,l:sub e  ; offset insertion point from row start
          push af
          ld l,e:ld h,d
          call move_tail_in_new_chunk
          call connect_next_chunk
          ld (va_row_pnt),hl
          ld e,l:ld d,h ; start of row = chunk_start
          pop af
          add l:ld l,a

sicc_com
; Must fit now that room was made.
          call try_shift_in_chunk
          call nc,mess
          ret


copy_from_chunk_to_next
; This is a dumb overwritting copy:
; caller must ensure sentinel is copied as well.

; In: B : source bk
    ; HL: source   (with 'next' field valid)
    ; E: dest LSB. (MSB taken from 'next' field)
    ; C: size 
;Out: DE: next (dest) chunk
    ; Dest chunk updated (chead_last). !! TODO: checksum etc.
    ; Source bk reconnected.

; TODO: simpler code by coping to tmp buf out of bank.

          push iy
          ld iyh,b      ;bk source
          ld iyl,c
          ld b,l
          ld l,chead_next:ld a,(hl) ;bk dest
          inc l:ld d,(hl) ;MSB dest
          ld l,b

;copy_trans_bk   !! specialized for chunks
; adapted from mirror6.o

;in : HL=source DE=dest iyl=size 
    ; iyh=bk source (classical: c4 c5 c6 c7 ...)
    ; a=bk dest (classical too for ayane)
         ; (actually any would work, except c2 as we are not in rom)
          ld c,a
      IF dev_checks'
; 'next' field must be valid and non 0
          and &C4:cp &C4:call nz,mess
          ld a,d:and &C0:cp &40:call nz,mess
      END
          ld b,&7F
.ctbk_lp
          ld a,iyh
          out (c),a
          ld a,(hl):inc l
          out (c),c
          ld (de),a:inc e
          dec iyl
          jr nz,.ctbk_lp

          ld a,e
          dec a:ld e,chead_last:ld (de),a
          inc a
          ld e,a

          ld a,iyh
          out (c),a
          pop iy
          scf
          ret



insert_new_chunk_from_bhl
;------------------------
          push hl
          ld l,b
          call insert_new_chunk_from_id
          pop hl
          ret

insert_new_chunk_from_id_
;------------------------
          ld ix,new_chunk_ext
;enchaine
insert_new_chunk_from_id
;-----------------------
      IF makeroom
; factorize with chunk.o
      END
; in: hl= id chunk
    ; ix= routine for new chunk (e.g. /new_phrase_chunk/)
;out: If ok: Carry.  A= chunk_start. 
    ; Otherwise, NC, A= code (memory full). 
;  !! Input chunk reconnected in any case.
    ; bc, de, hl preserved.

          push bc:push de:push hl

          ld l,chead_next:ld e,(hl):inc l:ld d,(hl)
          call hook_new_chunk:call nc,memory_full
          ld b,a        ; backup

;new.next = cur.next
          ld a,l
          ld l,chead_next:ld (hl),e:inc l:ld (hl),d
          ld e,a
          ld d,h        ; de= id new

          pop hl
          push hl
          call connect_phrase_from_id

;cur.next = new
          ld l,chead_next:ld (hl),e:inc l:ld (hl),d
          scf
          ld a,b        ; chunk_start
          pop hl:pop de:pop bc
          ret

hook_new_chunk
; Common interface: see new_phrase_chunk

; !! for now: only new_phrase_chunk_used
          push af
          ld a,ixl:cp new_chunk_ext AND &FF:call nz,mess
          ld a,ixh:cp new_chunk_ext/&0100:call nz,mess
          pop af
          jp ix


new_phrase_chunk
;---------------
;  in: N/A
; out: If ok: Carry.
            ; HL= chunk ID. (H=MSB, L=BANK)
            ; Chunk is connected.
      IF todo
; See why
      END
            ; A= end+1 (why?)
     ; Otherwise, NC
            ;  A= error code
     ; DE, BC preserved in any case.

          call connect_bk_phrase
          call New_chunk
          ret nc        ;exit if mem full

          push hl
          push de
          push bc
          ld a,l        ; bk for loop  
          ld d,h
          ld hl,phrase_def
          ld bc,phrase_def_ ;last word below
          jp _install_com

      IF 0
!! not needed
is_start_of_phrase
; IN: hl points on row
; OUT: Z if start of phrase
     ;NZ otherwise
     ; HL preserved in both case
          ld a,l
          cp phrase_start
          ret nz
      BRK
      END

is_end_of_phrase
; IN: hl points on row
; OUT: Z if end of phrase
     ;NZ otherwise
     ; HL preserved in both case
          push hl
          SKIP_LENGTH()
          ld a,(hl):cp mask_fx0:jr nz,.exit
          inc l
          ld a,(hl):cp fx_set_phrase_jp AND &FF:jr nz,.exit
          inc l
          ASSERT(phrase_start != chunk_start)
;phrase_start vs chunk_start: enough to discriminate
          ld a,(hl):cp phrase_start
.exit
          pop hl
          ret

goto_next_row
; Like skip_all, but skip eoc as well
;In:  HL: start of row
;Out: HL: start of next row
        ; Z if end of phrase
        ; BC, DE preserved.

          call skip_all
;enchaine
follow_link_if_eoc
          SKIP_LENGTH()
          ld a,(hl):cp mask_fx0:jr nz,.flie_ret__
          inc l:ld a,(hl)
          cp fx_set_phrase_jp AND &FF:jr nz,.flie_ret_
; EOC                    
          inc l:ld a,(hl)
          ASSERT(phrase_start != chunk_start)
;phrase_start: means loop to start of phrase 
          cp phrase_start:jr z,.flie_ret
          cp chunk_start:jr z,connect_next_chunk
          call mess     ;!! unexpected

.flie_ret
          dec hl        ; Preserve Z/NZ
.flie_ret_
          dec hl
.flie_ret__
          pos_flags ** dec hl
          ret

connect_next_chunk      ; !! Todo: rename connect_next_phrase_chunk
;-----------------
;in : hl pointe dans chunk (connected)
;Out: If has next chunk: NZ, HL: chunk start  A: bk chunk
    ; If no next chunk :  Z, NC (just side effect. Unused?)
                       ; H unchanged (for append)

      IF makeroom
; factorize with chunk.o
      END
          ld l,chead_next
          ld a,(hl):or a:ret z
          inc l
          ld h,(hl)
          ld l,a
          call connect_phrase_from_id
; 'ext' chunks don't have phrase header
          ld l,chunk_start
          ret

connect_phrase_from_id
;---------------------
;in : h=MSB, l=bk
;out: bk connected
    ; hl=chunk start **PAST phrase HEADER itself** (connected)
    ;  A=bk
    ; NZ (needed when coming from connect_next_chunk)
    ; BC, DE preserved
          call check_hl_in_bank
          call connect_l
          ld a,l

      IF chunk_start:ELSE
  !! trick NZ won't work
      END
          ld l,phrase_start-1:inc l ; NZ without changing A.
          ret

      IF 0
connect_phrase_from_bhl
;---------------------
          push hl
          ld l,b
          call connect_phrase_from_id
          pop hl
          ret
      END

;-------------- generic chunk operation
append_raw_in_chunk
      IF makeroom
; factorize with chunk.o and/or heap.o?
      END
; 'raw' because:
    ; - we don't deal with sentinel (in most cases we don't need it)
    ; - we don't need contiguity. 
      ; Just copy what fits and continue in new chunk.
    ; - [optim] we expect last chunk as a entry,
              ; so we don't have to follow the linked list.

; In: hl= source !! out of bank
    ;  b= bk dest
    ;  d= MSB dest (ie BD = ID of *last* chunk)
    ;  c= size
    ;  ix= routine new_chunk (returning HL:id, A:start)
    ; Bank agnostic    

; Out:  HL = id of new last chunk (can be the same). Needed by new_table
     ; BDE = dest start (i.e. insertion point). Rationale:
             ; - simpler client code (new_table)
             ; - avoid corner case when copy reaches end of chunk:
                 ; it would quirky to return "past the end" pnt then. 
           ; NB: that means BD is unchanged unless chunk was full.
     ; Last chunk inserted connected 
       ; Not a hard constraint for now -> might be revisited upon needs


; For now: BRK if size = 0 to detect programmation errors.
         ; Since i cannot think of a scenario were we would pass 0.
          inc c:dec c:call z,mess

          push hl
          ld h,d:ld l,b
          call connect_phrase_from_id
          ld e,chead_last:ld d,h
          ld a,(de):ld e,a ; point to last
          pop hl

          cpl           ; remaining size 
          cp c:jr c,$+3:ld a,c ; size1 = min(c,remaining)
          inc e:jr z,aric_full
          push de
          push bc
          ld c,a
          call _append
          pop bc        ;aric_com needs initial bank
          push bc
          call aric_com
          pop bc
          pop de
          ld l,b:ld h,d
          ret

aric_full
; Returned BDE must point to start of chunk
; Returned  HL = id of new chunk
; Yeah, nothing special to do!
aric_com
; Out: BDE points to start new chunk.  
     ; 
          neg:add c     ; remaining size
          ld c,a
          scf
          ret z

          push hl
          ld h,d:ld l,b
          call insert_new_chunk_from_id
          call connect_next_chunk:call z,mess
          ld e,l:ld d,h
          pop hl
          call _append
          ld b,a
          ld l,a:ld h,d
          scf
          ret

_append
; preserve DE (either needed to connect next chunk or as return value)
          push af
          push de
          ld b,0
          ldir
          ld a,e:dec a
          pop de
          ld b,e
          ld e,chead_last:ld (de),a
          ld e,b
          pop af
          ret

      IF 0
insert_in_chunk
; In:  hl= source !! out of bank
    ; bde= dest    (ie B= bank  DE= pos in chunk)
    ;   c= size    (0 = BRK)    
    ;  ix= routine new_chunk (returning HL:id, A:start)
    ;  iy= pointer to sentinel 'end of chunk' (size then data).
    ; Bank agnostic.
; Out: If ok: Carry, bde= past post dest (possibly new chunk)
            ; Chunk bde connected.
            ; HL= HL+c    

; See comments in shift_in_chunk below
          ex de,hl
          call shift_in_chunk
          ex de,hl
          ret nc

          ld a,b
          ld b,0
          ldir
          ld b,a
          scf
          ret
      END


shift_in_chunk
; Make room in chunk.
; In: bhl= dest    (ie B= bank  hl= pos in chunk)
    ;   c= size    (0 = BRK)    
    ;  ix= routine new_chunk (returning HL:id, A:start)
    ;  iy= pointer to sentinel 'end of chunk' (size then data).
         ; Nb: it would be nice to have only 1 hook since new chunk
             ; and sentinel are linked. It's not practical though,
             ; because we must follow the sequence:
                  ; - /hook_new_chunk/
                  ; - move tail
                  ; - /put_end_of_chunk/
    ; Bank agnostic.
; Out: If ok bhl= post dest (possibly new chunk) 
            ; Chunk bhl connected.
     ; Exception if mem full
     ; DE preserved

; If chunk is full, ALL the remaining from insertion point is moved:
   ; - No need to be smarter. We couldn't anyway, since data
     ; must remains contiguous (we wouldn't know where else to cut).
   ; - For phrase, sentinel must be moved unchanged. Works for both:
       ; - link to next chunk
       ; - link to phrase start

; NB: contrarily to orgams. No merge is performed (moved stuff is
    ; put in new chunk, not next one).
    ; -> Deemed unnecessary (merge done at load time)
    ; -> More complex code. We don't want that.

; Algorithm:
; ----------
; Let:
     ; x: the size before insertion point
     ; y: the shift size
     ; z: the size after insertion point
 ; Each option is considered in turn in the previous fails:
       ; (1) Try to fit x+y+z
       ; (2) Move z in new chunk, try to fit x+y
       ; (3) Try to fit y+z
       ; (4) Move z, y necessary fits in emptied chunk.

; Not optimized: In both (3) & (4) scenario, z has been moved twice.
; Instead we aim for short & simple code:
  ; The code from shift_in_row (chunge) was "optimized" and buggy. 

; For now: BRK if size = 0 to detect programmation errors.
         ; Since i cannot think of a scenario were we would pass 0.
          inc c:dec c:call z,mess
; For now: Doesn't support bigger than chunk size 
         ; since anyway inserted stuff must remain contiguous.
          ld a,c:cp chunk_free+1:call nc,to_be_implemented

          push hl
          ld l,b
          call connect_phrase_from_id
          pop hl

          call try_shift_in_chunk
          ret c

; Full: move trailing.
          call move_tail_in_new_chunk'

; Retry now that room was made.
          call try_shift_in_chunk
          ret c

; Try to insert in introduced chunk (options 3 & 4).
          call connect_next_chunk
          ld b,a
; Tail Recursion! NB: 2nd iteration will succeed unless memory full.
          jr shift_in_chunk


try_shift_in_chunk
;-----------------
; If it fits: shift, return Carry. Otherwise return NC.
; In:  hl= dest (this byte will be shifted).    
    ;   c= shift size   
    ;  A trashed, all other registers preserved.

          push bc:push hl
          ld a,l
          ld l,chead_last
          neg:add (hl):ld b,a:inc b ; size to copy
      IF dev_checks':call z,mess:END

          ld a,(hl)
          add c:jr c,_tsic_ret ; -> doesn't fit
; shift       
          ld (hl),a     ; new last
          push de
          ld e,a:ld d,h ; Dest
          sub c:ld l,a  ; Source
          ld c,b
          ld b,0
          lddr
          pop de
          or a
_tsic_ret
          ccf
          pop hl:pop bc
          ret


move_tail_in_new_chunk
;---------------------
; Insert new chunk and copy tail.
;in: hl=source
;out: reconnect source chunk     

; TODO: better factorization?

          push ix:push iy
          ld ix,new_chunk_ext
          ld iy,sentinel_phrase_eoc
          ld a,(bk_connected):ld b,a
          call move_tail_in_new_chunk'
          pop iy:pop ix
          ret


move_tail_in_new_chunk'
;----------------------
; in: bhl=source
    ;  IY=sentinel (size+data)  
    ;  IX=routine for new chunk (e.g. /new_phrase_chunk/)
;out: reconnect source chunk     
    ; bhl, de preserved

          call insert_new_chunk_from_bhl

          push bc:push de:push hl
          ld c,a        ; chunk_start

          ld e,chead_last
          ld d,h
          ld a,(de)
          sub l:IF dev_checks':call c,mess:END
          inc a
          ld e,c        ; chunk_start
          ld c,a        ; size
          call copy_from_chunk_to_next
          pop hl
;---------------
; Put sentinel 'end of chunk' 
; HL = cur chunk
; DE = next chunk
          ld a,d        ; for link
          push hl
          ex de,hl      ; de=dest in current chunk
          push iy:pop hl
      IF dev_checks'
;For now only one kind: strict sanity check.
          ld bc,sentinel_phrase_eoc
          or a:sbc hl,bc:add hl,bc:call nz,mess
      END
          ld c,(hl):inc hl
          inc c:dec c:jr z,.put_eoc
          ld b,0
          ldir
.put_eoc
      IF phrases_across_banks
 !!! review that. Use word for id, fx_set_phrase' would have to force
   ; L = chunk_start
      END
          ld (de),a     ; MSB next chunk (LSB in sentinel_phrase_eoc)

          ld a,e
          ld e,chead_last:ld (de),a
          pop hl
          pop de:pop bc
          scf
          ret

;-------------------------
get_phrase_id
; Used by track.o to convert pnt to id
; In: hl = phrase header
          call scope_bk_phrase
          ASSERT(fc_index == 0)
          ld a,(hl)
          ret

get_delai_ui
;Out a = delai_ui           
;Generic variables are in BK_BASE
          call scope_bk_base
          ld a,(delai_ui)
          ret

set_delai_ui
;In a = delai_ui
          call scope_bk_base
          ld (delai_ui),a
          ret

new_chunk_ext
;------------
; Like new_phrase_chunk, but no phrase header needed or desirable:
; it wouldn't make sense, as it is just an extension of the phrase.
; Also: Out:  A= chunk start (needed by insert_in_chunk)

      IF dev_checks'
; Assume bk phrase already connected
          call get_bk_connected
          cp BK_PHRASE:call nz,mess
      END

          call New_chunk
          ret nc
          call .install_ext
          ld a,chunk_start ; in const.i (shared with ply)
          ret

.install_ext
      IF makeroom
; Can be factorized by
; 1/ encoding size with chunk_def itself
; 2/ just passing LSB of chunk_def
      END
          push hl
          push de
          push bc
          ld a,l        ; bk for loop
          ld d,h
          ld hl,chunk_def
          ld bc,chunk_def_
;enchaine
_install_com
;header
          ld e,chead_last
          ldir
          ex de,hl
; We put link to start of chunk
; It will be copy if phrase takes more chunks,
; making looping easier
; NOTE1: lsb already set
; NOTE2: overwritten when linking to new chunk 
       ; (insert_new_chunk_from_id)
      IF phrases_across_banks
 !!! review that. Use word for id, fx_set_phrase would have to force
   ; L = phrase_start
      END
          ld (hl),h
      IF todo
; Why?
      END
          ld a,l:inc a
          pop bc
          pop de
          pop hl
          scf
          ret


; -----------------------------------------------
      MACRO CHECK_FIELD start,offset
      IF $-start - offset
 !!! error align 
      END
      ENDM

phrase_def
;-------
;phrase chunk header (after last, reset by new_chunk)
      BYTE phrase_def_+2 ; +2: field 'next'
      BYTE 0            ;checksum (unused now)
      BYTE 0            ; row# (mimic line# in orgams's chunk)
_header
;clip header
          CHECK_FIELD(_header,fc_index)
phrase_idx BYTE 
          CHECK_FIELD(_header,fc_type)
type_phrase = 1
      BYTE type_phrase
          CHECK_FIELD(_header,fc_name)
      WORD 0            ; Pnt name. Unused for now
          CHECK_FIELD(_header,fc_color)
phrase_color BYTE 
          CHECK_FIELD(_header,clip_header_size)

tag_end                 ; address used by chungnrt.o
;duration 0 = tag eof of phrase 
      BYTE 0
      BYTE mask_fx0
      BYTE fx_set_phrase_jp AND &FF
      BYTE phrase_start ; lsb self loop. MSB depends on chunk!
; !!! if changed review follow_link_if_eoc

tag_end_size = $ - tag_end + 1 ;+1: msb self floop
phrase_def_ = $ - phrase_def

chunk_def
;--------
;Standard chunk without phrase header.
;Used for tables(?) and phrases continuation (hence tag_end, which will
;be overwritten for tables)
      BYTE chunk_def_+3 ;+2: field 'next' +1: byte 
      BYTE 0            ;checksum (unused now)
      BYTE 0            ; row# (mimic line# in orgams's chunk)
      IF $ - chunk_def + 2 - chunk_start ;2: next field
  !! inconsistency. check const.i
      END
; ROW sentinel: makes sense for phrases cont, not table
; duration 0 (so ply doesn't change BC=tick)
; (also serve as tagging)
      BYTE 0
      BYTE mask_fx0
      BYTE fx_set_phrase_jp AND &FF
chunk_def_ = $ - chunk_def


; Maximum contiguous size in chunk.
; Actually could be a bit bigger since chunk_link_size < tag_end_size.
; Nevermind for now.
; Also, that's the max for the first chunk, for next (ext) it's bigger
chunk_free = &0100-phrase_def_-2 ; -2 next field

sentinel_phrase_eoc
      BYTE sentinel_phrase_eoc_ ; Size of sentinel for generic append
          pos_flags ** BYTE 0 ; duration
      BYTE mask_fx0
      BYTE fx_set_phrase_jp AND &FF
; link to next chunk: no more clip header, so starts at
; chunk_start rather than phrase start
      BYTE chunk_start
; !!! if changed review follow_link_if_eoc
sentinel_phrase_eoc_ = $ - sentinel_phrase_eoc - 1

      IF todo
; Factorize phrase_end+phrase_next_chunk into 'phrase_jump'?
    ; e.g. next_chunk: follow next
                ; end: follow loop
  ; (next and loop written like after phrase_end)
      END

; ----------------------------
vars
; Private/tmp vars alongside code (out of bank: no persistence needed)

row_t0 WORD             ; tmp
row_t1 WORD             ; tmp

va_savesp WORD 

dbg1  WORD 
dbg2  WORD 

; ----------------------------       
; Vars in bank
save_pc = $

def
; Doesn't use org va,$$
; otherwise orgams set high $ = 7cxx, which is inconvenient
      BYTE 
def_size = $-def

      ORG phrase_vars
var
delai_ui BYTE           ; root value

      IF $-var - def_size
 !! inconsistency
      END

zero_start              ; Not loaded, must follow def (see check below)
      IF zero_start - [var+def_size]
 !! must be contiguous to simplify init code
      END
va_current_phrase BYTE 
va_row_pnt WORD         ;address of currently selected row 
va_position WORD        ; position in phrase (in ticks)
zero_size = $-zero_start

pnt_next_row WORD 
time_next_row WORD 

      ORG save_pc

phrase_end

