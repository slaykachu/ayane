; <<<<<<<< Instrument editor >>>>>>>>>

; 2025                           
 ; Aug      
 ; -- v0am --
   ; 24 Inverse pitch for user comfort (+N= higher pitch)
 ; -- v0al --
   ; 21 deactivate main r13 when there is buzz
      ; _del_row: cursor up if it's the last
   ; 20 Fix sep after retrig          
 ; -- v0ak --          
   ; 07 smarter flip-flops for volume and co 
          ; e.g. activating sync buzz automatically set hard env
   ; 04 instr_row_ui: Add separators
      ; 8 lines of instr
   ; 02 instr_cold_refresh: display fields
   ; 01 Add jp instr_cold_refresh
 ; Jul
   ; 15 Extract ui loop   o  in uiloop.o
   ; 14 Extract manual setup in instruit.o 

;Lp X Vol  Arp Pitch Noise  H R Arp Pitch  Buz1 Arp Pitch Buz2 
;x  x F -- +12 -4095  x 31  A x +12 +1000   x A +10 +1000    
;   x 8 -  +12 -4095  x 31  A   +12 +1000   x A +10 +1000    
;   x 0    +12 -4095  x 31  A   +12 +1000   x A +10 +1000    

;todo: don't delete when only one row

to_be_implemented = &BE00
dev_checks = 1
hack_refresh = 1

      IMPORT "const.i"
      IMPORT "memmap.i"

      IMPORT "memcpc.o" ; reset_sp
      IMPORT "chung.o"  ; Model (instr get/set row)
      IMPORT "ged.o"
      IMPORT "timer.o"  ; for fx_null/sync_buzzer_register
      IMPORT "disp-jp.o"
      IMPORT "shortcut.o" ; for kcdel 

      FILL -$ AND &0F,&F7

;--------------------------------
      MACRO LOCATION x,y
          ld de,x*&0100 + y
      ENDM

      MACRO CALL_DS adr
 ; ds="disp status" status_* in disp.o
 ; disp-jp does the connection
      IF BK_DISP - &C7
 !!!! review
      END
          call adr
      ENDM

      MACRO RET_C_Z
; Ged expect Z for whatever reason
          xor a:scf
      ENDM

;--------------------------------
instrui_code
;-----------------
instr_cold_refresh
;-----------------
 ; -- bandaya
          LOCATION(x_pos_instr_ed,y_pos_instr_ed)
          ld bc,_fields
          CALL_DS(status_str_at)

 ; -- gedeihen 
          call gedeihen_init
 ; For now, keep default (firmware hooks)
 ;     call gedeihen_set_hooks 
          ld hl,&0101:call txt_set_cursor
          ld hl,instr_ui
          call setup_widget
;enchaine
refresh_all
          ld hl,&0101:call txt_set_cursor ; needed?
          call gedeihen_disp
reenter
          ld hl,&0101:call txt_set_cursor
          ld hl,instr_ui
          jp gedeihen_enter

;--------------------------------
instr_ui
;Put key_handler at root, since under multiline: not handler
;Refresh after insert/del line is handled in a adhoc maner,
;as we cannot yet use w_refresh twice in the tree.
      BYTE w_key_handler
      WORD instr_ui'
      WORD extra_handler

instr_ui'
      BYTE w_multiline
      WORD instr_row_ui
      WORD ui_get_rows#
      WORD ui_select_row
      WORD _insert_row
      WORD _del_row
      BYTE 8            ; Height
      BYTE 2            ; scroll offset (margin)

ui_get_rows#
;Return in A for ged 
          call instr_get_rows#
          ld a,c
          ret

ui_select_row
          ld (selected_line),a ; simpler than to ask back ged
          call select_row
          ld de,row_buffer:call get_row
          scf           ; OK
          ret

extra_handler
      BYTE kf+5:WORD _instr_down_refresh ; f5
      BYTE kf+8:WORD _instr_up_refresh ; f8
      BYTE 0:WORD 0

_del_row
;IN: A = line to delete   
          push af
          call instr_get_rows#
          or a          ; NC
          dec c
          pop bc
          ret z         ; NC: don't del if only one line 

          call del_row  ; in: B= row#  
          scf           ; del_row mustn't fail!
          ret

_insert_row
;In: A: line to insert
;Clone row                           
          push af
          ld de,row_buffer:call get_row
          pop af
          call insert_empty_row
          ld de,row_buffer:call instr_set_row
          scf           ; for now instr_set_row doesn't return flag
          ret

_instr_down_refresh
          call instr_down
          jr _instr_refresh

_instr_up_refresh
          call instr_up
_instr_refresh
          call instr_cold_refresh
          RET_C_Z()
          ret

instr_down
          call Song_get_instr
          cp 2:ret c    ; 1: no-op
          dec a
          jr instr_change

instr_up
          call Song_get_instr
          cp 99:ccf:ret c ; 99: no-op
          inc a
;enchaine
instr_change
          LOCATION(x_pos_instr#,y_pos_instr#)
          push af
          CALL_DS(status_deci_a_pad0_at)
          pop af
          ld c,a
          call Song_select_instr
          ret nz        ; Existing: nothing to do
; Create new instr
          ld a,c
          call New_instr_ayane
;New instr: add empty line (prevent ged assert)
          jp instr_append_empty_row

_fields
;Lp X Vol  Arp Pitch Noise E R Arp Pitch Buz1 Arp Pitch  Buz2 
      BYTE "Lp T Vol  Arp Pitch Noise  H Arp Pitch R "
      BYTE "Buz1 Arp Pitch  "
      BYTE "Buz2 Arp Pitch",0

instr_row_ui
      BYTE w_struct
      IF 1
      WORD loop_ui
      WORD sep1_ui
      WORD mixer_ui
      WORD vol_ui
      WORD sep3_ui
      WORD arp_ui
      WORD pitch_ui
      WORD sep1_ui
      WORD noise_flag_ui
      WORD noise_value_ui
      WORD sep1_ui
      WORD env_type_ui
      WORD env_arp_ui
      WORD env_pitch_ui
      WORD env_retrig_ui
      WORD sep1_ui
      END
      WORD fx0_type_ui
      WORD fx0_env_ui
      WORD fx0_arp_ui
      WORD fx0_pitch_ui
      IF 1
      WORD sep2_ui
      WORD fx1_type_ui
      WORD fx1_env_ui
      WORD fx1_arp_ui
      WORD fx1_pitch_ui
      END
      WORD 0

loop_ui
      BYTE w_toggle_custom
      WORD _set_loop
      WORD _get_loop

sep1_ui
;!! already 1 space by w_struct
      BYTE w_text,0
sep2_ui
      BYTE w_text," ",0
sep3_ui
      BYTE w_text,"  ",0

mixer_ui
      BYTE w_toggle_custom
      WORD _set_mix
      WORD _get_mix

vol_ui
      BYTE w_refresh
      WORD vol_ui'
vol_ui'
      BYTE w_key_handler
      WORD vol_ui''
      WORD vol_handler
vol_ui''
      BYTE w_optional_readwrite
      WORD vol_ui'''
      WORD is_volume
vol_ui'''
      BYTE w_hexa_digit_custom
      WORD _set_vol
      WORD _get_vol
vol_handler
      BYTE kclr:WORD _toggle_vol
      BYTE " ":WORD _toggle_vol
      BYTE 0:WORD 0


arp_ui
      BYTE w_deci_99_signed
      WORD _set_arp
      WORD _get_arp

pitch_ui
      BYTE w_deci_9999_signed
      WORD _set_pitch
      WORD _get_pitch

noise_flag_ui
      BYTE w_toggle_custom
      WORD _set_noise_flag
      WORD _get_noise_flag

noise_value_ui
      BYTE w_deci_99_custom
      WORD _set_noise_value
      WORD _get_noise_value

env_type_ui
      BYTE w_refresh
      WORD env_type_ui'
env_type_ui'
      BYTE w_key_handler
      WORD env_type_ui''
      WORD env_type_handler
env_type_ui''
; Optional (e.g. deactivated if volume not hard,
           ;but must be able to change it)
      BYTE w_optional_readwrite
      WORD env_type_ui'''
      WORD is_pure_env_hard
env_type_ui'''
      BYTE w_hexa_digit_custom
      WORD _set_env_type
      WORD _get_env_type

env_type_handler
      BYTE kclr:WORD _deactivate_env
      BYTE " ":WORD _toggle_env
      BYTE 0:WORD 0

env_arp_ui
      BYTE w_optional
      WORD env_arp_ui'
      WORD is_env_hard
env_arp_ui'
      BYTE w_deci_99_signed
      WORD _set_env_arp
      WORD _get_env_arp

env_pitch_ui
      BYTE w_optional
      WORD env_pitch_ui'
      WORD is_env_hard
env_pitch_ui'
      BYTE w_deci_9999_signed
      WORD _set_env_pitch
      WORD _get_env_pitch

env_retrig_ui
      BYTE w_optional
      WORD env_retrig_ui'
      WORD is_env_hard
env_retrig_ui'
      BYTE w_toggle_custom
      WORD _set_env_retrig
      WORD _get_env_retrig

fx0_type_ui
; For now toggle as there is only one type of fx
      BYTE w_refresh
      WORD fx0_type_ui'
fx0_type_ui'
      BYTE w_toggle_custom
      WORD _set_fx0_type
      WORD _get_fx0_type

fx0_arp_ui
      BYTE w_optional
      WORD fx0_arp_ui'
      WORD has_fx0
fx0_arp_ui'
      BYTE w_deci_99_signed
      WORD _set_fx0_arp
      WORD _get_fx0_arp

fx0_pitch_ui
      BYTE w_optional
      WORD fx0_pitch_ui'
      WORD has_fx0
fx0_pitch_ui'
      BYTE w_deci_9999_signed
      WORD _set_fx0_pitch
      WORD _get_fx0_pitch

fx0_env_ui
      BYTE w_optional
      WORD fx0_env_ui'
      WORD has_fx0
fx0_env_ui'
      BYTE w_hexa_digit_custom
      WORD _set_fx0_env
      WORD _get_fx0_env

fx1_type_ui
      BYTE w_refresh
      WORD fx1_type_ui'
fx1_type_ui'
      BYTE w_toggle_custom
      WORD _set_fx1_type
      WORD _get_fx1_type

fx1_arp_ui
      BYTE w_optional
      WORD fx1_arp_ui'
      WORD has_fx1
fx1_arp_ui'
      BYTE w_deci_99_signed
      WORD _set_fx1_arp
      WORD _get_fx1_arp

fx1_pitch_ui
      BYTE w_optional
      WORD fx1_pitch_ui'
      WORD has_fx1
fx1_pitch_ui'
      BYTE w_deci_9999_signed
      WORD _set_fx1_pitch
      WORD _get_fx1_pitch

fx1_env_ui
      BYTE w_optional
      WORD fx1_env_ui'
      WORD has_fx1
fx1_env_ui'
      BYTE w_hexa_digit_custom
      WORD _set_fx1_env
      WORD _get_fx1_env

_set_loop
          call instr_get_loop
          ld a,(selected_line)
          jr nc,.set
          cp b:jr z,.unset
          ld b,a
.set
          call instr_set_loop
; Hack: refresh all (since must erase previous loop marker)
          jr _refresh
.unset
          call instr_remove_loop
;enchaine
_refresh
;Refresh from root
          ld a,(selected_line):push af
          ld hl,state_stack
          call force_refresh_custom
;Hackish: selected_line was changed for disp
        ; (since calling ui_select_row)
          pop af:ld (selected_line),a
;For cursor (use refresh_focus instead?)
;Cannot use gedehein_enter now as delegate_width
;would reset multiline state.
;We rely on the fact force_refresh_custom use auxiliary stack,
;so the state is preserved.
          call enter
          scf
          ret

_get_loop
; Return 0 if selected_line = loop point
;          ld a,(dbg+4):cp &F7:call z,&BE00
          call instr_get_loop
          jr nc,_zero   ; no loop at all

          ld a,(selected_line)
          cp b
          jr nz,_zero
_nonzero
          xor a:inc a
          ret
_zero
          xor a
          ret


_set_mix
          ld c,7
_set_flags
          cpl
          and c
          ld b,a
          ld hl,row_buffer+instr_flags
          ld a,c
          cpl
          and (hl)
          or b
          ld (hl),a
_update_row
; Report change to actual row.
          ld de,row_buffer
          call instr_set_row
          RET_C_Z()
          ret

_get_mix
          ld c,7
_get_flags
          ld a,(row_buffer+instr_flags)
          cpl
          and c
          ret

_set_vol
          add a         ; Encoding
          ld (row_buffer+instr_vol),a
          jr _update_row

_get_vol  ld a,(row_buffer+instr_vol)
          srl a
          ret

_set_arp  add a         ; expect pre-encoded
          ld (row_buffer+instr_arp),a
          jr _update_row

_get_arp  ld a,(row_buffer+instr_arp)
          sra a         ; signed
      IF dev_checks
          call c,fail
      END
          ret

_set_pitch call neg_hl:ld (row_buffer+instr_pitch),hl:jr _update_row
_get_pitch ld hl,(row_buffer+instr_pitch):jp neg_hl

_set_noise_flag ld c,&38:jr _set_flags
_get_noise_flag ld c,&38:jr _get_flags

_set_noise_value
          ld (row_buffer+instr_noise),a
          ld a,&FF:call _set_noise_flag
; !!! infinite loop if _refresh_row via validate!?!
 ;          jr _refresh_row ; update flag noise
          call refresh_focus
          RET_C_Z()
          ret

_get_noise_value
          ld a,(row_buffer+instr_noise):ret

_toggle_vol
          ld hl,row_buffer+instr_vol
          ld a,(hl)
          xor flags_env_hard
          ld (hl),a
      IF hack_refresh
;Not sure why ui_refresh doesn't play its role 
          jr _refresh_row
      ELSE
          jr _update_row
      END

is_volume
;          ld a,(row_buffer+instr_vol):bit 0,a:call nz,&BE00
          ld a,(row_buffer+instr_vol):cpl:and flags_env_hard:ret

is_pure_env_hard
; when buzz activated, the main r13 doesn't make sense
          call is_env_hard
          or a:ret z
          call has_fx0_or_fx1
;Enchaine
not_a
;Negate zero/non-zero
          or a:jr z,.set1
          xor a
          ret
.set1
          inc a
          ret

is_env_hard
;A non zero if yes
          ld a,(row_buffer+instr_vol):and flags_env_hard:ret

_deactivate_env
          ld hl,row_buffer+instr_vol
          ld a,(hl):and flags_env_hard XOR &3F:ld (hl),a
          ld hl,row_buffer+instr_hard_type
flag_env_explicit = 5
mask_env_explicit = &20
          res flag_env_explicit,(hl)
          jr _refresh_row
_toggle_env
          ld hl,row_buffer+instr_vol
          ld a,(hl):xor flags_env_hard:ld (hl),a
_refresh_row
; Needed to (in)validate hard env fields.
          call _update_row
          call validate ; needed for w_refresh
          call refresh_focus
          RET_C_Z()
          ret

_activate_env
          push af
; %xyzzzz : x=flag explicitly set, y=retriger zzzz=env#
; Note: we don't store env type in volume, to allow "undo" when
      ; unselecting hard env: user get back original volume.
          ld hl,row_buffer+instr_vol
flags_env_hard = &21    ;bit 0 for rrca, bit 5 so already set for volume
          ld a,(hl):or flags_env_hard:ld (hl),a
          pop af
          ret

_set_env_type
          call _activate_env
          ld c,&0F
_set_env_type_
          and c:or mask_env_explicit
          ld b,a
          ld hl,row_buffer+instr_hard_type
          ld a,c
          cpl
          and (hl)
          or b
          ld (hl),a
          jp _update_row
_get_env_type
          ld c,&0F
_get_env_type_
          ld a,(row_buffer+instr_hard_type)
          and c
          ret

_set_env_retrig
          ld c,&10
          jr _set_env_type_
_get_env_retrig
          ld c,&10
          jr _get_env_type_

_set_env_arp
          add a
          ld (row_buffer+instr_hard_arp),a
          jp _update_row
_get_env_arp
          ld a,(row_buffer+instr_hard_arp)
          sra a
      IF dev_checks
          call c,fail
      END
          ret

_set_env_pitch call neg_hl:ld (row_buffer+instr_hard_pitch),hl
          jp _update_row
_get_env_pitch ld hl,(row_buffer+instr_hard_pitch):jp neg_hl


_set_fx0_type
;For now, just toggle
          call _fx0_type_pnt
_set_fx_type
          ld bc,fx_null
          or a:jr z,.set
          ld bc,sync_buzzer_register
.set
          ld (hl),c:inc hl
          ld (hl),b
;Refresh volume:
          jr z,.reset
; if set, set hard env flag
          call _activate_env
          jr .ok
.reset
;Remove env flag only if no other sync or explicit hard env
          call has_fx0:jr nz,.ok
          call has_fx1:jr nz,.ok
          call has_hard_env
          call z,_deactivate_env
.ok
          jp _update_row

has_hard_env
;NZ if yes (explicitly set hard env)
          ld hl,row_buffer+instr_hard_type
          bit flag_env_explicit,(hl)
          ret
has_fx0
;NZ if yes  (for now coincide with _get_fx0_type used for toggle)
_get_fx0_type
;For now, just toggle
;A = non-zero if set

; Test env hard (so deactivated when we put volume)
          call is_env_hard
          ret z
          call _fx0_type_pnt
      IF [fx_null AND &FF] - [sync_buzzer_register AND &FF]:ELSE
 !!! needs MSB to discrimate
      END
          ld a,(hl)
      IF dev_checks
          cp fx_null AND &FF:jr z,.ok
          cp sync_buzzer_register AND &FF:jr z,.ok
          call fail
.ok
      END
          xor fx_null AND &FF
          ret

_fx0_type_pnt
          ld c,0
_fx0_pnt
; Set hl=sub field fx0, and check proper setup
; In: C: fx0 field offset 
      IF dev_checks
          ld hl,row_buffer
          call _check_sfx
      END
          ld hl,row_buffer+fx0_type
          ld b,0
          add hl,bc
          ret

_set_fx0_arp add a:ld (row_buffer+fx0_arp),a:jp _update_row
_get_fx0_arp ld a,(row_buffer+fx0_arp)
          sra a
      IF dev_checks
          call c,fail
      END
          ret

_set_fx0_pitch call neg_hl:ld (row_buffer+fx0_pitch),hl:jp _update_row
_get_fx0_pitch ld hl,(row_buffer+fx0_pitch):jr neg_hl

; Each sync buzzer can set its own env type
_set_fx0_env ld (row_buffer+fx0_param),a:jp _update_row
_get_fx0_env ld a,(row_buffer+fx0_param):ret

_set_fx1_type
;For now, just toggle
          call _fx1_type_pnt
          jr _set_fx_type

has_fx0_or_fx1
;A = non-zero if set
          call has_fx0
          or a
          ret nz
;enchaine
has_fx1
;(for now coincide with _get_fx1_type used for toggle)
_get_fx1_type
;For now, just toggle
;A = non-zero if set
          call _fx1_type_pnt
      IF [fx_null AND &FF] - [sync_buzzer_register AND &FF]:ELSE
 !!! needs MSB to discrimate
      END
          ld a,(hl)
      IF dev_checks
          cp fx_null AND &FF:jr z,.ok
          cp sync_buzzer_register AND &FF:jr z,.ok
          call fail
.ok
      END
          xor fx_null AND &FF
          ret

_fx1_type_pnt
          ld c,0
_fx1_pnt
; Set hl=sub field fx0, and check proper setup
; In: C: fx0 field offset 
      IF dev_checks
          ld hl,row_buffer
          call _check_sfx
      END
          ld hl,row_buffer+fx1_type
          ld b,0
          add hl,bc
          ret

_set_fx1_arp add a:ld (row_buffer+fx1_arp),a:jp _update_row
_get_fx1_arp ld a,(row_buffer+fx1_arp)
          sra a
      IF dev_checks
          call c,fail
      END
          ret

_set_fx1_pitch call neg_hl:ld (row_buffer+fx1_pitch),hl:jp _update_row
_get_fx1_pitch ld hl,(row_buffer+fx1_pitch):jr neg_hl

; Each sync buzzer can set its own env type
_set_fx1_env ld (row_buffer+fx1_param),a:jp _update_row
_get_fx1_env ld a,(row_buffer+fx1_param):ret

neg_hl
; hl := -hl
          push af
          xor a:sub l:ld l,a
          ld a,0:sbc h:ld h,a
          pop af
          ret


clip_4095
; Clip into -4095 .. 4095
          bit 7,h
          jr nz,.neg
          ld bc,4095
          or a:sbc hl,bc:add hl,bc
          ret c
          jr ld_hl_bc
.neg
          ld bc,-4095
          or a:sbc hl,bc:add hl,bc
          ret nc
;enchaine
ld_hl_bc
          ld l,c
          ld h,b
          ret

; ----------- make dummy instr ---------------

      MACRO VOL n
; Encode as expected -> xxxx0
      BYTE n*2
      ENDM

      MACRO VOL_HARD
      BYTE flags_env_hard ; Bit 0 and 5 Set (so after rrca, bit set)
      ENDM

;----------------------------------------

      SKIP -$ AND &0F   ; easier debug
row_buffer SKIP instr_row_size_max
selected_line BYTE 0
