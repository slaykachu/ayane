; <<<<<<<< Instrument editor >>>>>>>>>

; 2025                           
 ; -- alpha1 --
 ; Nov
   ; 19 Move sep1_ui & co in ged.o
 ; -- v0au --
   ; 14 _set_loop: fix randomly set loop
   ; 10 s/dev_checks/dev_checks' to avoid ambiguity
 ; -- v0at --
 ; Oct 
   ; 16 Use disp.o directly
         ; Try to remove disp-jp dep altogher
         ; Already imported by uiloop and ??
   ; 15 Move instr_fields to doc-in/strings.o

to_be_implemented = &BE00
dev_checks' = 1

      IMPORT "const.i"
      IMPORT "memmap.i"
      IMPORT "macro.i"
      IMPORT "import.i"

      IMPORT "memcpc.o" ; reset_sp
      IMPORT "chung.o"  ; Model (instr get/set row)
      IMPORT "ged.o"
      IMPORT "timer.o"  ; for fx_null/sync_buzzer_register
;      IMPORT "disp-jp.o"
      BANK BK_DISP
          IMPORT_DISP()
          IMPORT_STRINGS()

;--------------------------------
      MACRO CALL_DS adr
 ; ds="disp status" status_* in disp.o
          ASSERT(BK_DISP == &C7)
          ASSERT(adr AND &C000 == &C000)
          call call_status:WORD adr
      ENDM

      MACRO RET_C_Z
; Ged expect Z for whatever reason
          xor a:scf
      ENDM

;--------------------------------
instrui_code
          jr instr_cold_refresh
          jr update_instr_in_status

;-----------------
instr_cold_refresh
;-----------------
 ; -- bandaya
          LOCATION(x_pos_instr_ed,y_pos_instr_ed)
          ld bc,instr_fields + &8000
          CALL_DS(status_str_at)

 ; -- Create instrument if empty 
          call Song_get_instr
          ld c,a
          call Song_select_instr
          jr nz,.exist
          ld a,c
          call New_instr_ayane
;Set 1 line (prevent ged assert, and user friendly)
      IF todo
; Not null row. E.g. tone + vol=f
      END
          call instr_append_empty_row
.exist

 ; -- gedeihen 
          call gedeihen_init
 ; For now, keep default (firmware hooks)
 ;     call gedeihen_set_hooks 
          ld hl,&0101:call txt_set_cursor
          ld hl,instr_ui
          call setup_widget
;enchaine
refresh_all
          ld hl,&0101:call txt_set_cursor ; needed?
          call gedeihen_disp
reenter
          ld hl,&0101:call txt_set_cursor
          ld hl,instr_ui
          jp gedeihen_enter

; ---------------------------------------
;Helpers (put first so update_instr_in_status reachable by jr)

instr_down
          call Song_get_instr
          cp 2:ret c    ; 1: no-op
          dec a
;enchaine
instr_change
          call Song_select_instr
;enchaine
update_instr_in_status
          call Song_get_instr
          LOCATION(x_pos_instr#,y_pos_instr#)
          CALL_DS(status_deci_a_pad0_at)
          ret

instr_up
          call Song_get_instr
          cp 99:ccf:ret c ; 99: no-op
          inc a
          jr instr_change

;--------------------------------
instr_ui
;Put key_handler at root, since under multiline: not handler
;Refresh after insert/del line is handled in a adhoc maner,
;as we cannot yet use w_refresh twice in the tree.
      BYTE w_key_handler
      WORD instr_ui'
      WORD extra_handler

instr_ui'
      BYTE w_multiline
      WORD instr_row_ui
      WORD ui_get_rows#
      WORD ui_select_row
      WORD _insert_row
      WORD _del_row
      BYTE 8            ; Height
      BYTE 2            ; scroll offset (margin)

ui_get_rows#
;Return in A for ged 
          call instr_get_rows#
          ld a,c
          ret

ui_select_row
          ld (selected_line),a ; simpler than to ask back ged
          call select_row
          ld de,row_buffer:call get_row
          scf           ; OK
          ret

extra_handler
      BYTE kf+5:WORD _instr_down_refresh ; f5
      BYTE kf+8:WORD _instr_up_refresh ; f8
      BYTE 0:WORD 0

_del_row
;IN: A = line to delete   
          push af
          call instr_get_rows#
          or a          ; NC
          dec c
          pop bc
          ret z         ; NC: don't del if only one line 

          call del_row  ; in: B= row#  
          scf           ; del_row mustn't fail!
          ret

_insert_row
;In: A: line to insert
;Clone row                           
          push af
          ld de,row_buffer:call get_row
          pop af
          call insert_empty_row
          ld de,row_buffer:call instr_set_row
          scf           ; for now instr_set_row doesn't return flag
          ret

_instr_down_refresh
          call instr_down
          jr _instr_refresh

_instr_up_refresh
          call instr_up
_instr_refresh
          call instr_cold_refresh
          RET_C_Z()
          ret

;----------------
instr_row_ui
      BYTE w_struct
      IF 1
      WORD loop_ui
      WORD sep1_ui
      WORD mixer_ui
      WORD vol_ui
      WORD sep3_ui
      WORD arp_ui
      WORD pitch_ui
      WORD sep1_ui
      WORD noise_flag_ui
      WORD noise_value_ui
      WORD sep1_ui
      WORD env_type_ui
      WORD env_arp_ui
      WORD env_pitch_ui
      WORD env_retrig_ui
      WORD sep1_ui
      END
      WORD fx0_type_ui
      WORD fx0_env_ui
      WORD fx0_arp_ui
      WORD fx0_pitch_ui
      IF 1
      WORD sep2_ui
      WORD fx1_type_ui
      WORD fx1_env_ui
      WORD fx1_arp_ui
      WORD fx1_pitch_ui
      END
      WORD 0

loop_ui
      BYTE w_toggle_custom
      WORD _set_loop
      WORD _get_loop


mixer_ui
      BYTE w_toggle_custom
      WORD _set_mix
      WORD _get_mix

vol_ui
      BYTE w_refresh
      WORD vol_ui'
vol_ui'
      BYTE w_key_handler
      WORD vol_ui''
      WORD vol_handler
vol_ui''
      BYTE w_optional_readwrite
      WORD vol_ui'''
      WORD is_volume
vol_ui'''
      BYTE w_hexa_digit_custom
      WORD _set_vol
      WORD _get_vol
vol_handler
      BYTE kclr:WORD _toggle_vol
      BYTE " ":WORD _toggle_vol
      BYTE 0:WORD 0


arp_ui
      BYTE w_deci_99_signed
      WORD _set_arp
      WORD _get_arp

pitch_ui
      BYTE w_deci_9999_signed
      WORD _set_pitch
      WORD _get_pitch

noise_flag_ui
      BYTE w_toggle_custom
      WORD _set_noise_flag
      WORD _get_noise_flag

noise_value_ui
      BYTE w_deci_99_custom
      WORD _set_noise_value
      WORD _get_noise_value

env_type_ui
      BYTE w_refresh
      WORD env_type_ui'
env_type_ui'
      BYTE w_key_handler
      WORD env_type_ui''
      WORD env_type_handler
env_type_ui''
; Optional (e.g. deactivated if volume not hard,
           ;but must be able to change it)
      BYTE w_optional_readwrite
      WORD env_type_ui'''
      WORD is_pure_env_hard
env_type_ui'''
      BYTE w_hexa_digit_custom
      WORD _set_env_type
      WORD _get_env_type

env_type_handler
      BYTE kclr:WORD _deactivate_env
      BYTE " ":WORD _toggle_env
      BYTE 0:WORD 0

env_arp_ui
      BYTE w_optional
      WORD env_arp_ui'
      WORD is_env_hard
env_arp_ui'
      BYTE w_deci_99_signed
      WORD _set_env_arp
      WORD _get_env_arp

env_pitch_ui
      BYTE w_optional
      WORD env_pitch_ui'
      WORD is_env_hard
env_pitch_ui'
      BYTE w_deci_9999_signed
      WORD _set_env_pitch
      WORD _get_env_pitch

env_retrig_ui
      BYTE w_optional
      WORD env_retrig_ui'
      WORD is_env_hard
env_retrig_ui'
      BYTE w_toggle_custom
      WORD _set_env_retrig
      WORD _get_env_retrig

fx0_type_ui
; For now toggle as there is only one type of fx
      BYTE w_refresh
      WORD fx0_type_ui'
fx0_type_ui'
      BYTE w_toggle_custom
      WORD _set_fx0_type
      WORD _get_fx0_type

fx0_arp_ui
      BYTE w_optional
      WORD fx0_arp_ui'
      WORD has_fx0
fx0_arp_ui'
      BYTE w_deci_99_signed
      WORD _set_fx0_arp
      WORD _get_fx0_arp

fx0_pitch_ui
      BYTE w_optional
      WORD fx0_pitch_ui'
      WORD has_fx0
fx0_pitch_ui'
      BYTE w_deci_9999_signed
      WORD _set_fx0_pitch
      WORD _get_fx0_pitch

fx0_env_ui
      BYTE w_optional
      WORD fx0_env_ui'
      WORD has_fx0
fx0_env_ui'
      BYTE w_hexa_digit_custom
      WORD _set_fx0_env
      WORD _get_fx0_env

fx1_type_ui
      BYTE w_refresh
      WORD fx1_type_ui'
fx1_type_ui'
      BYTE w_toggle_custom
      WORD _set_fx1_type
      WORD _get_fx1_type

fx1_arp_ui
      BYTE w_optional
      WORD fx1_arp_ui'
      WORD has_fx1
fx1_arp_ui'
      BYTE w_deci_99_signed
      WORD _set_fx1_arp
      WORD _get_fx1_arp

fx1_pitch_ui
      BYTE w_optional
      WORD fx1_pitch_ui'
      WORD has_fx1
fx1_pitch_ui'
      BYTE w_deci_9999_signed
      WORD _set_fx1_pitch
      WORD _get_fx1_pitch

fx1_env_ui
      BYTE w_optional
      WORD fx1_env_ui'
      WORD has_fx1
fx1_env_ui'
      BYTE w_hexa_digit_custom
      WORD _set_fx1_env
      WORD _get_fx1_env

_set_loop
          call instr_get_loop
          ld a,(selected_line)
          jr nc,.set
          cp b:jr z,.unset
.set
          ld b,a
          call instr_set_loop
; Hack: refresh all (since must erase previous loop marker)
          jr _refresh
.unset
          call instr_remove_loop
;enchaine
_refresh
;Refresh from root
          ld a,(selected_line):push af
          ld hl,state_stack
          call force_refresh_custom
;Hackish: selected_line was changed for disp
        ; (since calling ui_select_row)
          pop af:ld (selected_line),a
;For cursor (use refresh_focus instead?)
;Cannot use gedehein_enter now as delegate_width
;would reset multiline state.
;We rely on the fact force_refresh_custom use auxiliary stack,
;so the state is preserved.
          call enter
          scf
          ret

_get_loop
; Return 0 if selected_line = loop point
;          ld a,(dbg+4):cp &F7:call z,&BE00
          call instr_get_loop
          jr nc,_zero   ; no loop at all

          ld a,(selected_line)
          cp b
          jr nz,_zero
_nonzero
          xor a:inc a
          ret
_zero
          xor a
          ret


_set_mix
          ld c,7
_set_flags
          cpl
          and c
          ld b,a
          ld hl,row_buffer+instr_flags
          ld a,c
          cpl
          and (hl)
          or b
          ld (hl),a
_update_row
; Report change to actual row.
          ld de,row_buffer
          call instr_set_row
          RET_C_Z()
          ret

_get_mix
          ld c,7
_get_flags
          ld a,(row_buffer+instr_flags)
          cpl
          and c
          ret

_set_vol
          add a         ; Encoding
          ld (row_buffer+instr_vol),a
          jr _update_row

_get_vol  ld a,(row_buffer+instr_vol)
          srl a
          ret

_set_arp  add a         ; expect pre-encoded
          ld (row_buffer+instr_arp),a
          jr _update_row

_get_arp  ld a,(row_buffer+instr_arp)
          sra a         ; signed
      IF dev_checks'
          call c,fail
      END
          ret

_set_pitch call neg_hl:ld (row_buffer+instr_pitch),hl:jr _update_row
_get_pitch ld hl,(row_buffer+instr_pitch):jp neg_hl

_set_noise_flag ld c,&38:jr _set_flags
_get_noise_flag ld c,&38:jr _get_flags

_set_noise_value
          ld (row_buffer+instr_noise),a
          ld a,&FF:call _set_noise_flag
; !!! infinite loop if _refresh_row via validate!?!
 ;          jr _refresh_row ; update flag noise
          call refresh_focus
          RET_C_Z()
          ret

_get_noise_value
          ld a,(row_buffer+instr_noise):ret

_toggle_vol
          ld hl,row_buffer+instr_vol
          ld a,(hl)
          xor flags_env_hard
          ld (hl),a
      IF hack_refresh
;Not sure why ui_refresh doesn't play its role 
          jr _refresh_row
      ELSE
          jr _update_row
      END

is_volume
;          ld a,(row_buffer+instr_vol):bit 0,a:call nz,&BE00
          ld a,(row_buffer+instr_vol):cpl:and flags_env_hard:ret

is_pure_env_hard
; when buzz activated, the main r13 doesn't make sense
          call is_env_hard
          or a:ret z
          call has_fx0_or_fx1
;Enchaine
not_a
;Negate zero/non-zero
          or a:jr z,.set1
          xor a
          ret
.set1
          inc a
          ret

is_env_hard
;A non zero if yes
          ld a,(row_buffer+instr_vol):and flags_env_hard:ret

_deactivate_env
          ld hl,row_buffer+instr_vol
          ld a,(hl):and flags_env_hard XOR &3F:ld (hl),a
          ld hl,row_buffer+instr_hard_type
flag_env_explicit = 5
mask_env_explicit = &20
          res flag_env_explicit,(hl)
          jr _refresh_row
_toggle_env
          ld hl,row_buffer+instr_vol
          ld a,(hl):xor flags_env_hard:ld (hl),a
_refresh_row
; Needed to (in)validate hard env fields.
          call _update_row
          call validate ; needed for w_refresh
          call refresh_focus
          RET_C_Z()
          ret

_activate_env
          push af
; %xyzzzz : x=flag explicitly set, y=retriger zzzz=env#
; Note: we don't store env type in volume, to allow "undo" when
      ; unselecting hard env: user get back original volume.
          ld hl,row_buffer+instr_vol
flags_env_hard = &21    ;bit 0 for rrca, bit 5 so already set for volume
          ld a,(hl):or flags_env_hard:ld (hl),a
          pop af
          ret

_set_env_type
          call _activate_env
          ld c,&0F
_set_env_type_
          and c:or mask_env_explicit
          ld b,a
          ld hl,row_buffer+instr_hard_type
          ld a,c
          cpl
          and (hl)
          or b
          ld (hl),a
          jp _update_row
_get_env_type
          ld c,&0F
_get_env_type_
          ld a,(row_buffer+instr_hard_type)
          and c
          ret

_set_env_retrig
          ld c,&10
          jr _set_env_type_
_get_env_retrig
          ld c,&10
          jr _get_env_type_

_set_env_arp
          add a
          ld (row_buffer+instr_hard_arp),a
          jp _update_row
_get_env_arp
          ld a,(row_buffer+instr_hard_arp)
          sra a
      IF dev_checks'
          call c,fail
      END
          ret

_set_env_pitch call neg_hl:ld (row_buffer+instr_hard_pitch),hl
          jp _update_row
_get_env_pitch ld hl,(row_buffer+instr_hard_pitch):jp neg_hl


_set_fx0_type
;For now, just toggle
          call _fx0_type_pnt
_set_fx_type
;Here: A = 0 or non-zero, convert to type id
          or a
          push af       ; Z flag
          jr z,$+4:ld a,fx_type_sync_buzzer
;Note: it would be better to let chung do the conversion id->rout when
     ; updating row. nevermind for now.
          call fx_type_to_rout
          ld (hl),c:inc hl
          ld (hl),b
;Refresh volume:
          pop af
          jr z,.reset
; if set, set hard env flag
          call _activate_env
          jr .ok
.reset
;Remove env flag only if no other sync or explicit hard env
          call has_fx0:jr nz,.ok
          call has_fx1:jr nz,.ok
          call has_hard_env
          call z,_deactivate_env
.ok
          jp _update_row

has_hard_env
;NZ if yes (explicitly set hard env)
          ld hl,row_buffer+instr_hard_type
          bit flag_env_explicit,(hl)
          ret
has_fx0
;NZ if yes  (for now coincide with _get_fx0_type used for toggle)
_get_fx0_type
;For now, just toggle
;A = non-zero if set

; Test env hard (so deactivated when we put volume)
          call is_env_hard
          ret z
          call _fx0_type_pnt
_get_fx_type
          ld c,(hl):inc hl
          ld b,(hl)
          call fx_rout_to_type
          or a
          ret

_fx0_type_pnt
          ld c,0
_fx0_pnt
; Set hl=sub field fx0, and check proper setup
; In: C: fx0 field offset 
      IF dev_checks'
          ld hl,row_buffer
          call _check_sfx
      END
          ld hl,row_buffer+fx0_type
          ld b,0
          add hl,bc
          ret

_set_fx0_arp add a:ld (row_buffer+fx0_arp),a:jp _update_row
_get_fx0_arp ld a,(row_buffer+fx0_arp)
          sra a
      IF dev_checks'
          call c,fail
      END
          ret

_set_fx0_pitch call neg_hl:ld (row_buffer+fx0_pitch),hl:jp _update_row
_get_fx0_pitch ld hl,(row_buffer+fx0_pitch):jr neg_hl

; Each sync buzzer can set its own env type
_set_fx0_env ld (row_buffer+fx0_param),a:jp _update_row
_get_fx0_env ld a,(row_buffer+fx0_param):ret

_set_fx1_type
;For now, just toggle
          call _fx1_type_pnt
          jr _set_fx_type

has_fx0_or_fx1
;A = non-zero if set
          call has_fx0
          or a
          ret nz
;enchaine
has_fx1
;(for now coincide with _get_fx1_type used for toggle)
_get_fx1_type
;For now, just toggle
;A = non-zero if set + Flag Z/NZ for some callers
          call is_env_hard
          ret z
          call _fx1_type_pnt
          call _get_fx_type
          or a
          ret

_fx1_type_pnt
          ld c,0
_fx1_pnt
; Set hl=sub field fx0, and check proper setup
; In: C: fx0 field offset 
      IF dev_checks'
          ld hl,row_buffer
          call _check_sfx
      END
          ld hl,row_buffer+fx1_type
          ld b,0
          add hl,bc
          ret

_set_fx1_arp add a:ld (row_buffer+fx1_arp),a:jp _update_row
_get_fx1_arp ld a,(row_buffer+fx1_arp)
          sra a
      IF dev_checks'
          call c,fail
      END
          ret

_set_fx1_pitch call neg_hl:ld (row_buffer+fx1_pitch),hl:jp _update_row
_get_fx1_pitch ld hl,(row_buffer+fx1_pitch):jr neg_hl

; Each sync buzzer can set its own env type
_set_fx1_env ld (row_buffer+fx1_param),a:jp _update_row
_get_fx1_env ld a,(row_buffer+fx1_param):ret

neg_hl
; hl := -hl
          push af
          xor a:sub l:ld l,a
          ld a,0:sbc h:ld h,a
          pop af
          ret


clip_4095
; Clip into -4095 .. 4095
          bit 7,h
          jr nz,.neg
          ld bc,4095
          or a:sbc hl,bc:add hl,bc
          ret c
          jr ld_hl_bc
.neg
          ld bc,-4095
          or a:sbc hl,bc:add hl,bc
          ret nc
;enchaine
ld_hl_bc
          ld l,c
          ld h,b
          ret

; ----------- make dummy instr ---------------

      MACRO VOL n
; Encode as expected -> xxxx0
      BYTE n*2
      ENDM

      MACRO VOL_HARD
      BYTE flags_env_hard ; Bit 0 and 5 Set (so after rrca, bit set)
      ENDM

;----------------------------------------

      SKIP -$ AND &0F   ; easier debug
row_buffer SKIP instr_row_size_max
selected_line BYTE 0
