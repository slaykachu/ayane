; ---------------------------
; Ayane main entry point / ui
; ---------------------------

; 2025
 ;--- alpha 1 ---
  ; Dec
   ;25: CTRL-O to open .aya
      ; plug phrase editor 
 ;--- v0au ---
  ; Nov             
   ;15: save_command: edit name
   ;11: save_command: proper cls and return
   ; 7: Load ayalib2 (track+init no more available via ayalib)
 ;--- v0at ---
  ; Oct
   ;16: + IMPORT_STRINGS()
 ;--- v0aq ---
  ; Sep
   ;28: CTRL-SPACE, CTRL-S, clear_status_last_line
 ;--- v0ak ---
  ; Aug
   ; 9: Migrate uientry.o here
 ;--- 
     ; Jun 18  Plug instr-sel

dev   = 1
dev_checks = 1
todo  = 1
need_room = 1

client_ayane = 1
r2    = 46              ; defaut
r2'   = 50              ; sequence

      IMPORT "const.i"  ; kesc
      IMPORT "memmap.i" ; bk_disp, code_main, ...
      IMPORT "import.i"
      IMPORT "macro.i"

      ORG code_start
      ENT start

      IF 1
          IMPORT_CORE()
      LOAD "ayalib0.bin"
      ORG phrase
      LOAD "ayalib2.bin"
      ELSE
;for debug: import sources
          IMPORT_SHARED_DEPS_ALL()
          ASSERT(instr_code == instr_module)
       ;   IMPORT_SHARED_DEPS()
          IMPORT_SHARED_DEPS''()
          ASSERT(track_code == track_module)
 !! todo: load uiloop bin
      ORG fx_module
      LOAD "ayalib2'.bin" ; ply and init
      END

; All text/fonte/disp routines in dedicated bank
; Imported now to avoid forward ref in CALL_DISP/CALL_DISP_BK
      BANK BK_DISP
          LOAD_FONTS()
          IMPORT_DISP()
          LOAD_PIANOUI()
          IMPORT_STRINGS()
; See /disp_ext/ for other routines in /DISP_BK/
; GED and BANDAYA imported at the end

; We don't use the address directly, that's just a sanity check.
          ASSERT(memcpc_code == memcpc)

      SKIP code_main - $

; ---------------------------------------------
CRTC_R1_STATUS = 48     ; Setup BYTE widget
      IF CRTC_R1_STATUS - 48
   !! must update widget.CRTC=R1 *and* widget.y_to_offset
  ; Note: 48 is too big for some monitors.
        ; nevermind for now
      END
CRTC_R1_IO = 40         ; todo: check if used by disp
CRTC_R2_IO = 46
MAX_FILENAME_SIZE = 90  ; room for open: and cursor

km_reset = &BB03
km_read_key = &BB09
km_test_key = &BB1E

full_init = init_module
dummy_instr_ui = init_module+2
New_module = track_module+3
Song_attach_empty_phrases = track_module+6

ui_init_ged_null = uiloop
ui_init_band = uiloop+2
ui_process_key = uiloop+4

instr_selector_init = instrsel

instr_cold_refresh = instrui
update_instr_in_status = instrui+2

phrase_cold_refresh = phrasui
phrase_process_key = phrasui+3

load_file = salo
save_file = salo+2

Amorce_song = ply
;play  = ply+3
piano_play_song = playsong_module
field_editor = field_module

; ---------------------------------------------

      MACRO CALL_DISP adr
; When caller already in bank
          ASSERT($ AND &C000 == &4000)
          ASSERT(adr AND &C000 == &4000)
          call adr
      ENDM

      MACRO CALL_DISP_BK adr
; When caller out of bank
          ASSERT($ AND &C000 != &4000)
   ;       ASSERT(adr AND &C000 == &4000) (cannot check: forward ref)
          call call_disp:WORD adr
      ENDM

      MACRO SET_CRTC reg,val
!! use bandaya to set crtc (cheaper to do it there)
          call set_crtc:BYTE reg,val,-1
      ENDM

      MACRO ENTER ui_screen
;Remember last entered screen, for: 
  ; ESC in instr_selector_entry and incoming other selectors
  ; Post fatal error (assert.o)
          ld hl,ui_screen
          ld (reenter_jp),hl
;unwind stack (i.e. ui_process)
          call reset_sp
      ENDM


;-----------------------------------------------
; Firmware routines
;-----------------------------------------------

;disc_in_open = &BC77
;disc_in_close = &BC7A
;disc_in_abandon = &BC7D
;disc_test_eof = &BC89   ; NC if eof
;disc_in_direct = &BC83  ; In: hl=destination

;disc_out_open = &BC8C
;disc_out_close = &BC8F
;disc_out_abandon = &BC92

scr_set_mode = &BC0E
scr_ink_set = &BC32

mc_set_mode = &BD1C

mess  = &BE00

err_io = 1
err_too_big = 2
; -------------------------------

;---------
start
;---------          
          call set_sp_backup
; Entry point after io_postlude
; do it first in case of assert error
          ENTER(ayane_entry)

          call full_init
          CALL_DISP_BK(start_disp_bk)

      IF 1
; Empty module, but with phrases so tracks aren't empty
          call New_module ; wasn't done by full init!? maybe for salo
          call Song_attach_empty_phrases
;          call dummy_instr_ui ; TMP test
      ELSE
; load module 
          call io_prelude
          ld hl,name_module
          ld de,tmp_buf
          push de
;routine is not in DISK_BK, but name_module is
          CALL_DISP_BK(copy_nt)
          pop hl
          ld bc,0
          call load_file
      END
          jp io_postlude

;----------
ayane_entry
;----------
          call ui_init_ged_null
          call clear_status_last_line
          CALL_DISP_BK(help)

ui_loop_no_exit
;Common loop for all screens. Well, except phrase editor below
          call ui_process
          jr ui_loop_no_exit

ui_process
          call km_wait_key
_ui_process_com
          call ui_process_key
          ret c
;_fallback
          ld c,a
          ld hl,shortcuts
          call scan_key
          ret nc
          jp hl

phrase_ed_entry
;--------------
          ENTER(phrase_ed_entry)
          ld a,2:call scr_set_mode
          CALL_DISP_BK(phrase_cold_refresh)
;enchaine
.phrase_loop_no_exit
          CALL_DISP_BK(.ui_process_phrase)
          jr .phrase_loop_no_exit

.ui_process_phrase
; First, call this:
  ; - Must catch piano key for modif
  ; - There is post-process after gedeihen action
          call km_wait_key
          call phrase_process_key
          ret c
; second chance for f5/f8 etc...
          jr _ui_process_com

      IF dev
exit
;Exit if control+esc to e.g. test ESC when CTRL-S
          ld a,23       ; CTRL
          call km_test_key
          ret z
          call reset_sp
          ret
      END

play_song
; No ENTER: must return to screen
          call Song_get_first_track
          call get_track_header
          ld a,3
          call Amorce_song
;play_song does DI. So it automatically turn off status.
;But then when putting back EI, INTs might be out of sync.
;So we explicitly turn off/on.
;!!copy-pasted from uiloop.o (can't put in macro.i: status_o* undefined)
          call status_off
          call piano_play_song ; ret when ESC or space pressed
          ei
          call km_reset ; Eat ESC
          call km_read_key ; km_reset not enough
          call status_on
          scf
          ret



;-----------------------------------------------
; Screens (sequencer, instr ed/sel)
;-----------------------------------------------
; <<< UI for each screen >>>

      IF 0
sequencer
; Do screen setup here, as we don't want to add bandaya dep to track.o
; (might be moved in a newly introduced trackui.o, though)
          ENTER(.sequencer_)
.sequencer_
          ld hl,mode_sequencer:ld (hook_top),hl
          ld hl,no_op:ld (hook_int2),hl
          ld hl,mode_help:ld (hook_int3),hl
          jp ui_sequencer

      END

cls'
; For now disp.cls disable interruption
; Todo: reactivate them in the loop.
      ; better: leave them always ei, erase the last &40 by hand
          ld a,2:jp scr_set_mode

instr_selector_entry
;!!! No /ENTER/ here: it's a selector. 
          call reset_sp ; in case called from itself
          call cls'
          call clear_status_last_line
          call instr_selector_init
.lp
          call ui_process
          push af

          pop af
          cp 13:jr z,instr_ed_entry_
          cp kesc
          jr nz,.lp
          jp reenter_last

instr_ed_entry_
          call update_instr_in_status
instr_ed_entry
;-------------
          ENTER(instr_ed_entry)
end_of_screens          ; After last /ENTER/ for static check
          ld a,2:call scr_set_mode
          ld bc,text_instred
          ld de,screen + CRTC_R1_IO*2*9
          CALL_DISP_BK(display_page)
          call instr_cold_refresh
          jp ui_loop_no_exit

; ---------------------------------------------
io_prelude
;---------  
; !!! Client out of bank (we connect C1)
; Switch to classical display for proper display of amsdos messages
; Also, allow to use page C0:4000       
;Out: HL= tmp_buf
    ; BC= 0 (meta size)
          call status_off ; first so that cls is faster!
       ;   CALL_DISP_BK(cls)
          ld a,2:call &BC0E ; For amsdos error message
       ;   call set_crtc:BYTE 1,CRTC_R1_IO,2,CRTC_R2_IO,-1
          ld bc,&7FC1:out (c),c
          ld hl,io0+&8000
          ld de,io
          ld bc,io0_
          ldir
          ld hl,tmp_buf
;          ld bc,0   ; already at 0
          ret

_error
          ld a,err_io
io_error
;-------      
          CALL_DISP_BK(disp_err_message)
          call &BB06
;enchaine      
io_postlude
;----------
; Switch back to ayane display
; CRTC done by bandaya
      IF 0
; no, handled by bandaya
          call flyback
          ld de,r2*&0100 + r2'
          call r2_transition
      END
          call connect_bk_io
          call clearstatus ; while c0 connected
          call connect_bk_base
          call ui_init_band ; !! also set instr 1 
          ei
          call status_on
          jp return_to_screen

;-----------------------------------------------
; Commands
;-----------------------------------------------

open_command
;-----------                        
          CALL_DISP_BK(edit_filename)
          ret nc
;Out of bank: save_file doesn't reconnect bk. 
; AND: io_prelude must connect C1 to install io0
          call io_prelude
          call load_file
          jp io_postlude

save_command
;-----------                        
          CALL_DISP_BK(edit_filename)
          ret nc
;Out of bank: save_file doesn't reconnect bk. 
; AND: io_prelude must connect C1 to install io0
          call io_prelude
          call save_file
          jp io_postlude


clear_status_last_line
          LOCATION(0,y_pos_last_line)
          CALL_STATUS(status_clear_from)
          ret
;-----------------------------------------------
; Tables, variables and co 
;-----------------------------------------------

shortcuts
;"screens" -> no return
      BYTE "H"-&40:WORD ayane_entry
      BYTE kcf+2:WORD phrase_ed_entry
      BYTE kcf+3:WORD instr_ed_entry
;commands
      BYTE "I"-&40:WORD instr_selector_entry
      BYTE kcspc:WORD play_song
      BYTE "O"-&40:WORD open_command
      BYTE "S"-&40:WORD save_command
;misc
      IF dev
      BYTE kesc:WORD exit
      END
;      BYTE "o":WORD open
      BYTE 0


hi
          LIMIT(ramlimit)

;-----------------------------------------------
; Display management
;-----------------------------------------------

disp_ext
      BANK BK_DISP
      ORG phrasui       ; after disp/pianoui
      LOAD "ayaphras.bin"

      ORG disp_ayane
          IMPORT_DISP()
; 'status' and 'help' are calling disp directly, putting it here ensure 
;  proper bank is connected
disp_ext_start
      ORG $ + &8000,$$  ; Bank c1
      IMPORT "status.o"
      ORG $ - &8000
      IMPORT "help.o"
io0
      LOAD "ayaio.bin"
io0_  = $ - io0

init_disp_bk
;-----------
      IF 0
;for quick tests
          ld hl,name_file_dbg
          ld de,name_file
;copy_nt not in bank, but must connect for name_file
          call copy_nt
      ELSE
     ;      xor a:ld (name_file),a
      END
          ld a,CRTC_R1_IO
          CALL_DISP(init_disp)
          ret

text_welcome LOAD "doc-in/welcome.txt"
      BYTE 0
text_instred LOAD "doc-in/instred.txt"
      BYTE 0

disp_err_message
;---------------
;In: A: Message number (1 indexed)
          call get_err_message
          call disp_text_nl
          ret

get_err_message
;--------------
;In: A: Message number (1 indexed)
;Out: HL: Pointer to message (in corresponding bank)

          ld b,a
          ld hl,messages_error
.lp
          dec b
          ret z
          call skip_nt
          jr .lp

messages_error
      BYTE "message 1",0
      BYTE "message 2",0



_txt_open BYTE "Open:",0

start_disp_bk
          call init_disp_bk
          ld hl,text_welcome
          ld de,text_welcome
          call conv_protext
          ld hl,text_instred
          ld de,text_instred
          call conv_protext
    ;       call help_init ; Move in full_init? Doesn't matter!
          ld hl,vampsync
          ld de,name_module
          call copy_nt
          jp firm2shift ; from BASIC 

;vampire BYTE "testdata/vampire1.aya",0
vampsync BYTE "vampsync.aya",0

;---------------------
help
;---------------------
;Welcome message / help: same thing for now  
          ld a,2:call mc_set_mode
          xor a:ld b,a:ld c,a:call scr_ink_set
          ld a,1:ld bc,&1A1A:call scr_ink_set
          call cls
          ld bc,text_welcome
          ld de,screen
          call display_page
          ret

;-----------------------------------------------
; Common helpers
;-----------------------------------------------

; They are put in disp BK as soon as text is involved.
  ; - Ensure we access fields in bank 
       ; (e.g. field_editor doesn't depend on disp, but the field
         ;under modification is in DISP BK)
  ; - No need to use CALL_DISP once we're here.
  ; - Central RAM is more precious.
      IF 0
question
;-------
;In: HL: Text to display
   ; DE: Field
;  BANK_DISP connected (since manipulating field to be displayed)

;Out: Carry if no ESC  (and field copied to TMP_BUF)

          push de
          ld de,&0200 + status_line_question
          call disp_infos_com ; Update D: pos X
          inc d         ; Hack. otherwise points to last char
          pop hl        ; Field

          call saisie_champ

          push af
          call nc,ClearQuestion ; if exit: clear
          pop af

; Copy out of bank to ease io (open etc...)
          ld de,TMP_BUF
          ld bc,MAX_FILENAME_SIZE
          ldir
          ret

      END

saisie_champ
;-----------
; Copy/paste from ed.o
; Edition champ avec texte pre-rempli

;   in: D position curseur X
      ; HL adresse champ a remplir
;  out: Carry si ok 
      ; HL preserved
      ; NC si annulation (ESC)

;Place cursor at end of string.
;Cannot use c=-1 here since it's not handled by inv_cursor.
          call get_len:ld c,a

          ld e,&80      ; Flag selected
          ld b,MAX_FILENAME_SIZE+1
.edit_loop
; Regs like oFieldEditor  + D = pos X field

;display   
          call field_refresh_wait_key
          ret z         ; Exit

          dec b         ; Remove rab for cursor
          call field_editor
          inc b
          jr .edit_loop

field_refresh_wait_key
;---------------------
; Field refresh and test key.
; In: HL: Field (preserved)
    ; D : pos X field
    ;  E: flags (selected)
    ; B : length field
    ; Out:  A: key code.
         ;  Z if exit (Carry: return, NC: ESC)
         ; NZ: all other keys

          push de
          ld a,e
          ld e,y_pos_last_line
          set 7,h       ; +&8000 (c1)
          CALL_STATUS(field_refresh)
          res 7,h
          pop de

          call km_wait_key
          cp kesc:ret z ; ESC: NC
          cp kreturn:ccf ; C & Z: Return
          ret           ; NZ if otherkeys


; ----------------------------------
edit_filename
;in bk disp for name handling    
          ld hl,name_module
          ld d,5
          call saisie_champ
          push af
          call clear_status_last_line
          pop af
          ret nc

          ld hl,name_module
          ld de,tmp_buf
          call copy_nt
          scf
          ret


; ----------------------------------
          LIMIT(strings)

disp_ext_end = name_module ; after strings imported in IMPORT_STRINGS


;!!! Still in bank C7
; -------------------------------

      ORG salo
      LOAD "ayasalo.bin"

      SKIP ged-$
      LOAD "ayalib1.bin"
          ASSERT($ <= bandaya)
          IMPORT_BANDAYA() ; firm2status, status_on
      SKIP bandaya_end - $

          ASSERT($ <= ramlimit')

      IF dev
      SAVE "!!! set dev = 0",0,0
      ELSE
      SAVE "ayane0.bin",code_start,hi-code_start,start
      BANK BK_DISP
      SAVE "ayane1.bin",fonte_gris,disp_ext_end-fonte_gris
      SAVE "ayane2.bin",salo,bandaya_end-salo
      END
