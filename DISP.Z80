; Disp: text display. From Orgams.
   ; Difference: status_*: same API than disp_* (e.g. BC for text)

; 2025     
; -- alpha 1 --
 ; Dec
   ; 27 Add disp_locate[_y], disp_place_cursor
   ; 26 Add status_error
      ; Remove check for status_* (cannot "assert"), since those
        ; routine are use to display assert error
 ; Nov      
   ; 16 dh_* routines for phrases (h: halfsize / highres)    
; -- v0au --
   ; 15 Adapt /status_inv_cursor_at/ for ayane's status
   ; 10 s/dev_checks/dev_checks' to avoid ambiguity
; -- v0aq -- 
 ; Oct
     ;15 Add status_paragraph_at:
            ; - less code in client area
            ; - C1 connected to read final 0

todo  = 1
dev_checks' = 1

screen' = &4000         ; for status

      IF todo
; !!!! remove is_ei
; Harmonize naming (e.g. status_char_at takes de=cursor
                   ; but disp_char_at   takes de=offset)
      END

enable = 1

      IMPORT "memmap.i"
      IMPORT "const.i"
      IMPORT "macro.i"
      IMPORT "import.i"
pccheck
      IMPORT "assert.o"
      IMPORT "conv.o"
      IF $ != pccheck
  !! must have been imported beforehand
      END
; Cannot use IMPORT_STRINGS (bug orgams wip)
      ORG strings
      IMPORT "doc-in/strings.o" ; txt_mess and co
      ORG pccheck

      IF fonte_gris AND &03FF
 !! error align   ; must be 0 mod &400
      END

      IF fonte AND &03FF
 !! error align   
      END

      ORG disp

      BYTE "DI"         ; marker for dev_checks

; ------------- 
; Jump points in memmap.i
          jp status_error

      IF enable
str_pad
          ld de,(vo_scrpos)
str_pad_at
;In: hl= nt string
   ; de= pos screen
   ;  b= len (padding or clipping may occur)

; NB: when coming from str_pad_at_ei with b=0,
    ; we must update vo_scrpos so client can chain with no _at_ routines
          inc b:dec b:jp z,_disp_ret_

; Copy/paste disp_chr_ for faster loop.
          di
          ld (vo_savesp),sp
          ld ixl,b
          ld c,l:ld b,h
          ld iy,spa_ret
spa_lp
          ld a,(bc)
          or a:jp z,disp_space_ ; 0: stay at same place
          inc bc
          jp disp_chr_internal
spa_ret
          ld de,1-&2000
          add hl,de
          res 3,h
          ex de,hl
          dec ixl
          jr nz,spa_lp
          jp disp_ret_

;------------
str_pad_shaded_ei
          ld de,(vo_scrpos)
str_pad_shaded_at_ei

          ld iyh,fonte_gris/&0400
          jr str_pad_com

;------------
str_pad_ei
          ld de,(vo_scrpos)
str_pad_at_ei
; As str_pad_at but reactivate int for rupture.
; Todo: remove str_pad_at

          ld iyh,fonte/&0400

str_pad_com
; NB: when coming from str_pad_at_ei with b=0,
    ; we must update vo_scrpos so client can chain with no _at_ routines
          inc b:dec b:jp z,_disp_ret_

          ld iyl,b
spae_lp
          ld a,(hl)
          or a:jr z,disp_space2_ ; Stay at same place

          inc hl
          cp &20
          jr z,disp_space2

          ld b,iyh
          add a         ;NB: Inv not handled here
      2 ** [add a:rl b]
          ld c,a

   ;0-1 
          ld a,(bc)
          ld (de),a
          inc c:ld a,(bc)
          set 3,d:ld (de),a
   ;3-2
          inc c:ld a,(bc)
          set 4,d:ld (de),a
          inc c:ld a,(bc)
          res 3,d:ld (de),a
   ;6-7
          inc c:ld a,(bc)
          set 5,d:ld (de),a
          inc c:ld a,(bc)
          set 3,d:ld (de),a
   ;5-4
          inc c:ld a,(bc)
          res 4,d:ld (de),a
          inc c:ld a,(bc)
          res 3,d:ld (de),a

          jr spae_next


disp_space2
          xor a
disp_space2_

          ld (de),a
          set 3,d:ld (de),a
          set 4,d:ld (de),a
          res 3,d:ld (de),a
          set 5,d:ld (de),a
          set 3,d:ld (de),a
          res 4,d:ld (de),a
          res 3,d:ld (de),a

spae_next
          inc de
          ld a,d:and &C7:ld d,a

          dec iyl
          jr nz,spae_lp

          ld (vo_scrpos),de
          ret
      END

init_disp
;in A = Reg1
          ld (vo_reg1),a
          ld de,screen_main
disp_locate_scr
          ld (vo_scrpos0),de
          ld (vo_scrpos),de
          ret


cls
;corrupt hl, de, af
;!! disable interruptions

          di
          xor a
          ld l,a
          ld h,a
          ld e,a
          ld d,a
          add hl,sp
          ex de,hl
          ld sp,hl
;
cls_lp
      FILL 32,&E5       ;push hl
          dec a
          jr nz,cls_lp

          ld (vo_scrpos0),sp ;$C000
          ld (vo_scrpos),sp ;$C000

          ex de,hl
          ld sp,hl
          ret

      IF enable
disp_chr_at_
          ld h,fonte/&0400 + &80
          jr _disp_chr
disp_chr
          ld de,(vo_scrpos)
disp_chr_at
;in: a=chr (bit 7 for video inverse)
   ;de=screen dest
;out:de=new pos
    ; a=new cursor x
    ;hl trashed

          ld h,fonte/&0400
_disp_chr
          di
          ld (vo_savesp),sp
          ld iy,disp_ret
          jp disp_chr_internal_

disp_chr_shaded
          ld de,(vo_scrpos)
disp_chr_shaded_at
          ld h,fonte_gris/&0400
          jr _disp_chr

      END

disp_ret
          ld de,1-&2000
          add hl,de
          res 3,h
          ex de,hl
disp_ret_
          ld sp,(vo_savesp)
_disp_ret_
          ld (vo_scrpos),de
;enchaine
;_disp_update_cursor
; Needed for disp_get_cursor (when plugged to ged)
          ld a,(vo_scrpos0)
          neg:add e
          ld (vo_cursor_x),a
          ret



      IF enable

disp_inline_nl
          pop bc
          call disp_text_nl
          push bc
          ret

disp_inline_nl_at
          pop bc
          call disp_text_nl_at
          push bc
          ret

disp_inline
          ld de,(vo_scrpos)
disp_inline_at
          pop bc
          call disp_text_at
          push bc
          ret
      END

disp_text_nl
          call disp_text
          jr disp_nl

      IF enable
disp_text_nl_at

;!!! hum, weird behavior

          push de
          call disp_text_at
          pop hl
          jr disp_nl_at
      END

disp_nl
          push af:push bc:push de:push hl
          ld hl,(vo_scrpos0)
disp_nl_at
          ld a,(vo_reg1)
          add a
          jr z,dnl_end  ;sanity : avoid infinite loop
          ld e,a:ld d,0
          ld bc,(vo_scrpos)
dnl_lp
          add hl,de:res 3,h
;new adresse must be after current one
          or a:sbc hl,bc:ld a,h:add hl,bc
          and 7
          jr nz,dnl_lp

          ld (vo_scrpos0),hl
          ld (vo_scrpos),hl
dnl_end
          pop hl:pop de:pop bc:pop af
          ret

      IF enable
disp_text_shaded
          ld de,(vo_scrpos)
disp_text_shaded_at
;like disp_text_at, but with fonte grisee
          di
          ld (vo_savesp),sp

          ld iy,dshd_lp
          jr dshd_start
dshd_lp
          ld de,1-&2000
          add hl,de
          res 3,h
          ex de,hl
dshd_start
          ld a,(bc)
          inc bc
          or a
          jr z,disp_ret_

          ld h,fonte_gris/&0400
          jr disp_chr_internal_


disp_text_inv
          ld de,(vo_scrpos)
disp_text_inv_at
;like disp_text_at, but inversed

          di
          ld (vo_savesp),sp

          ld iy,dint_lp
          jr dint_start
dint_lp
          ld de,1-&2000
          add hl,de
          res 3,h
          ex de,hl
dint_start
          ld a,(bc)
          inc bc
          or a
          jp z,disp_ret_

          xor &80
          jr disp_chr_internal
      END

disp_text
          ld de,(vo_scrpos)
disp_text_at
;in : bc= zero terminated string
    ; de= dest screen
;out : bc= past string (after zero)
     ; de= new dest

          di
          ld (vo_savesp),sp
          ld iy,dnt_lp
          jr dnt_start
dnt_lp
          ld de,1-&2000
          add hl,de
          res 3,h
          ex de,hl
dnt_start
          ld a,(bc)
          inc bc
          or a
          jp z,disp_ret_
;enchaine
disp_chr_internal
;in : !!caller must DI!!
    ;  a = chr
    ; de = dest screen
    ; iy = ret adr

;out: hl = de+$2000
    ; de, sp corrupted

          ld h,fonte/&0400
disp_chr_internal_
          add a
          jr c,dc_inv

          cp &40
          jr z,disp_space

          ld l,a
          add hl,hl
          add hl,hl
          ld sp,hl

          ex de,hl
   ;0-1
          pop de
          ld (hl),e
          set 3,h
          ld (hl),d
   ;3-2
          pop de
          set 4,h
          ld (hl),e
          res 3,h
          ld (hl),d
   ;6-7
          pop de
          set 5,h
          ld (hl),e
          set 3,h
          ld (hl),d
   ;5-4
          pop de
          res 4,h
          ld (hl),e
          res 3,h
          ld (hl),d
jp_iy     jp iy         ;ret


dc_inv
          cp &40
          jr z,disp_space_inv

          ld l,a
          add hl,hl
          add hl,hl
          ld sp,hl

          ex de,hl
   ;0-1
          pop de
          ld a,e
          cpl
          ld (hl),a
          ld a,d
          cpl
          set 3,h
          ld (hl),a
   ;3-2
          pop de
          ld a,e
          cpl
          set 4,h
          ld (hl),a
          ld a,d
          cpl
          res 3,h
          ld (hl),a
   ;6-7
          pop de
          ld a,e
          cpl
          set 5,h
          ld (hl),a
          ld a,d
          cpl
          set 3,h
          ld (hl),a
   ;5-4
          pop de
          ld a,e
          cpl
          res 4,h
          ld (hl),a
          ld a,d
          cpl
          res 3,h
          ld (hl),a
          jp iy

disp_space_inv
          scf
disp_space
          sbc a         ;0 or $ff
disp_space_
          ex de,hl

          ld (hl),a
          set 3,h
          ld (hl),a
          set 4,h
          ld (hl),a
          res 3,h
          ld (hl),a
          set 5,h
          ld (hl),a
          set 3,h
          ld (hl),a
          res 4,h
          ld (hl),a
          res 3,h
          ld (hl),a
          jp iy         ;ret



      IF enable
disp_hexa_bc
          push hl
          ld h,b
          ld l,c
          call disp_hexa_hl
          pop hl
          ret

disp_hexa_de
          ex de,hl
          call disp_hexa_hl
          ex de,hl
          ret

disp_hexa_hl_shaded
          push iy:ld iy,disp_text_shaded
          jr _disp_hexa_hl

disp_hexa_hl_inv
          push iy:ld iy,disp_text_inv
          jr _disp_hexa_hl

disp_hexa_hl
          push iy:ld iy,disp_text
_disp_hexa_hl
          push ix:ld ix,put_hexa_hl
          jr _disp_num_com

disp_hexa_a_shaded
          push iy:ld iy,disp_text_shaded
          jr _disp_hexa_a

disp_hexa_a_inv
          push iy:ld iy,disp_text_inv
          jr _disp_hexa_a

disp_hexa_a
          push iy:ld iy,disp_text
_disp_hexa_a
          push ix:ld ix,put_hexa_a
_disp_num_com
          push af:push bc:push de
          ld de,vo_tmp
          push de
          call jp_ix
          pop bc
          push hl
          call jp_iy
          pop hl:pop de:pop bc:pop af:pop ix:pop iy
          ret

jp_ix     jp ix

disp_deci_hl_shaded
          push iy:ld iy,disp_text_shaded
          jr _disp_deci_hl

disp_deci_hl_inv
          push iy:ld iy,disp_text_inv
          jr _disp_deci_hl

disp_deci_hl
          push iy:ld iy,disp_text
_disp_deci_hl
          push ix:ld ix,put_deci_hl
          jr _disp_num_com


disp_deci_a_shaded
          push iy:ld iy,disp_text_shaded
          jr _disp_deci_a

disp_deci_a_inv
          push iy:ld iy,disp_text_inv
          jr _disp_deci_a

disp_deci_a
          push iy:ld iy,disp_text
_disp_deci_a
          push ix:ld ix,put_deci_a
          jr _disp_num_com

disp_locate
          ld (vo_cursor),hl
          ld a,l:call disp_locate_y
          ld a,h
;enchaine
disp_locate_x
          push hl
          ld hl,(vo_scrpos0)
          add l:ld l,a:jr nc,$+3:inc h
_disp_locate_
          res 3,h
          ld (vo_scrpos),hl
          pop hl
          ret

disp_locate_inc
          push hl
          ld hl,(vo_scrpos)
          inc hl
          jr _disp_locate_

disp_locate_y
; !! reset x to 0 
; Nevermind, only used via disp_locate for now
;IN: A= pos, 0-based
          push hl
          ASSERT(r1 == 40)
          ld l,a:add a:add a:add l:ld l,a ; *5
          ld h,screen_main / &1000
          4 ** add hl,hl
          ld (vo_scrpos0),hl
          ld (vo_scrpos),hl
          pop hl
          ret

disp_get_cursor
          ld hl,(vo_cursor)
          ret


disp_place_cursor
; Inverse video at cursor pos
          push hl
          ld hl,(vo_scrpos)
          ld a,h:or screen_main/&0100:and &C7:ld h,a ; sanitize
          ASSERT(screen_main == &C000) ; for Carry detection
.lp       ld a,(hl):cpl:ld (hl),a
          ld a,h:add 8:ld h,a
          jr nc,.lp
          pop hl
          ret

;---------------
;Display highres
;---------------
dh_text
;------
          ld de,(dh_scrpos)
dh_text_at
;in : bc= zero terminated string
    ; de= dest screen
;out : bc= past string (after zero)
     ; de= new dest
          jr entry
.lp
          call dh_chr_at
.entry
          ld a,(bc):inc bc
          or a
          jr nz,.lp
          ld (dh_scrpos),hl
          ret

dh_chr
;-----
          ld de,(dh_scrpos)
          call dh_chr_at
          ld (dh_scrpos),de ; needed to simulate bb5a
          ret

dh_chr_at
;--------
;in: a=chr (bit 7 for video inverse)
   ;de=screen dest
;out:de=new pos
    ;hl trashed
          ld h,fonte_small/&0100
          sub 32
small_hei = 5
          ld l,a:add a:add a:add l:ld l,a ; *5
          push de
      small_hei-1 ** [
          ld a,(hl):inc l:ld (de),a
          ld a,d:add 8:call c,bc26_de_cor
          ld d,a
          ]
          ld a,(hl):ld (de),a
          pop de
          inc e
          ret nz
inc_d_wrap              ; called by phradisp
          ld a,d
          inc d
          xor d
          and &38
          ret z
          ld a,d:sub 8:ld d,a
      IF dev_checks'
          cp screen_main/&0100:call c,mess
      END
          ret

bc26_de
; !! Only for page C000
; Not the fastest, to reuse bc26_de_cor
          ld a,d:add 8:call c,bc26_de_cor
          ld d,a
          ret

bc26_de_cor
          ld a,e:add r1*2:ld e,a
          ld a,d:adc &C8
          bit 3,a:ret z
          add &38
          ret

dh_place_cursor
          push bc:push de
          ld de,(dh_scrpos)
          ld b,5
.lp       ld a,(de):cpl:ld (de),a
          ld a,d:add 8:call c,bc26_de_cor
          ld d,a
          djnz .lp
          pop de:pop bc
          ret

dh_locate
;In: H = col  (0-based)
   ; L = row  (0-based)
          ld (dh_cursor),hl
          ld a,l:call dh_locate_y
          ld a,h
;enchaine
dh_locate_x
;In: A= X
          push hl
          ld hl,(dh_scrpos0)
          add l:ld l,a:jr nc,$+3:inc h
          ld (dh_scrpos),hl
          pop hl
          ret


dh_locate_y
;!!! Reset x to 0
;In: A= Y (scanline)
          push hl:push de:push bc
          ld hl,(dh_scrpos00)
          ld c,a
          and 7:3 ** add a:ld b,a
          add h:ld h,a
          ld a,c:and &F8
          ASSERT(r1 == 40)
;*10 (*8 already done)
          ld d,0:add a:rl d:ld e,a
          add hl,de     ; +2
          ex de,hl
          2 ** add hl,hl
          add hl,de     ; +8
;page wrap
          ld a,h
          xor b
          and &38:jr z,.ok
          ld a,h:sub 8:ld h,a
      IF dev_checks'
          cp screen_main/&0100:call c,mess
      END
.ok
          ld (dh_scrpos0),hl
          ld (dh_scrpos),hl
          pop bc:pop de:pop hl
          ret


;-------


is_ei
;Retain if we are under DI or EI,
;so we can reactivate EI if needed
          push hl
          ld hl,&C9FB
          ld a,i:jp pe,_isei
; Must double check to counteract z80 bug. 
          ld a,i:jp pe,_isei
          ld l,h        ; No-op
_isei
          ld (vo_ei),hl
          pop hl
          ret

vo_ei     ret:ret       ; might be replace by ei:ret above

      END


; -----------------------------

vo_cursor
vo_cursor_y BYTE 0
vo_cursor_x BYTE 0
vo_scrpos0 WORD screen_main
vo_scrpos WORD screen_main
vo_tmp FILL 6,0
vo_reg1 BYTE 40
vo_savesp WORD 0
dh_scrpos00 WORD screen_main ; Start of page (change when scrolling)
dh_scrpos0 WORD screen_main ; Start of line
dh_scrpos WORD screen_main
dh_cursor               ; for phradisp
dh_cursor_y BYTE 0
dh_cursor_x BYTE 0

; -----------------------------
; !!! Status routines (and var)
; -> Reached in BK C1 to be able to write in page &4000
; -----------------------------

      ORG $+&8000,$$

      MACRO CALL_FROM_C1 adr
      IF $ AND &8000:ELSE
   !! error caller
      END
      IF adr AND &8000
   !! error callee
      END
          call adr + &8000
      ENDM

      MACRO JP_FROM_C1 adr
      IF $ AND &8000:ELSE
   !! error caller
      END
      IF adr AND &8000
   !! error callee
      END
          jp adr + &8000
      ENDM

status_error
;In: A = id message
   ; HL = main caller address (failing point)
          ld bc,txt_to_be_implemented+&8000:or a:jr z,.ok
          ld bc,txt_memory_full+&8000:dec a:jr z,.ok
          ld bc,txt_mess+&8000
.ok
          LOCATION(0,y_pos_last_line)
          push bc
          call status_clear_from
          pop bc
          LOCATION(x_pos_error,y_pos_last_line)
          call status_str_at
          ld a,":":call status_char
          call status_hexa_hl
          ld bc,txt_press_a_key+&8000
          call status_str
;sanity if assert comming while playing
          di
          ld bc,&7F8E
          exx
          jp km_wait_key

_status_cursor
;In: d=x (0 based) e=y (0 based) <= 4
;Out: HL= Scr pos.
          push af
      IF dev_checks'
          ld a,d:cp r1'*2:jr c,$+4:ld d,0
          ld a,e:cp 7:jr c,$+4:ld e,6
      ELSE
          ld a,e
      END
;one text line is 2*r1' (&60)
          add a:add e   ; <= 21
          3 ** add a    ; <= 168
          ld l,a
          ld h,screen'/&0400
          2 ** add hl,hl
          ld a,l:add d
          ld l,a:jr nc,$+3:inc h
          pop af
          ret

status_get_pos
          ld de,(vo_status_pos)
      IF dev_checks'
          push af
          ld a,d
          cp &40:jr c,.ko
          cp &44:jr c,.ok
.ko       ld d,&40
.ok
          pop af
      END
          ret


status_char_at
;In: de=x,y (logicial 0-based) 
   ; A trashed
          call status_set_cursor
status_char
          call status_prelude
          call status_chr_at
_status_ret
          ld (vo_status_pos),de
_status_ret_
          pop hl:pop de:pop ix
          ret

status_prelude
; save ix, hl, de     
; Out: DE: screen pos
          ex (sp),ix
          push de:push hl
          call status_get_pos
          jp ix         ; ret. Ix can be used by routines, yeah!

status_str_at
          call status_set_cursor
status_str
;in: bc=str
          call status_prelude
.lp
          ld a,(bc):inc bc:or a:jr z,_status_ret
          call status_chr_at
          jr .lp

      IF enable
status_str_shaded_at
          call status_set_cursor
status_str_shaded
          call status_prelude
.lp
          ld a,(hl):or a:jr z,_status_ret
          call status_chr_shaded_at
          inc hl
          jr .lp
      END

status_pad_at
; Similar to str_pad_at but for status.
;In: hl= nt string
   ; de= pos cursor
   ;  b= len (clipping OR padding may occur)
          call status_set_cursor
status_pad
          call status_prelude

; NB: when coming from status_pad_at with b=0,
; we must update vo_statuspos so client can chain with no _at_ routines
          inc b:dec b:jr z,_status_ret

          ld iyl,b
stapae_lp
          ld a,(hl)
          or a:jr z,$+3:inc hl ; Stay at same place

          call status_chr_at
          dec iyl
          jr nz,stapae_lp

          jr _status_ret

status_paragraph_at
; Display several lines
;In: BC: point nt strings
   ; DE: cursor
.lp
          push de
          call status_str_at
          pop de
          inc e
          ld a,(bc):or a
          jr nz,.lp
          ret

status_clear_from
; Clear line until right end 
;In: d=x (0 based) e=y (0 based) <= 7
;Out: AF BC trashed
          call status_set_cursor

; C:= width to clear (-1 for ldir)
          ld a,r1'*2 -1
          sub e
          ld c,a
          ret z

          call status_prelude
          ld b,8
.ylp
          push bc
          push de
          ld l,e:ld h,d
          inc de
          ld b,0:ld (hl),b:ldir
          pop de
          pop bc
          ld a,d:add 8:ld d,a
          djnz .ylp
          jp _status_ret_


status_deci_a_at
          call status_set_cursor
status_deci_a
          push ix:ld ix,put_deci_a
          jr _status_num

status_deci_a_pad0_at
          call status_set_cursor
status_deci_a_pad0
          push ix:ld ix,put_deci_a_pad0
          jr _status_num


status_deci_hl_at
          call status_set_cursor
status_deci_hl
          push ix:ld ix,put_deci_hl
          jr _status_num


status_hexa_a_at
          call status_set_cursor
status_hexa_a
          push ix:ld ix,put_hexa_a
          jr _status_num


status_hexa_hl_at
          call status_set_cursor
status_hexa_hl
          push ix:ld ix,put_hexa_hl
_status_num
          push de:push hl
          ld de,vo_status_tmp
          push de
          ASSERT(jp_ix AND &C000 == &4000)
          call jp_ix + &8000
          xor a:ld (de),a
          pop bc
          call status_str
          pop hl:pop de
          pop ix
          ret

status_inv_cursor_at
; NB: doesn't change internal cursor position
          push bc:push hl
          call _status_cursor
          ld b,8
.sicalp
          ld a,(hl):cpl:ld (hl),a
          ld a,h:add 8:ld h,a
          djnz .sicalp
          pop hl:pop bc
          ret

status_set_cursor
;Locate and print
;In: d=x (0 based) e=y (0 based) <= 4
          push hl
          call _status_cursor
          ld (vo_status_pos),hl
          pop hl
          ret

status_chr_shaded_at
          ld h,fonte_gris+&8000 /&0400
          jr _status_chr

status_chr_at
;in: a=chr (bit 7 for video inverse)
   ;de=screen dest
;out:de=new pos
    ;hl trashed
          ld h,fonte+&8000 /&0400
_status_chr
          di
          ld (vo_status_savesp),sp
          ld iy,status_ret
          JP_FROM_C1(disp_chr_internal_)

status_ret
          ld de,1-&2000
          add hl,de
          res 3,h
          ld (vo_status_pos),hl
          ex de,hl
          ld sp,(vo_status_savesp)
          ret

vo_status_savesp WORD 0
vo_status_pos WORD 0    ; 0 for proper bin length
; Otherwise variables would overlap with what's loaded/imported next.
vo_status_tmp SKIP &80  ; buffer tmp

      IF $-&8000 != $$
  !! error sync
      END

      ORG $$            ; restore

      IF $ > pianoui
   !! overlap
      END
