; Disp: text display. From Orgams.
   ; Difference: status_*: same API than disp_* (e.g. BC for text)

; 2025     
; -- alpha 1 --
 ; Nov      
   ; 16 dh_* routines for phrases (h: halfsize / highres)    
; -- v0au --
   ; 15 Adapt /status_inv_cursor_at/ for ayane's status
   ; 10 s/dev_checks/dev_checks' to avoid ambiguity
; -- v0aq -- 
 ; Oct
     ;15 Add status_paragraph_at:
            ; - less code in client area
            ; - C1 connected to read final 0

todo  = 1
dev_checks' = 1

screen' = &4000         ; for status

      IF todo
; !!!! remove is_ei
; Harmonize naming (e.g. status_char_at takes de=cursor
                   ; but disp_char_at   takes de=offset)
      END

enable = 1

      IMPORT "memmap.i"
      IMPORT "const.i"
      IMPORT "macro.i"
pccheck = $
      IMPORT "conv.o"
      IF $ != pccheck
  !! must have been imported beforehand
      END

      IF fonte_gris AND &03FF
 !! error align   ; must be 0 mod &400
      END

      IF fonte AND &03FF
 !! error align   
      END

      ORG disp

      BYTE "DI"         ; marker for dev_checks

; -------------
      IF 0
; Not using disp-jp anymore

; Same order than disp-jp  (roughly follows orgams ROM).
          jp init_disp
          jp cls        ;!!To be called before disp_* (not _at)
          jp disp_locate_scr ;de:pos in screen (e.g.) &c000 
          jp disp_locate_x ;a:x  Change pos to "line start + x"
          jp disp_locate_inc
;5*3
          jp disp_chr   ;a:chr, de:dest
          jp disp_chr_at
          jp disp_chr_shaded
          jp disp_chr_shaded_at
;9*3
          jp disp_text  ;hl:nt string
          jp disp_text_at ;" de:dest
          jp disp_text_shaded
          jp disp_text_shaded_at
          jp disp_text_inv
          jp disp_text_inv_at ;" video inversion
          jp disp_text_nl
  ;        JP   disp_text_nl_at !! weird behavior, and no more room

          jp str_pad
          jp str_pad_ei

          jp disp_inline ;call x, "text", 0
          jp disp_inline_at ;"  de: dest
          jp disp_inline_nl
     ;        JP   disp_inline_nl_at ;!! weird behavior
          3 ** BRK
          jp disp_nl
     ;         JP   disp_nl_at !! weird behavior and no more room

          jp str_pad_shaded_ei

;18*3
          jp disp_deci_a
          jp disp_deci_a_inv
          jp disp_deci_a_shaded
          jp disp_deci_hl
          jp disp_deci_hl_inv
          jp disp_deci_hl_shaded
          jp disp_hexa_a
          jp disp_hexa_a_inv
          jp disp_hexa_a_shaded
          jp disp_hexa_hl
          jp disp_hexa_hl_inv
          jp disp_hexa_hl_shaded

          3 ** BRK      ;  jp put_deci_a
          3 ** BRK      ;jp put_deci_a_pad0
          3 ** BRK      ;jp put_deci_hl
          3 ** BRK      ;jp put_hexa_a
          3 ** BRK      ;jp put_hexa_hl

          3 ** BRK      ;jp dump_ascii
          3 ** BRK      ; jp dump_ascii_shaded
          3 ** BRK      ; jp dump_hexa
          3 ** BRK      ; jp dump_hexa_shaded

          jp str_pad_at
          jp str_pad_at_ei

m         jp status_set_cursor

          jp status_char_at
          jp status_str_at
          jp status_pad_at
          jp status_deci_a_at
          jp status_deci_a_pad0_at
          jp status_deci_hl_at
          jp status_hexa_a_at
          jp status_hexa_hl_at

          jp status_char
          jp status_str
      IF 0
;Shall be called directly
          jp status_pad
          jp status_deci_a
          jp status_deci_a_pad0
          jp status_deci_hl
          jp status_hexa_a
          jp status_hexa_hl
          jp status_inv_cursor_at
          jp status_clear_from
          jp status_str_shaded_at
          jp status_str_shaded
      END
      END

      IF enable
str_pad
          ld de,(vo_scrpos)
str_pad_at
;In: hl= nt string
   ; de= pos screen
   ;  b= len (padding or clipping may occur)

; NB: when coming from str_pad_at_ei with b=0,
    ; we must update vo_scrpos so client can chain with no _at_ routines
          inc b:dec b:jp z,_disp_ret_

; Copy/paste disp_chr_ for faster loop.
          di
          ld (vo_savesp),sp
          ld ixl,b
          ld c,l:ld b,h
          ld iy,spa_ret
spa_lp
          ld a,(bc)
          or a:jp z,disp_space_ ; 0: stay at same place
          inc bc
          jp disp_chr_internal
spa_ret
          ld de,1-&2000
          add hl,de
          res 3,h
          ex de,hl
          dec ixl
          jr nz,spa_lp
          jp disp_ret_

;------------
str_pad_shaded_ei
          ld de,(vo_scrpos)
str_pad_shaded_at_ei

          ld iyh,fonte_gris/&0400
          jr str_pad_com

;------------
str_pad_ei
          ld de,(vo_scrpos)
str_pad_at_ei
; As str_pad_at but reactivate int for rupture.
; Todo: remove str_pad_at

          ld iyh,fonte/&0400

str_pad_com
; NB: when coming from str_pad_at_ei with b=0,
    ; we must update vo_scrpos so client can chain with no _at_ routines
          inc b:dec b:jp z,_disp_ret_

          ld iyl,b
spae_lp
          ld a,(hl)
          or a:jr z,disp_space2_ ; Stay at same place

          inc hl
          cp &20
          jr z,disp_space2

          ld b,iyh
          add a         ;NB: Inv not handled here
      2 ** [add a:rl b]
          ld c,a

   ;0-1 
          ld a,(bc)
          ld (de),a
          inc c:ld a,(bc)
          set 3,d:ld (de),a
   ;3-2
          inc c:ld a,(bc)
          set 4,d:ld (de),a
          inc c:ld a,(bc)
          res 3,d:ld (de),a
   ;6-7
          inc c:ld a,(bc)
          set 5,d:ld (de),a
          inc c:ld a,(bc)
          set 3,d:ld (de),a
   ;5-4
          inc c:ld a,(bc)
          res 4,d:ld (de),a
          inc c:ld a,(bc)
          res 3,d:ld (de),a

          jr spae_next


disp_space2
          xor a
disp_space2_

          ld (de),a
          set 3,d:ld (de),a
          set 4,d:ld (de),a
          res 3,d:ld (de),a
          set 5,d:ld (de),a
          set 3,d:ld (de),a
          res 4,d:ld (de),a
          res 3,d:ld (de),a

spae_next
          inc de
          ld a,d:and &C7:ld d,a

          dec iyl
          jr nz,spae_lp

          ld (vo_scrpos),de
          ret
      END

mess  = &BE00

init_disp
;in A = Reg1
          ld (vo_reg1),a
          ld de,&C000
disp_locate_scr
          ld (vo_scrpos0),de
          ld (vo_scrpos),de
          ret


cls
;corrupt hl, de, af
;!! disable interruptions

          di
          xor a
          ld l,a
          ld h,a
          ld e,a
          ld d,a
          add hl,sp
          ex de,hl
          ld sp,hl
;
cls_lp
      FILL 32,&E5       ;push hl
          dec a
          jr nz,cls_lp

          ld (vo_scrpos0),sp ;$C000
          ld (vo_scrpos),sp ;$C000

          ex de,hl
          ld sp,hl
          ret

      IF enable
disp_chr_at_
          ld h,fonte/&0400 + &80
          jr _disp_chr
disp_chr
          ld de,(vo_scrpos)
disp_chr_at
;in: a=chr (bit 7 for video inverse)
   ;de=screen dest
;out:de=new pos
    ;hl trashed

          ld h,fonte/&0400
_disp_chr
          di
          ld (vo_savesp),sp
          ld iy,disp_ret
          jp disp_chr_internal_

disp_chr_shaded
          ld de,(vo_scrpos)
disp_chr_shaded_at
          ld h,fonte_gris/&0400
          jr _disp_chr

      END

disp_ret
          ld de,1-&2000
          add hl,de
          res 3,h
          ex de,hl
disp_ret_
          ld sp,(vo_savesp)
_disp_ret_
          ld (vo_scrpos),de
          ret



      IF enable

disp_inline_nl
          pop bc
          call disp_text_nl
          push bc
          ret

disp_inline_nl_at
          pop bc
          call disp_text_nl_at
          push bc
          ret

disp_inline
          ld de,(vo_scrpos)
disp_inline_at
          pop bc
          call disp_text_at
          push bc
          ret
      END

disp_text_nl
          call disp_text
          jr disp_nl

      IF enable
disp_text_nl_at

;!!! hum, weird behavior

          push de
          call disp_text_at
          pop hl
          jr disp_nl_at
      END

disp_nl
          push af:push bc:push de:push hl
          ld hl,(vo_scrpos0)
disp_nl_at
          ld a,(vo_reg1)
          add a
          jr z,dnl_end  ;sanity : avoid infinite loop
          ld e,a:ld d,0
          ld bc,(vo_scrpos)
dnl_lp
          add hl,de:res 3,h
;new adresse must be after current one
          or a:sbc hl,bc:ld a,h:add hl,bc
          and 7
          jr nz,dnl_lp

          ld (vo_scrpos0),hl
          ld (vo_scrpos),hl
dnl_end
          pop hl:pop de:pop bc:pop af
          ret

      IF enable
disp_text_shaded
          ld de,(vo_scrpos)
disp_text_shaded_at
;like disp_text_at, but with fonte grisee
          di
          ld (vo_savesp),sp

          ld iy,dshd_lp
          jr dshd_start
dshd_lp
          ld de,1-&2000
          add hl,de
          res 3,h
          ex de,hl
dshd_start
          ld a,(bc)
          inc bc
          or a
          jr z,disp_ret_

          ld h,fonte_gris/&0400
          jr disp_chr_internal_


disp_text_inv
          ld de,(vo_scrpos)
disp_text_inv_at
;like disp_text_at, but inversed

          di
          ld (vo_savesp),sp

          ld iy,dint_lp
          jr dint_start
dint_lp
          ld de,1-&2000
          add hl,de
          res 3,h
          ex de,hl
dint_start
          ld a,(bc)
          inc bc
          or a
          jp z,disp_ret_

          xor &80
          jr disp_chr_internal
      END

disp_text
          ld de,(vo_scrpos)
disp_text_at
;in : bc= zero terminated string
    ; de= dest screen
;out : bc= past string (after zero)
     ; de= new dest

          di
          ld (vo_savesp),sp
          ld iy,dnt_lp
          jr dnt_start
dnt_lp
          ld de,1-&2000
          add hl,de
          res 3,h
          ex de,hl
dnt_start
          ld a,(bc)
          inc bc
          or a
          jp z,disp_ret_
;enchaine
disp_chr_internal
;in : !!caller must DI!!
    ;  a = chr
    ; de = dest screen
    ; iy = ret adr

;out: hl = de+$2000
    ; de, sp corrupted

          ld h,fonte/&0400
disp_chr_internal_
          add a
          jr c,dc_inv

          cp &40
          jr z,disp_space

          ld l,a
          add hl,hl
          add hl,hl
          ld sp,hl

          ex de,hl
   ;0-1
          pop de
          ld (hl),e
          set 3,h
          ld (hl),d
   ;3-2
          pop de
          set 4,h
          ld (hl),e
          res 3,h
          ld (hl),d
   ;6-7
          pop de
          set 5,h
          ld (hl),e
          set 3,h
          ld (hl),d
   ;5-4
          pop de
          res 4,h
          ld (hl),e
          res 3,h
          ld (hl),d
jp_iy     jp iy         ;ret


dc_inv
          cp &40
          jr z,disp_space_inv

          ld l,a
          add hl,hl
          add hl,hl
          ld sp,hl

          ex de,hl
   ;0-1
          pop de
          ld a,e
          cpl
          ld (hl),a
          ld a,d
          cpl
          set 3,h
          ld (hl),a
   ;3-2
          pop de
          ld a,e
          cpl
          set 4,h
          ld (hl),a
          ld a,d
          cpl
          res 3,h
          ld (hl),a
   ;6-7
          pop de
          ld a,e
          cpl
          set 5,h
          ld (hl),a
          ld a,d
          cpl
          set 3,h
          ld (hl),a
   ;5-4
          pop de
          ld a,e
          cpl
          res 4,h
          ld (hl),a
          ld a,d
          cpl
          res 3,h
          ld (hl),a
          jp iy

disp_space_inv
          scf
disp_space
          sbc a         ;0 or $ff
disp_space_
          ex de,hl

          ld (hl),a
          set 3,h
          ld (hl),a
          set 4,h
          ld (hl),a
          res 3,h
          ld (hl),a
          set 5,h
          ld (hl),a
          set 3,h
          ld (hl),a
          res 4,h
          ld (hl),a
          res 3,h
          ld (hl),a
          jp iy         ;ret



      IF enable
disp_hexa_bc
          push hl
          ld h,b
          ld l,c
          call disp_hexa_hl
          pop hl
          ret

disp_hexa_de
          ex de,hl
          call disp_hexa_hl
          ex de,hl
          ret

disp_hexa_hl_shaded
          push iy:ld iy,disp_text_shaded
          jr _disp_hexa_hl

disp_hexa_hl_inv
          push iy:ld iy,disp_text_inv
          jr _disp_hexa_hl

disp_hexa_hl
          push iy:ld iy,disp_text
_disp_hexa_hl
          push ix:ld ix,put_hexa_hl
          jr _disp_num_com

disp_hexa_a_shaded
          push iy:ld iy,disp_text_shaded
          jr _disp_hexa_a

disp_hexa_a_inv
          push iy:ld iy,disp_text_inv
          jr _disp_hexa_a

disp_hexa_a
          push iy:ld iy,disp_text
_disp_hexa_a
          push ix:ld ix,put_hexa_a
_disp_num_com
          push af:push bc:push de
          ld de,vo_tmp
          push de
          call jp_ix
          pop bc
          push hl
          call jp_iy
          pop hl:pop de:pop bc:pop af:pop ix:pop iy
          ret

jp_ix     jp ix

disp_deci_hl_shaded
          push iy:ld iy,disp_text_shaded
          jr _disp_deci_hl

disp_deci_hl_inv
          push iy:ld iy,disp_text_inv
          jr _disp_deci_hl

disp_deci_hl
          push iy:ld iy,disp_text
_disp_deci_hl
          push ix:ld ix,put_deci_hl
          jr _disp_num_com


disp_deci_a_shaded
          push iy:ld iy,disp_text_shaded
          jr _disp_deci_a

disp_deci_a_inv
          push iy:ld iy,disp_text_inv
          jr _disp_deci_a

disp_deci_a
          push iy:ld iy,disp_text
_disp_deci_a
          push ix:ld ix,put_deci_a
          jr _disp_num_com

      IF enable
disp_locate_x
          push hl
          ld hl,(vo_scrpos0)
          add l:ld l,a:jr nc,$+3:inc h
_disp_locate_
          res 3,h
          ld (vo_scrpos),hl
          pop hl
          ret

disp_locate_inc
          push hl
          ld hl,(vo_scrpos)
          inc hl
          jr _disp_locate_
      END

;---------------
;Display highres
;---------------
dh_text
;------
          ld de,(dh_scrpos)
dh_text_at
;in : bc= zero terminated string
    ; de= dest screen
;out : bc= past string (after zero)
     ; de= new dest
          jr entry
.lp
          call dh_chr_at
.entry
          ld a,(bc):inc bc
          or a
          jr nz,.lp
          ld (dh_scrpos),hl
          ret

dh_chr
;-----
          ld de,(dh_scrpos)
          call dh_chr_at
          ld (dh_scrpos),de ; needed to simulate bb5a
          ret

dh_chr_at
;--------
;in: a=chr (bit 7 for video inverse)
   ;de=screen dest
;out:de=new pos
    ;hl trashed
          ld h,fonte_small/&0100
          sub 32
small_hei = 5
          ld l,a:add a:add a:add l:ld l,a ; *5
          push de
      small_hei-1 ** [
          ld a,(hl):inc l:ld (de),a
          ld a,d:add 8:call c,bc26_de_cor
          ld d,a
          ]
          ld a,(hl):ld (de),a
          pop de
          inc e
          ret nz
inc_d_wrap              ; called by phradisp
          ld a,d
          inc d
          xor d
          and &38
          ret z
          ld a,d:sub 8:ld d,a
      IF dev_checks'
          cp &C0:call c,mess
      END
          ret

bc26_de
; !! Only for page C000
; Not the fastest, to reuse bc26_de_cor
          ld a,d:add 8:call c,bc26_de_cor
          ld d,a
          ret

bc26_de_cor
          ld a,e:add r1*2:ld e,a
          ld a,d:adc &C8
          bit 3,a:ret z
          add &38
          ret

dh_place_cursor
          push bc:push de
          ld de,(dh_scrpos)
          ld b,5
.lp       ld a,(de):cpl:ld (de),a
          ld a,d:add 8:call c,bc26_de_cor
          ld d,a
          djnz .lp
          pop de:pop bc
          ret

dh_locate
;In: H = col  (0-based)
   ; L = row  (0-based)
          ld (dh_cursor),hl
          ld a,l:call dh_locate_y
          ld a,h
;enchaine
dh_locate_x
;In: A= X
          push hl
          ld hl,(dh_scrpos0)
          add l:ld l,a:jr nc,$+3:inc h
          ld (dh_scrpos),hl
          pop hl
          ret


dh_locate_y
;!!! Reset x to 0
;In: A= Y (scanline)
          push hl:push de:push bc
          ld hl,(dh_scrpos00)
          ld c,a
          and 7:3 ** add a:ld b,a
          add h:ld h,a
          ld a,c:and &F8
          ASSERT(r1 == 40)
;*10 (*8 already done)
          ld d,0:add a:rl d:ld e,a
          add hl,de     ; +2
          ex de,hl
          2 ** add hl,hl
          add hl,de     ; +8
;page wrap
          ld a,h
          xor b
          and &38:jr z,.ok
          ld a,h:sub 8:ld h,a
      IF dev_checks'
          cp &C0:call c,mess
      END
.ok
          ld (dh_scrpos0),hl
          ld (dh_scrpos),hl
          pop bc:pop de:pop hl
          ret


;-------


is_ei
;Retain if we are under DI or EI,
;so we can reactivate EI if needed
          push hl
          ld hl,&C9FB
          ld a,i:jp pe,_isei
; Must double check to counteract z80 bug. 
          ld a,i:jp pe,_isei
          ld l,h        ; No-op
_isei
          ld (vo_ei),hl
          pop hl
          ret

vo_ei     ret:ret       ; might be replace by ei:ret above

      END


; -----------------------------

vo_scrpos0 WORD &C000
vo_scrpos WORD &C000
vo_tmp SKIP 6
vo_reg1 BYTE 40
vo_savesp WORD 
dh_scrpos00 WORD &C000  ; Start of page (change when scrolling)
dh_scrpos0 WORD &C000   ; Start of line
dh_scrpos WORD &C000
dh_cursor               ; for phradisp
dh_cursor_y BYTE 
dh_cursor_x BYTE 

; -----------------------------
; !!! Status routines (and var)
; -> Reached in BK C1 to be able to write in page &4000
; -----------------------------

      ORG $+&8000,$$

      MACRO CALL_FROM_C1 adr
      IF $ AND &8000:ELSE
   !! error caller
      END
      IF adr AND &8000
   !! error callee
      END
          call adr + &8000
      ENDM

      MACRO JP_FROM_C1 adr
      IF $ AND &8000:ELSE
   !! error caller
      END
      IF adr AND &8000
   !! error callee
      END
          jp adr + &8000
      ENDM

_status_cursor
;In: d=x (0 based) e=y (0 based) <= 4
;Out: HL= Scr pos.
          push af
      IF dev_checks'
          ld a,d:cp r1'*2:call nc,mess
          ld a,e:cp 7:call nc,mess
      ELSE
          ld a,e
      END
;one text line is 2*r1' (&60)
          add a:add e   ; <= 21
          3 ** add a    ; <= 168
          ld l,a
          ld h,screen'/&0400
          2 ** add hl,hl
          ld a,l:add d
          ld l,a:jr nc,$+3:inc h
          pop af
          ret

status_get_pos
          ld de,(vo_status_pos)
      IF dev_checks'
          push af
          ld a,d
          cp &40:call c,mess
          cp &44:call nc,mess
          pop af
      END
          ret


status_char_at
;In: de=x,y (logicial 0-based) 
   ; A trashed
          call status_set_cursor
status_char
          call status_prelude
          call status_chr_at
_status_ret
          ld (vo_status_pos),de
_status_ret_
          pop hl:pop de:pop ix
          ret

status_prelude
; save ix, hl, de     
; Out: DE: screen pos
          ex (sp),ix
          push de:push hl
          call status_get_pos
          jp ix         ; ret. Ix can be used by routines, yeah!

status_str_at
          call status_set_cursor
status_str
;in: bc=str
          call status_prelude
.lp
          ld a,(bc):inc bc:or a:jr z,_status_ret
          call status_chr_at
          jr .lp

      IF enable
status_str_shaded_at
          call status_set_cursor
status_str_shaded
          call status_prelude
.lp
          ld a,(hl):or a:jr z,_status_ret
          call status_chr_shaded_at
          inc hl
          jr .lp
      END

status_pad_at
; Similar to str_pad_at but for status.
;In: hl= nt string
   ; de= pos cursor
   ;  b= len (clipping OR padding may occur)
          call status_set_cursor
status_pad
          call status_prelude

; NB: when coming from status_pad_at with b=0,
; we must update vo_statuspos so client can chain with no _at_ routines
          inc b:dec b:jr z,_status_ret

          ld iyl,b
stapae_lp
          ld a,(hl)
          or a:jr z,$+3:inc hl ; Stay at same place

          call status_chr_at
          dec iyl
          jr nz,stapae_lp

          jr _status_ret

status_paragraph_at
; Display several lines
;In: BC: point nt strings
   ; DE: cursor
.lp
          push de
          call status_str_at
          pop de
          inc e
          ld a,(bc):or a
          jr nz,.lp
          ret

status_clear_from
; Clear line until right end 
;In: d=x (0 based) e=y (0 based) <= 7
;Out: AF BC trashed
          call status_set_cursor

; C:= width to clear (-1 for ldir)
          ld a,r1'*2 -1
          sub e
          ld c,a
          ret z

          call status_prelude
          ld b,8
.ylp
          push bc
          push de
          ld l,e:ld h,d
          inc de
          ld b,0:ld (hl),b:ldir
          pop de
          pop bc
          ld a,d:add 8:ld d,a
          djnz .ylp
          jp _status_ret_


status_deci_a_at
          call status_set_cursor
status_deci_a
          push ix:ld ix,put_deci_a
          jr _status_num

status_deci_a_pad0_at
          call status_set_cursor
status_deci_a_pad0
          push ix:ld ix,put_deci_a_pad0
          jr _status_num


status_deci_hl_at
          call status_set_cursor
status_deci_hl
          push ix:ld ix,put_deci_hl
          jr _status_num


status_hexa_a_at
          call status_set_cursor
status_hexa_a
          push ix:ld ix,put_hexa_a
          jr _status_num


status_hexa_hl_at
          call status_set_cursor
status_hexa_hl
          push ix:ld ix,put_hexa_hl
_status_num
          push de:push hl
          ld de,vo_status_tmp
          push de
          ASSERT(jp_ix AND &C000 == &4000)
          call jp_ix + &8000
          xor a:ld (de),a
          pop bc
          call status_str
          pop hl:pop de
          pop ix
          ret

status_inv_cursor_at
; NB: doesn't change internal cursor position
          push bc:push hl
          call _status_cursor
          ld a,h:and &F0:cp &40:call nz,&BE00
          ld b,8
.sicalp
          ld a,(hl):cpl:ld (hl),a
          ld a,h:add 8:ld h,a
          djnz .sicalp
          pop hl:pop bc
          ret

status_set_cursor
;Locate and print
;In: d=x (0 based) e=y (0 based) <= 4
          push hl
          call _status_cursor
          ld (vo_status_pos),hl
          pop hl
          ret

status_chr_shaded_at
          ld h,fonte_gris+&8000 /&0400
          jr _status_chr

status_chr_at
;in: a=chr (bit 7 for video inverse)
   ;de=screen dest
;out:de=new pos
    ;hl trashed
          ld h,fonte+&8000 /&0400
_status_chr
          di
          ld (vo_status_savesp),sp
          ld iy,status_ret
          JP_FROM_C1(disp_chr_internal_)

status_ret
          ld de,1-&2000
          add hl,de
          res 3,h
          ld (vo_status_pos),hl
          ex de,hl
          ld sp,(vo_status_savesp)
          ret

      IF 0
;Check IX dest is in C000
;Not needed anymore
jp_ix_c1
      IF dev_checks'
          push af
          ld a,ixh:and &C0:cp &C0:call nz,mess
          pop af
      END
          jp ix
      END

vo_status_savesp WORD 
vo_status_pos WORD 0    ; 0 for proper bin length
; Otherwise variables would overlap with what's loaded/imported next.
vo_status_tmp SKIP &80  ; buffer tmp

      IF $-&8000 != $$
  !! error sync
      END

      ORG $$            ; restore

      IF $ > pianoui
   !! overlap
      END
