dev_checks = 0
dev_checks_anchor = dev_checks AND 0
tmp_dbg = 0
tmp_rast = 0
; <<<< Handling cpc keyboard as piano >>>>
; -> Using hardware keycode: locale agnostic (azerty/qwerty)

 ; 2025                
    ; -- v0as --
  ;Oct
   ;11: more checks
      ; _play_lp: remove waits when tmp_rast = 0 (less code)

      IMPORT "const.i"
      IMPORT "memmap.i"
      IMPORT "macro.i"

      IMPORT "chung.o"  ; For va_current_instr
      IMPORT "ply.o"    ; play
      IMPORT "instr.o"  ; for instr_setup
      IMPORT "timer.o"
      IMPORT "ppi.o"

fail  = &BE00

      MACRO CHECK_DI
      IF dev_checks
          call _check_di
      END
      ENDM

;---------------------------------------
      MACRO SUB_TM_CALL n
; Update and call HL' when CPT < 0 
; !! A (A' here) isn't preserved
          SUB_TM(n+9)
; Cannot use call m,jp_hl', as it must take the same time in both case
          call jp_m_hl'
      ENDM

      MACRO DBG_RAST n
      IF tmp_rast
          SUB_TM(17)
          ld bc,&7F00+n:out (c),0:out (c),c:ld c,&10:out (c),c
      END
      ENDM
;---------------------------------------
piano_code
play_song
;--------
; Done in this source since shared code
; In: client called Amorce_song
; Out: N/A (We loop until ESC pressed)
          ASSERT($ == piano_code) ; called from ayane.o

          call _prelude
          call play_prelude
          call play     ; prepare regs
          call play_prelude'
          jr .play_song_entry

.play_song_lp
;------------
; Here A=TM  (value doesn't matter for first iteration)
          call vsync_timed
; Must be done at stable position
.play_song_entry
          call set_timer_and_psg

          ex af,af
          ld a,&48:call testkey
          inc c         ; ESC, 1, tab
          jp nz,_stop_play

          SUB_TM_CALL(5+17) ; including call vsync_timed

          call play     ; regs for next frame

          SUB_TM_CALL(5+3)
          jr .play_song_lp


play_piano
;---------
; Called when no note currently playing
; Check if there is a piano key pressed and start playing le cas echeant
; Out: N/A (We loop as long key presed)

          call _prelude
          call scan_piano_keys
          jp nc,_postlude
start_note
;A= note (0 = c0)
          ld (current_note),a
          push af
;Setup instr code
          ld hl,(va_current_instr) ; for l
          call instr_setup
;         call debug
          call play_prelude
          pop af
          call instr_play ; Amorce timer + psg_regs
      IF tmp_dbg
          xor a:ld (.dbgcpt+1),a
          call debug'
      END
          call play_prelude'
          jr _play_entry

_play_lp
;------
; Playing loop      
; Here A=TM  (value doesn't matter for first iteration)
          call vsync_timed
; Must be done at stable position
_play_entry
      IF dev_checks_anchor
          ex af,af
_refa     ld a,0
          ld hl,current_anchor:cp (hl):jr z,.ok
; anchor event could have been trigered
; (e.g. fx evt happening just at vsync time: since it's long, we reach
  ;anchor rdv)
          inc a:cp (hl):call nz,fail:dec a
          SUB_TM''(7-1)
.ok
          add 39*2
          ld (_refa+1),a
          ex af,af
          SUB_TM(18)
      END
          call set_timer_and_psg

      IF tmp_dbg
          ex af,af
.dbgcpt   ld a,0:inc a:ld (.dbgcpt+1),a ; tm not corrected
          dec a
          call z,debug'
          ex af,af
      END

          DBG_RAST(&58)
; ensure timer has been fired before reseting rasters
      IF 0
;No need, loop is handled
 ; NOT reseting allows visual debug!
          ld hl,rasters:ld (raster_pnt),hl ; Reset
      ELSE
          push hl:pop hl:nop
      END
; Ensure more than 16 lines are consumed before looping
; For now we don't consider time taken by scan_key and set_timer:
; nevermind.      
;          ld b,16:call waitlines
; For visual debug!
      IF tmp_rast
          ld b,80:call waitlines_tm
          DBG_RAST(&44)
          SUB_TM_CALL(25)
      ELSE
          SUB_TM_CALL(18)
      END

          ex af,af
          call scan_piano_keys
          jr nc,_stop_play
          ld hl,current_note
          cp (hl)
          jr nz,start_note

      IF tmp_rast
          push af
; For visual debug!
          ex af,af
          ld b,10:call waitlines_tm
          DBG_RAST(&59)
          ld b,30:call waitlines_tm
          SUB_TM_CALL(15+23)
          ex af,af
          pop af
          DBG_RAST(&46)
      ELSE
          ex af,af
          SUB_TM(15+2)  ; !!! sub_tm_call would thrash A
          ex af,af
      END

          call instr_play ; for next frame
      IF 0
          ex af,af
.toot     ld a,14
          dec a
          ld (.toot+1),a
          call z,&BE00
          ex af,af
          SUB_TM(12)
      END

      IF tmp_rast
          ld b,30:call waitlines_tm
          DBG_RAST(&4E)
          SUB_TM_CALL(5 + 7 + 3)
      ELSE
          SUB_TM_CALL(5 + 3)
      END
          jr _play_lp

_stop_play
; Stop playing
          ld hl,mute_psg
          ld de,psg_regs+7
          ld bc,4
          ldir
          call psg
_postlude
;"restore" firmware. DON'T set EI
; Preserve AF (for is_piano_key_pressed)
          ex af,af
      IF dev_checks
saveint = $+1
          ld a,0:ld (&38),a
      END
          pop bc
          pop af
      IF dev_checks
          call _check_regs'
      END
          exx
          ex af,af
          ret

;-----------------------------
play_prelude
;Needed when changing note, so no spurious event
;E.g. event scan_piano_keys will call hl'
          ld a,MAX_TM   ; so instr_play doesn't triger event. 
          ex af,af
          ld hl,anchor + hdr_code ; must re-init when looping
          exx
          jp init_timer

play_prelude'
          ld bc,&7F10:out (c),c ; for debug rasters        
          ld bc,&F6C0:out (c),c ; All fx routines assume that

      IF tmp_dbg
          call debug'
      END
          SYNC_ANCHOR()
      IF dev_checks_anchor
          ld (_refa+1),a
      END
          call vsync_start
;initial tm should not matter. But we reset it for reproductibility
          xor a
          ret

;-----------------------------
is_piano_key_pressed
; Like /scan_piano_keys/ with proper setup
          call .hackstack
;we know int wheren't interupted long enough
          ei
          ret

.hackstack
          call _prelude
          call scan_piano_keys
          jr _postlude

scan_piano_keys
; IN: A' = TM
    ; DI
;Out: if note pressed, Carry, A = note number (0 = C)
    ; otherwise, NC
    ; A' = updated TM
scan_keys_tm0 = 21      ; until .line_lp
;Skip first 2 lines: no piano key
          ld a,&42
          ld hl,keymap+2
          push hl
          call scan_all_lines_almost
;!!! NOW A = TM   
          pop hl
          ld e,0
          ld b,7        ; seven lines to scan
.line_lp
scan_keys_tm1 = 11      ; until jr pressed (taken)
          ld d,(hl):inc hl
          ld c,8        ; cannot use sl1 trick: must read left to right
.bit_lp
          rr d
          jr nc,.pressed
          inc e
;Favor precision (of timer) over speed (of routine)
; That also allows to **avoid** RET_ROUT, hence freeing A for return val
          SUB_TM_CALL(9)
          dec c         ; !!! After SUB_TM which sets Z/NZ
          jr nz,.bit_lp
; Inner loop takes 95 nops, so we must check/trigger timer now.
          SUB_TM(10-1)  ; -1: last jr
          djnz .line_lp

          SUB_TM(scan_keys_tm0 + 5 - 1) ; -1: last djnz
          ex af,af
          or a          ; NC: no piano key pressed
          ret

.pressed
          SUB_TM(scan_keys_tm0 + scan_keys_tm1 + 20)
          ex af,af
          ld d,0:ld hl,map:add hl,de
          ld a,(hl)
nn    = &FF             ; No note
      IF nn < &80
  !! review that
      END
          or a
          ret m         ;  TM shorter. Nevermind since we stop playing
octave_shift = $+1      ; Set by uiloop from pianoui.octave
          add 4*12      ; give proper index in /periods/
          scf
          ret

_prelude
;Store "firmware" and setup HL'     
;In: !!! Must be called at top level
;OUT: AF', BC' in stack  (must jump to _postlude)

          pop hl        ; ret address
          di
          ex af,af
          exx
          push af
          push bc       ;;"store firmware"
      IF dev_checks
          call _check_regs'
      END
          exx
          push hl       ; for ret
; Must set hl' early, as most routine might trigger timer (JP HL')
          call play_prelude
      IF dev_checks
; Better break than crash in case of spurious EI
          ld a,(&38):ld (saveint),a
          ld a,&F7:ld (&38),a
      END
          ret


      IF dev_checks
_check_di
          push af
          ld a,i:call pe,fail
          pop af
          ret

_check_regs'
 ; apparently A' can be 0 or &8x
          push af
          or a:jr z,.oka
          and &8C:cp &8C:call nz,fail
.oka
          ld a,b:cp &7F:call nz,fail
          ld a,c:and &8C:cp &8C:call nz,fail
          pop af
          ret

      IF tmp_dbg
debug
          ld a,(dbg3+1):ld (&8300),a
          ld hl,header_events:ld de,&8200:ld bc,&0100:ldir
          ld hl,(current_anchor)
          ld b,&80
.ch       dec l:ld a,(hl):cp &F1:call nz,&BE00
          djnz .ch
          ret

debug'
;expect just first event set (or +&f00 is already triggered)
          ld hl,header_events+&20
.ch       ld a,(hl):cp &F1:call nz,&BE00
          inc l:jr nz,.ch
          ret
      END
      END

mute_psg BYTE &3F,0,0,0
;other regs: nevermind

map
; Note (in demi-tone. C=0 C#=1 ...) for each keycode


; In comments: keys on qwerty

; 0-7 : no notes (numeric pad)
; 8-15: no notes
; 16-23: clr [ ?? ] f4 shift \ ???
      BYTE nn,31,nn,18,nn,nn,17,nn
; 24-31: ^ - @ P ; : / . 
      BYTE 30,nn,29,28,nn,15,16,14
; 32-39:   0  9  O  I  L  K  M  ,
      BYTE 27,25,26,24,13,nn,11,12
; 40-47:   8  7  U  Y  H J  N Space
      BYTE nn,22,23,21,8,10,9,nn
; 48-55:   6  5  R  T  G F  B V
      BYTE 20,18,17,19,6,nn,7,5
; 56-63:   4  3  E  W  S D C X
      BYTE nn,15,16,14,1,3,4,2
; 64-71:   1  2  Esc Q Tab A Cap Z 
      BYTE nn,13,nn,12,nn,nn,nn,0

current_note BYTE 0

keymap FILL 10,&FF

