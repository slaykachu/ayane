dev_checks = 1
; <<<< Handling cpc keyboard as piano >>>>
; -> Using hardware keycode: locale agnostic (azerty/qwerty)

; 2024
; -------- Ayane v0y ----------
; Oct
  ; 17: Fix timing issues.
; -------- Ayane v0v ----------
; Sep      
  ; 30: Plug timer.
      ; scan_key: Fix NC when no piano touch pressed
; -------- Ayane v0t ----------
  ; 17: Extract helpers in instr.o
; -------- Ayane v0p ----------
  ;  8: Functional!

      BRK

      IMPORT "const.i"
      IMPORT "memmap.i"
      IMPORT "instr.o"  ; for instr_code
      IMPORT "ply.o"
 ;      IMPORT "chung.o"  ; To get current instrument # 
      IMPORT "ppi.o"
      IMPORT "chung.o"  ; For va_current_instr
      IMPORT "timer.o"

fail  = &BE00

      MACRO CHECK_DI
      IF dev_checks
          call _check_di
      END
      ENDM

;---------------------------------------
      MACRO SUB_TM n
; Update counter TM (+2 for 'sub n' itself)
      IF n AND 1
; Resolution: 2-nops. Must compensate
          ld a,a:sub [n+3]/2
      ELSE
          sub [n+2]/2
      END
      ENDM

      MACRO SUB_TM'' n
; Update counter TM (+2 for 'ex af')
          ex af,af
          SUB_TM(n+2)
          ex af,af
      ENDM

      MACRO SUB_TM_CALL n
; Update and call HL' when CPT < 0 
          SUB_TM(n+9)
; Cannot use call m,jp_hl', as it must take the same time in both case
          call jp_m_hl'
      ENDM


      MACRO SUB_TM_CALL'' n
          ex af,af
          SUB_TM_CALL(n+2)
          ex af,af
      ENDM

      MACRO RET_ROUT tm
          SUB_TM(tm+4)
          ret p
          exx:jp hl
      ENDM

      MACRO RET_ROUT' tm
          ex af,af
          RET_ROUT(tm+1)
      ENDM

;---------------------------------------
check_note
;---------
; Called when no note currently playing
; Check if there is a piano key pressed and start playing le cas echeant
          di
          ex af,af
          exx
          push af
          push bc       ;;"store firmware"
      IF dev_checks
          call _check_regs'
      END
; Must set hl' early, as most routine might trigger timer (JP HL')
          ld hl,anchor + hdr_code
          exx
      IF dev_checks
; Better break than crash in case of spurious EI
          ld a,(&38):ld (saveint),a
          ld a,&F7:ld (&38),a
      END
; --- tmp for dbg ---------
          ld a,&42
          ld hl,keymap+2
          call scan_all_lines_almost
; -------------------------

          call scan_keys
          jp nc,exit
start_note
;A= note
          ld (current_note),a
          push af
;Setup instr code
          ld hl,(va_current_instr) ; for l
          call instr_setup
          call init_timer
          ld bc,&F6C0:out (c),c ; All routines assume that
          ld bc,&7F10:out (c),c ; for debug rasters
          ld a,MAX_TM   ; so instr_play doesn't triger event. 
          ex af,af
          pop af
          call instr_play ; Amorce timer + psg_regs
; --- tmp dev ---------------------
;Just to set reg9 = &10
          ex af,af
          ld a,&3F:ld (r7),a
          call set_timer
; ---------------------------------
          ld a,MAX_TM   ; For stability across calls
          ex af,af
          call anti_vsync ; idem
.play_lp
;------
; Playing loop      
; Here A'=TM  (value doesn't matter for first iteration)
          call vsync_timed
          ld bc,&7F58:out (c),0:out (c),c:ld c,&10:out (c),c
; ensure timer has been fired before reseting rasters
          ex af,af
          ld b,1:call waitlines
          ex af,af
          ld hl,rasters:ld (raster_pnt),hl ; Reset
; Ensure more than 16 lines are consumed before looping
; For now we don't consider time taken by scan_key and set_timer:
; nevermind.      
          ex af,af
;          ld b,16:call waitlines
; For visual debug!
          ld b,80:call waitlines
          ex af,af

          ld bc,&7F44:out (c),0:out (c),c:ld c,&10:out (c),c

          SUB_TM_CALL''(65)

          call scan_keys
          jr nc,.no_note
          ld hl,current_note
          cp (hl)
          jr nz,start_note

          push af
; For visual debug!
          ex af,af
          ld b,50:call waitlines
          ex af,af

; start/continue playing instrument         
; Here a'=tm   
          call set_timer ; setup timer + PSG
; Here a=tm
; For visual debug!
          ld b,50:call waitlines
          ex af,af
;          ld a,(&1D09):cp &16:call nz,&BE00
;          ld a,(&1D0A):cp &07:call nz,&BE00
          pop af

          call instr_play ; for new iteration
          SUB_TM_CALL(52)
          ex af,af
          jr .play_lp

.no_note
; Stop playing
          ld hl,mute_psg
          ld de,psg_regs+7
          ld bc,4
          ldir
          call psg
exit
;"restore" firmware
          pop bc
          pop af
      IF dev_checks
          call _check_regs'
      END
          exx
          ex af,af
      IF dev_checks
saveint = $+1
          ld a,0:ld (&38),a
      END
          ei
          or a
          ret

scan_keys
; IN: A' = TM
;Out: if note pressed, Carry, A = note number
    ; otherwise, NC
    ; A' = updated TM
scan_keys_tm0 = 21      ; until .line_lp
;Skip first 2 lines: no piano key
          ld a,&42
          ld hl,keymap+2
          push hl
          call scan_all_lines_almost
;!!! NOW A = TM   
          pop hl
          ld e,0
          ld b,7        ; seven lines to scan
.line_lp
scan_keys_tm1 = 11      ; until jr pressed (taken)
          ld d,(hl):inc hl
          ld c,8        ; cannot use sl1 trick: must read left to right
.bit_lp
          rr d
          jr nc,.pressed
          inc e
;Favor precision (of timer) over speed (of routine)
; That also allows to **avoid** RET_ROUT, hence freeing A for return val
          SUB_TM_CALL(9)
          dec c         ; !!! After SUB_TM which sets Z/NZ
          jr nz,.bit_lp
; Inner loop takes 95 nops, so we must check/trigger timer now.
          SUB_TM(10-1)  ; -1: last jr
          djnz .line_lp

          SUB_TM(scan_keys_tm0 + 5 - 1) ; -1: last djnz
          ex af,af
          or a          ; NC: no piano key pressed
          ret

.pressed
          SUB_TM(scan_keys_tm0 + scan_keys_tm1 + 17)
          ex af,af
          ld d,0:ld hl,map:add hl,de
          ld a,(hl)
octave_shift = $+1
          add 4*12
nn    = -1              ; No note
      IF nn - -1
  !! review that
      END
          ccf           ; NC iif no-note (nn)
          ret

      IF dev_checks
_check_di
          push af
          ld a,i:call pe,fail
          pop af
          ret

_check_regs'
 ; apparently A' can be 0 or &8x
          push af
          or a:jr z,.oka
          cp &8E:call nz,fail
.oka
          ld a,b:cp &7F:call nz,fail
          ld a,c:cp &8E:call nz,fail
          pop af
          ret
      END

mute_psg BYTE &3F,0,0,0
;other regs: nevermind

map
; Note (in demi-tone. C=0 C#=1 ...) for each keycode


; In comments: keys on qwerty

; 0-7 : no notes (numeric pad)
; 8-15: no notes
; 16-23: clr [ ?? ] f4 shift \ ???
      BYTE nn,31,nn,18,nn,nn,17,nn
; 24-31: ^ - @ P ; : / . 
      BYTE 30,nn,29,28,nn,15,16,14
; 32-39:   0  9  O  I  L  K  M  ,
      BYTE 27,25,26,24,13,nn,11,12
; 40-47:   8  7  U  Y  H J  N Space
      BYTE nn,22,23,21,8,10,9,nn
; 48-55:   6  5  R  T  G F  B V
      BYTE 20,18,17,19,6,nn,7,5
; 56-63:   4  3  E  W  S D C X
      BYTE nn,15,16,14,1,3,4,2
; 64-71:   1  2  Esc Q Tab A Cap Z 
      BYTE nn,13,nn,12,nn,nn,nn,0

current_note BYTE 0

keymap FILL 10,&FF

