dev_checks = 1
todo  = 1
makeroom = 1
do_set_loop = 1
do_set_replay_period = 0
use_widget = 0          ; 1 for trackui
; -----------------------------------------------
; Song & Track handling for ayane (map/songlist)
; -----------------------------------------------

; 2026       
; -- alpha 3 --
 ; Feb
     ; 1: Add track_select_last_phrase
; -- alpha 2 --
 ; Jan       
     ;17: Remove used_tracks (was write only)     
     ;16: Add track_set_loop_at
     ;15: track_select_phrase_at and co: return Z if past end 
     ; 9: track_select_phrase_at: Respect invariant fetched_t1 > t
     ; 8: track_get_state_at: save hl, ix. Preserve transpose sign!
     ; 7: [cleanup] Remove ui related code
; 2025 
; -- alpha 1.07 --
 ; Dec     
    ; 30: Add track_get_state_at

; Setup ------
; ------------
    ; Init_track_module
    ; Reset_tracks
    ; New_module
    ; New_subsong  (move in song.o at some point)

; Track creation -----
; --------------------
    ; Song_select_new_track
    ; Song_add_map

; Track selection and queries --------
; ------------------------------------
    ; Song_select_track             
    ; track_get_event_at
    ; track_select_phrase_at
    ; track_select_last_phrase

; Track update -------
; --------------------
    ; Set_phrase_at_t
    ; Set_transpose_at_t
    ; Set_track_loop

; Clip ---------------
; --------------------
    ; Clip_set_duration

; Phrase -------------
; --------------------
    ; phrase_select_next_row ; Here since needs track_get_phrase_at

; Helpers ------------
; --------------------
    ; Get_tracks
    ; get_current_track_header
    ; get_track_header
    ; track_get_hook_at
    ; track_get_last_hook

; Track update -------
    ; Set_phrase_at_t
    ; Set_transpose_at_t

      IF todo
; move clip struct here?  (or in dedicated clip.o)
      END

      IMPORT "const.i"  ; for clip structure (fc_color etc)
      IMPORT "macro.i"  ; ASSERT
      IF dev_checks
      IMPORT "memmap.i" ; for check BK_TRACK
      END

      IMPORT "assert.o"
      IMPORT "phrase.o" ; song_get_phrase_id, phrase_start
        ; + all needed by Song_attach_empty_phrases/Song_add_map
      IMPORT "chunk.o"  ; for chunk_start
      IMPORT "memcpc.o" ; for check get_bk_connected
      IMPORT "song.o"   ; New_subsong still lives here for now
      IMPORT "tracknub.o" ; get_track_header
 ;  import "lizst.o" !!! don't use, see rationale in journal

reg32 = 0
reg_pad = 4
      IF reg32
reg_size = 4
      ELSE
reg_size = 3            ; !! still padded every 4 bytes
      END

scr_set_border = &BC38

;-------------------------
structs
;-------------------------

idsz  = 2               ; size of id node (just pnt: not cross bank)

savepc = $
saveobj = $$

; ---- Struct of event amorce (evt0=hook)  -----
      IF todo
 ; s/evt0/hook/ 
      END
      ORG 0
;evt0_link0 skip idsz  ; Next hook (already in node header)
evt0_dur WORD           ; Duration in 16 bits (see design)
evt0_dur_
evt0_link SKIP idsz     ; link to 1st event
; Note: we use indirection, otherwise amorce would be bigger than
      ; subsequent nodes. Since we work with static node size, that's
      ; something we want to avoid
      ; Everything is inlined at compilation anyway.
evt0_size
; No room left (node7)

; ---- Struct of event (after node header) -----
      ORG 0
;evt_link skip idsz   ; Next evt at this timestamp
evt_type BYTE 
evt_param WORD          ; E.g. link to phrase
evt_size

      IF 0
      MACRO EVENT_NODE link,type,param
      IF evt_type OR [evt_param-1]
 !! review this
      END
      FILL idsz,0
      BYTE type AND &FF ; Only LSB
      WORD param
      ENDM
      END

; ---- clip/phrase structure -----
; see const.i

      ORG savepc,saveobj

;===================================
      MACRO EMPTY_NAME
      FILL 3,0
      ENDM

      MACRO COLOR n
      BYTE n
      ENDM

      IF todo
 ; cleanup that. Still used for aum?
      END
      MACRO LINK bk,adr
;!!! Must keep little endian order: LSB, MSB, BK
;!!! So we can do pointer arithmetic 
      WORD adr:BYTE bk
      ENDM

      MACRO LINK_NULL
      FILL 3,0
      ENDM

      MACRO PNT adr
; Regular pointer, but must set bk byte:
  ; - We work with 24bits register
  ; - Needed for sanity checks  (todo: use c0 instead?)
          LINK(0,adr)
      ENDM

      MACRO DURATION val
; Encode value 16 bytes
      IF evt0_dur_ - 2
 !! review this
      END
      WORD val
      ENDM

      MACRO TIME val
; Encode value 24 bytes. Timestamp
      WORD val AND &FFFF:BYTE val/&0100/&0100
      ENDM


; -----------------------------
; MACRO for AUM virtual machine
; -----------------------------   
      MACRO LD2 dest,arg1
; Variants to make for orgams' lack of overloading.
      BYTE ld,dest,arg1
      ENDM

      MACRO LD2_C dest,arg1
      BYTE ld + if_c,dest,arg1
      ENDM

      MACRO LD3 dest,arg1,arg2
; Variants to make for orgams' lack of overloading.
      BYTE ld,dest,arg1,arg2
      ENDM

      MACRO LD3_C dest,arg1,arg2
      BYTE ld + if_c,dest,arg1,arg2
      ENDM

      MACRO LD3_NZ dest,arg1,arg2
      BYTE ld + if_nz,dest,arg1,arg2
      ENDM

      MACRO LD4 dest,arg1,arg2,arg3
; Variants to make for orgams' lack of overloading.
      BYTE ld,dest,arg1,arg2,arg3
      ENDM

      MACRO LD5 dest,arg1,arg2,arg3,arg4
; Variants to make for orgams' lack of overloading.
      BYTE ld,dest,arg1,arg2,arg3,arg4
      ENDM

      MACRO FUN1 fun,arg1
; Output result implicitly in out0
      BYTE fun1:WORD fun:BYTE arg1
      ENDM

      MACRO FUN1' fun,arg1,arg2
; Output result implicitly in out0
      BYTE fun1:WORD fun:BYTE arg1,arg2
      ENDM

      MACRO FUN1_Z' fun,arg1,arg2
; Output result implicitly in out0
      BYTE fun1 + if_z:WORD fun:BYTE arg1,arg2
      ENDM

      MACRO FUN2 fun,arg1,arg2
; Output result implicitly in out0, out1
      BYTE fun2:WORD fun:BYTE arg1,arg2
      ENDM

      MACRO CALL_EXT01 rout
      BYTE call_ext01:WORD rout
      ENDM

      MACRO CALL_EXT10 rout,arg1
;Arg passed in CDE
      BYTE call_ext10:WORD rout:BYTE arg1
      ENDM

      MACRO CALL_EXT1'0 rout,arg1,arg2
;Arg passed in CDE
; Still one input parameter, but computed from 2 operands
      BYTE call_ext10:WORD rout:BYTE arg1,arg2
      ENDM

      MACRO CALL_EXT11 rout,arg1
;Arg passed in CDE, 
      BYTE call_ext11:WORD rout:BYTE arg1
      ENDM

      MACRO CALL_EXT1'1 rout,arg1,arg2
;Arg passed in CDE
; Still one input parameter, but computed from 2 operands
      BYTE call_ext11:WORD rout:BYTE arg1,arg2
      ENDM

      MACRO JP rout
      BYTE jp:WORD rout
      ENDM

      MACRO JP_Z rout
      BYTE jp + if_z:WORD rout
      ENDM

      MACRO JP_NZ rout
      BYTE jp + if_nz:WORD rout
      ENDM

      MACRO JP_C rout
      BYTE jp + if_c:WORD rout
      ENDM

      MACRO JP_NC rout
      BYTE jp + if_nc:WORD rout
      ENDM

      MACRO RET0
      BYTE ret
      ENDM

      MACRO RET_Z
      BYTE ret + if_z
      ENDM

      MACRO RET_C
      BYTE ret + if_c
      ENDM

      MACRO RET_NC
      BYTE ret + if_nc
      ENDM

      MACRO BRK
      BYTE break
      ENDM

      MACRO BRK_Z
      BYTE break + if_z
      ENDM

      MACRO BRK_NZ
      BYTE break + if_nz
      ENDM

      MACRO BRK_C
      BYTE break + if_c
      ENDM

      MACRO BRK_NC
      BYTE break + if_nc
      ENDM

      MACRO SIGN in#,out#,flags
;Signatures.
;'flags' indicate which flags are returned by the routine.
      BYTE in#,out#,flags
      ENDM

  ; For signature
NO_FLAGS = 0
FLAG_Z = &60

; -----------------------------
;    AUM constants/enums
; -----------------------------

FRAME_REGS_SIZE = 32 * 4 ; 32 * 32-bits regs 

MAX_FRAMES = 4          ; recursion level admitted
MAX_OUTPUT_PARAMETERS = 4
MAX_EXT_PARAMETERS = 8

LIT_MIN = -1            ; a ajuster selon besoin
LIT_MAX = 15            ; 14 used (TRACK_BOX_HEIGHT)
      IF LIT_MAX - LIT_MIN AND &E0
 !!! cannot be encoded in 5 bits
      END

CONDITION_MASK = %00000111
MODIFIER_MASK = %11110000

; ---- Opcodes ----------------------
; We leave 3 LSB for conditions (Z, NZ, ...) 
      IF CONDITION_MASK - 7
 !!! must review encoding
      ENDM
ret   = &00
ld    = &08
fun1  = &10
fun2  = &18
call_ext01 = &20
call_ext10 = &28
call_ext11 = &30
jp    = &38
break = &40             ; clin d'oeil
call_ext50' = &48
; Re-evaluate encoding when reaching 16 opcodes.
      ; -> Shall we continue adding opcode?
         ; Or we can have one escape code, and leverage the free bit.
      ; Compare with RISC-V !

; ---- Conditions -------------------
always = 0              ; default: unconditional
if_z  = 1
if_nz = 2
if_c  = 3
if_nc = 4
; Re-evaluate encoding when reaching 8 conditions.
      ; Should "don't change flags" a la ARM be a special bit, 
      ; or one of the condition.

; ---- Operand modifiers ------------
      IF MODIFIER_MASK - &F0
 !! review encoding 
      END
reg   = 0               ; DEFAULT register 0..15 
      IF reg
!! must be 0, so we don't 
      END
lit_opcode = &10        ; integers from -lit_min..lit_max (inlined)
lit   = lit_opcode - LIT_MIN ; For encoding correction
lit_opcode' = &20
      IF lit_opcode' - lit_opcode - &10
!! must be contiguous
      END
lit20 = &30             ; followed by word (with LSQ: 20 bits)
add   = &40
sub   = &50
ind   = &60             ; indexed indirection: (reg + oper)
ind16 = &70             ; same, but troncated to 16 bits
ind_post = &80          ; indirection indexed: (reg) + oper
min   = &90
;Note: Min introduced as modifier:
     ;  - faster to code and to execute
     ;  - we still have room
     ; We might reconsider this choice later
        ; (e.g. if nested operations are rare, we can implement
              ; idea below)
max   = &A0
; You gotta respect the symettry.
conv16 = &B0            ; Convert 16 bits to reg_size
      IF todo
 ; 1/ should conv update flag Z/NZ?
 ; 2/ generic conv (with size in LSB)
      END
shift = &C0
; Shift rather than div, to allow division by 64
; (otherwise, need a way to encode 64!)

;Note: instead of add, sub,... opcodes, 
     ; we could introduce a 'binary op' escape code
; !!! Careful. For now we rely than one of the operands is necessary
; a reg. So we *cannot* have two 'ind' for instance, which allows to
; reuse same tmp 'internal register' (tmp_lit in that case, incidentaly)
; If we introduce complex combination tree, we'll have to change that
; (by a rolling buffer for instance).

; A voir ?
;fun
;and
;or
;xor

; ------- Registers ----------------
; Start by input registers,
; since we init a new frame with them. 
in0   = 0
in1   = 1
in2   = 2
in3   = 3
r0    = 4
r1    = 5
r2    = 6
r3    = 7
out0  = 8
out1  = 9
out2  = 10
out3  = 11
; Reevaluate when reaching 16

track_code
          jp Reset_tracks_and_subsongs
          jp New_module
          jp Song_attach_empty_phrases
          3 ** BRK

; -----------------------------
;      AUM Virtual Machine
; -----------------------------

; Some caracteristics: 
 ;- Function calls with local scope (1 set of register by stack frame)
    ; -> That's why there is no push/pop opcodes.
       ; Local registers should be enough.
 ;- 'add', 'xor', ... aren't opcodes, but an operand modifiers
    ; -> avoid temporary register
 ;- No 'cp' either: use 'sub' instead
 ;- Doesn't use IY, EXX or AF'
 ;- Speed isn't a goal.

eval
;---
; Main entry point.
;IN: hl = bytecode
;OUT: ahl = (out0) for convenience.
    ; !!!ARGL!!! why not CDE like the others?
    ; How costly it would be to uniformize?
      IF todo
; Lift flags as well?
      END

          push de
; Init frame 0
          call eval_init
          call eval_loop
; lift flags to z80
          ld hl,(aum_af):push hl:pop af
; pass back ahl = out0
          ld hl,(aum_regs + out0*4)
          ld a,(aum_regs + out0*4 + 2)
          pop de
          ret

eval_init
; In dedicated routine for nrts
          ld de,aum_regs:ld (frame_pnt),de
          ld de,aum_stack_:ld (aum_sp),de
          ret

eval_loop
; (exit happens at _ret)
          ld (aum_pc),hl ; for debug 

; ---- Decodes
          ld a,(hl)
          and CONDITION_MASK:jr z,.exec ; 0= always execute
          add a
          add cond_table AND &FF
          ld e,a
          ld d,cond_table/&0100
          ex de,hl
          ld a,(aum_af)
          and (hl):inc l ; Mask flag
          cp (hl)       ; Expected value of flag
          ex de,hl
          jr nz,skip

.exec
          ld a,(hl)     ; opcode # * 8
          and &FF-CONDITION_MASK
          inc hl
          add a:call c,to_be_implemented ; # * 16 for address
          ld ixl,a
          ld ixh,opcodes/&0100
          jp ix

skip
;---
; almost as complex as eval, since instr length depends not only
; on opcode, but on operands.
          ld a,(hl)     ; opcode # * 8
          and &FF-CONDITION_MASK
          inc hl
          add a:call c,to_be_implemented ; # * 16 for address
          ld ixl,a
          ld ixh,skipcodes/&0100
          jp ix


previous_frame
;------------- 
;1/ Set flag Z if out0 = 0
  ; -> This is an adhoc need. Might be revisited.
;2/ Copy output registers to previous frame
;[optim] TODO? Let outX registers at absolute place (not in frame).
   ; -> automatic tail call optim! 
   ; -> but _reg routine would be a bit slower, since we'll need
      ; to discriminate.
   ; !! Would hinder co-routines?
; Simpler optim: reduce MAX_OUTPUT_PARAMETERS to 2! 
  ; (pass bigger things via struct?)
;3/ Set pointer to previous frame and pop pc.

          ld hl,(frame_pnt)
; Check we are not in frame 0
          ld bc,aum_regs:or a:sbc hl,bc:add hl,bc
          call z,mess

; Prepare source/dest
          ld bc,-FRAME_REGS_SIZE + out0*4
          add hl,bc

          ex de,hl      ; de = out0 in previous frame
          ld hl,FRAME_REGS_SIZE
          add hl,de     ; hl = out0 in this frame
;[optim] TODO? Let outX registers at absolute place (not in frame).
   ; -> automatic tail call optim! 
   ; -> but _reg routine would be a bit slower, since we'll need
      ; to discriminate.
   ; !! Would hinder co-routines?
; Simpler optim: reduce MAX_OUTPUT_PARAMETERS to 2! 
  ; (pass bigger things via struct?)
          ld bc,MAX_OUTPUT_PARAMETERS*4
          ldir

;Update pnt and return to callee.
          ld bc,-MAX_OUTPUT_PARAMETERS*4 - out0*4 - FRAME_REGS_SIZE
          add hl,bc
          ld (frame_pnt),hl
          call pop_hl
          jp eval_loop

dest_reg
; destination is a plain register
;Note: dedicated routine so ld's code can fit in 16 bytes.
          ld a,(hl):inc hl
          call _reg
          call eval_operand_and_store
          jp eval_loop

dest_deref16
; destination is a (register + operand)
          xor (hl):inc hl
          call _add     ; = _reg + _add_op
          call deref
          call eval_operand_and_store16
          jp eval_loop

eval_operand_and_store
;---------------------
;In: HL points on operand in bytecode
   ; DE result pnt.
;OUT: HL past operands evaluated (several if arithmetic modifier)
    ; DE += reg_size
          push de
          call eval_operand
          ex (sp),hl
          ex de,hl
          reg_size ** ldi
          pop hl
          ret

eval_operand_and_store16
;-----------------------
; Same than eval_operand_and_store, but only copy 2 bytes
          push de
          call eval_operand
          ex (sp),hl
          ex de,hl
          2 ** ldi
          pop hl
          ret

eval_operand
;-----------  
;In: HL points on operand in bytecode
;OUT: HL past operands evaluated (several if arithmetic modifier)
    ; DE points on result value.
          ld a,(hl)
          and MODIFIER_MASK:ld ixl,a
          xor (hl)      ; parameter (register or litteral)
      IF dev_checks
          cp 16:call nc,mess
      END
      IF makeroom
; Read reg here (like _reg),
; as it is done for any modifier.
      END
          inc hl
          ld ixh,modifiers/&0100
jp_ix     jp ix
jp_hl = jp_ix + 1

_lit
;Litteral in LIT_MIN..LIT_MAX
          ld c,0        ; MSB: 0 for positive, &ff otherwise
      IF LIT_MIN AND &80:ELSE
 !! assumed LIT_MIN < 0
      END
          sub -LIT_MIN:jr nc,$+3:dec c
          ex de,hl
; Ridiculous cast from 5 bits to 24/32 bits.
      IF reg32
          ld hl,tmp_lit+3
          ld (hl),c:dec l
      ELSE
          ld hl,tmp_lit+2
      END
          ld (hl),c:dec l
          ld (hl),c:dec l
          ld (hl),a
          ex de,hl
          ret

_sub_op
          push de
          call eval_operand
          ex (sp),hl
          ld bc,tmp_binary
          ld ixl,reg_size
          or a          ; for first sbc
          ex de,hl
.sublp
          ld a,(de):inc e
          sbc (hl):inc l
          ld (bc),a:inc c
          dec ixl
          jr nz,.sublp
          jp binary_common ; will pop hl

_min_op
;Unsigned min
          push de
          call eval_operand
          ex (sp),hl

          ld b,reg_size
          or a          ; for first sbc
          ex de,hl
.cplp
          ld a,(de):inc e
          sbc (hl):inc l
          djnz .cplp
          jr c,$+3:ex de,hl ; carry: de is <= 
          reg_size ** dec e
          pop hl
          ret

_max_op
;Unsigned max
          push de
          call eval_operand
          ex (sp),hl

          ld b,reg_size
          or a          ; for first sbc
          ex de,hl
.cplp
          ld a,(de):inc e
          sbc (hl):inc l
          djnz .cplp
          jr nc,$+3:ex de,hl ; carry: de is <= 
          reg_size ** dec e
          pop hl
          ret


_add_op
          push de
          call eval_operand
          ex (sp),hl
          ld bc,tmp_binary
          ld ixl,reg_size
          or a          ; for first adc
.addlp
          ld a,(de):inc e
          adc (hl):inc l
          ld (bc),a:inc c
          dec ixl
          jr nz,.addlp
; Enchaine (will pop hl)
binary_common
;------------
;Post add/sub modifier, store flags.
          push af
          pop de
;Carry flag is ok with last operation on MSB
;For Z flag we must consider the whole value.
          ld hl,tmp_binary + reg_size - 1
          ld a,(hl):dec l
          or (hl):dec l
          or (hl)
;TM-stable
          ld a,&40      ; Z flags
          jr z,$+3:xor a
          res 6,e
          or e
          ld e,a

          ex de,hl
          ld (aum_af),hl
;here de= tmp_binary
          pop hl
          ret

conv16_to_reg_size
;In:  DE points on 16 bits unsigned value
;Out: DE points on same value padded with 0 to fit reg size.
    ; HL preserved
          push hl
          ex de,hl      ; hl: point on 16 bits value
          ld de,tmp_arg
          push de
          ldi:ldi
          xor a
      reg_size-3 ** [ld (de),a:inc e]
          ld (de),a
          pop de
          pop hl
          ret


skip_operand
;-----------  
; Like eval_operand, but don't perform evalutaion
;In: HL points on operand in bytecode
;OUT: HL past operands (several if arithmetic modifier)
          ld a,(hl)
          inc hl
          and MODIFIER_MASK:ld ixl,a
          ld ixh,skip_modifiers/&0100
          jp ix

call_ext0_com
;-----------
;Call from aum to asm (no return arg)
;IN: HL points on address
   ; B = number params
;OUT; Z/NZ set

          call call_ext_com_input
          jp eval_loop


call_ext_com
;-----------
;Call from aum to asm 
;IN: HL points on address
   ; B = number params (can be 0)
;OUT: Return value put back in ext0
    ; Z/NZ setup
;!!!! For now just 1 return arg handled.

          call call_ext_com_input

;Put returned BCDE in out0 register
          push hl
          ld hl,(frame_pnt)
          ld a,out0*4
          add l:call c,mess ; regs should be confined
          ld l,a
          ld (hl),e:inc l
          ld (hl),d:inc l
          ld (hl),c
      IF reg32
          inc l
          ld (hl),b
      END
          pop hl
          jp eval_loop


call_ext_com_input
;----------------
;Call from aum to asm 
;IN: HL points on address
   ; B = number params (can be 0)
;OUT: Flags lifted 
          call get_rout
          push de

          inc b
          dec b:jr z,.noargs
          dec b:call nz,to_be_implemented
; 1 argument: pass it via BCDE
          call eval_operand
          pop ix        ; was de: address routine
          push hl
          ex de,hl
      IF dev_checks
;dereferenced argument can be in bank,
;but not before bytecode, as we don't have variables before that.
          ld a,h
          cp bytecode_start/&0100:call c,mess
          cp &80:call nc,mess
      END
          ld e,(hl):inc l:call z,mess
          ld d,(hl):inc l:call z,mess
          ld c,(hl)
      IF reg32
          inc l:ld b,(hl)
      END
          jr .com
.noargs
          pop ix        ; was de: address routine
          push hl
.com
          call jp_ix
;lift flags to aum
          push af:pop hl:ld (aum_af),hl
          pop hl
          ret


      IF use_widget
call_ext_to_words
;----------------
;Call from aum to asm 
; Like call_ext_com, with convert 24bits regs to 16bits word
; + pass IX to the beginning 
; !!! This is an arbitrary choice, as we could modified called routine
; !!! to accept 24bits alignement.
; -> Simpler for now 

;IN: HL points on address
   ; B = number params
;!!!! For now just 1 return arg handled.
          call get_rout
          push de
          ld de,tmp_ext_args
.arglp
          push bc
          call eval_operand_and_store
          pop bc
          dec de        ; discare msb
;Note: MSB can contain garbage, as we might do 24 bits operands
     ; pointing on 16 bits words.
; Ed: xshift = x0 - t0   (with x0 a 16 bits field inside topleft struct)
          djnz .arglp

          pop de
          push hl
          ld hl,tmp_ext_args ; draw_box takes hl=struct pnt

          call jp_de

;Store flags
          push af:pop hl:ld (aum_af),hl
;For now, no result arg considered.

          pop hl
          jp eval_loop

jp_de     push de
          ret

      END

deref
;Dereference: DE = (DE)
          ex de,hl
          call read_pnt_bc
          ex de,hl
          ld e,c
          ld d,b
          ret

read_pnt_bc
;in:  hl= points to extended pointer
;out: bc= point, check proper bank connect

; Since v0g, all pointers are 16 bits
; Note: when we add 'op' (on 24 bits), 
      ; it change the word pointer (16 bits),
      ; but won't overflow, since we don't reach &ffff.
          ld c,(hl):inc hl
          ld b,(hl)
          ld a,b
          cp &80:call nc,mess
; This assert might be too strong!
          cp bytecode_start/&0100
          ret nc
      BRK
; Mess.
      BRK               ; for visu: read_pnt_bc failed

fun_com
;------
; Call sub-routine with new local scope. 
; IN: C: Number of args.

          call get_rout
          push de

          push bc
; Last frame? For now, programming error: too many nested calls.
; If we make recursive functions, can become a runtime error dependent
; on parameters.
          ex de,hl      ; save hl
          ld hl,(frame_pnt)
          ld bc,aum_regs_:or a:sbc hl,bc:add hl,bc
          call z,stack_overflow
; Destination for parameters: inputs of next frame.
          ld bc,FRAME_REGS_SIZE + in0
          add hl,bc
          ex de,hl      ; hl restored, de = dest

          pop bc

          push de
.lp
          push bc
          call eval_operand_and_store
      IF reg_size - 3
 !! double check
      ELSE
 ; 24 bits are stored, but for now we align to 32
          inc de
      END
          pop bc
          djnz .lp

          call push_hl  ; Return address for AUM

; Now that paramaters have been evaluated,
; move frame_pnt to new set of registers.
      IF in0
 !!! must correct to point start of registers
      END
          pop hl
          ld (frame_pnt),hl
          pop hl        ; function address
          jp eval_loop  ; Unstack done by _ret

skip_fun_com
; IN: HL = PC
    ; B = nb args (can be 0)
          inc hl:inc hl ; skip routine adr
          inc b
          jr .entry
.lp
          push bc
          call skip_operand
          pop bc
.entry
          djnz .lp
          jp eval_loop

get_rout
;In: HL: pointeur in byc
   ;  B: nb args passed
;Out: DE: verified function/routine address.
    ; HL += 2

          ld e,(hl):inc hl ; address function / routine
          ld d,(hl):inc hl
; Sanity check:
; No routine should be in 00XX or above 4000
;TODO: Refine checks
          ld a,d:or a:call z,mess
          cp &40:call nc,mess
; Check signature:
   ; - Argument matching (a la type system).
   ; - It would also help detect a bogus address.
          dec de
          dec de
          dec de
          ld a,(de):cp b:call nz,mess
          inc de
          inc de
          inc de
          ret

      MACRO OPCODE_ALIGN opcode
      FILL opcode*2 - [$ AND &FF],&F7
      ENDM

      MACRO MODIFIER_ALIGN modifier
      FILL modifier - [$ AND &FF],&F7
      ENDM

      FILL -$ AND &FF,0
;------
opcodes
;------
          OPCODE_ALIGN(ret)
_ret
;RET: go back to caller
          ld hl,(frame_pnt)
          ld de,aum_regs
          or a:sbc hl,de
          jp nz,previous_frame
;---- Evaluator exit -----
          ret

          OPCODE_ALIGN(ld)
_ld
          ld a,(hl)
          and MODIFIER_MASK:jp z,dest_reg
          cp ind16:jp z,dest_deref16
      BRK
; Error programming: modifier not handled for dest register

          OPCODE_ALIGN(fun1)
          ld b,1        ; 1 parameter
          jp fun_com

          OPCODE_ALIGN(fun2)
          ld b,2        ; 2 parameters
          jp fun_com

          OPCODE_ALIGN(call_ext01)
          ld b,0
          jp call_ext_com

          OPCODE_ALIGN(call_ext10)
          ld b,1
          jp call_ext0_com

          OPCODE_ALIGN(call_ext11)
          ld b,1
          jp call_ext_com

          OPCODE_ALIGN(jp)
;!!! Don't use get_rout since we don't do signature check here.
          ld e,(hl):inc hl
          ld d,(hl):inc hl
          ex de,hl
          jp eval_loop

          OPCODE_ALIGN(break)
          push hl
          ld bc,&0601:call scr_set_border
          call km_wait_key
          pop hl
      BRK
; BREAK triggered from AUM bytecode itself.
; HL = PC = past BRK() bytecode.
          jp eval_loop

      IF use_widget
          OPCODE_ALIGN(call_ext50')
          ld b,5
          jp call_ext_to_words
      END

      FILL -$ AND &FF,&F7

;-------
skipcodes
;-------
          OPCODE_ALIGN(ret)
;Already skipped, nothing to do
          jp eval_loop

          OPCODE_ALIGN(ld)
          ld a,(hl)
; destination should be a plain register
          and MODIFIER_MASK:call nz,mess
          inc hl
          call skip_operand
          jp eval_loop

          OPCODE_ALIGN(fun1)
          ld b,1
          jp skip_fun_com

          OPCODE_ALIGN(fun2)
          ld b,2        ; 2 parameters
          jp skip_fun_com

          OPCODE_ALIGN(call_ext01)
          ld b,0
          jp skip_fun_com

          OPCODE_ALIGN(call_ext10)
          ld b,1
          jp skip_fun_com

          OPCODE_ALIGN(call_ext11)
          ld b,1
          jp skip_fun_com

          OPCODE_ALIGN(jp)
          2 ** inc hl
          jp eval_loop

          OPCODE_ALIGN(break)
          jp eval_loop

      IF use_widget
          OPCODE_ALIGN(call_ext50')
          ld b,5
          jp skip_fun_com
      END

      FILL -$ AND &FF,&F7

;--------
modifiers
;--------
; Common input: A = LSQ 0..&f  (reg, literal, ...)
              ;HL = past modifier
; Common output: DE points to computed value
               ; HL = past operand (if any)
          MODIFIER_ALIGN(reg)
_reg
; Each register is 4-bytes aligned
          2 ** add a
          ld de,(frame_pnt)
          add e:call c,mess ; assume confined
          ld e,a
          ret

          MODIFIER_ALIGN(lit_opcode)
          jp _lit

          MODIFIER_ALIGN(lit_opcode')
          add &10
          jp _lit

          MODIFIER_ALIGN(lit20)
          ld de,tmp_lit
          push de
          ldi
          ldi
          ld (de),a     ; LSQ becomes MSQ (bits 19..16)
          pop de
          ret

          MODIFIER_ALIGN(add)
_add
;Add register with result of next operand
          call _reg
          jp _add_op

          MODIFIER_ALIGN(sub)
;Remove result of next operand from register
          call _reg
          jp _sub_op

          MODIFIER_ALIGN(ind)
; Like add, but then dereference.
; Add: dest:= reg + op
; Ind: dest:= (reg + op)
          call _add     ; = _reg + _add_op
          jp deref

          MODIFIER_ALIGN(ind16)
; Like ind, but unsigned convertion to 24 bits (pad with 0)
; Ind16: dest:= (reg + op) (16 bits, converted to 24)
          call _add     ; = _reg + _add_op
      BRK
 ; TODO: Right now just used for /_ld/
          di:halt       ; marker for visu
;          jp deref16

          MODIFIER_ALIGN(ind_post)
; Dereference then add
; ind_post: dest:= (reg) + op
          call _reg
          call deref
          jp _add_op

          MODIFIER_ALIGN(min)
;Unsigned min
;similare to sub, but: don't store result (actually perform compare)
;de points to less reg (second one if eq)
          call _reg
          jp _min_op

          MODIFIER_ALIGN(max)
;Unsigned max
;similare to sub, but: don't store result (actually perform compare)
;de points to bigger reg (second one if eq)
          call _reg
          jp _max_op

          MODIFIER_ALIGN(conv16)
      IF reg_size - 2:ELSE
  !! replace by noop
      END
          call eval_operand
          jp conv16_to_reg_size

          MODIFIER_ALIGN(shift)
          call _reg
          push de
          call eval_operand
          ex (sp),hl
;Sanity: check bits8..15 are 0
;(don't check for 16..23, are they might contain garbage when 
; input is 16 bits)
          inc de:ld a,(de):or a:call nz,mess
          dec de:ld a,(de)
          or a
          call m,to_be_implemented ; Shift to left
;Sanity: for now shouldn't be 0, as it would mean no-op
; (might happen in the future with dynamic parameter)
          call z,mess
;Copy for in-place shift (needed since several iterations)
          ld de,tmp_binary
          ld bc,reg_size
          ldir
          ld c,a
.shflp
          push de
          ld b,reg_size
          or a          ; First nc
.lp
          dec e:ld a,(de)
          rra
          ld (de),a
          djnz .lp
          pop de
          dec c
          jr nz,.shflp
          jp binary_common ; will pop hl

pad                     ; some free space here.
      FILL -$ AND &FF,&F7
;------------
skip_modifiers
;------------
; Common input: HL past operand
; Common output: HL past all operands (in case of binary operand)
          MODIFIER_ALIGN(reg)
; Nothing to do already skipped
          ret

          MODIFIER_ALIGN(lit_opcode)
          ret

          MODIFIER_ALIGN(lit_opcode')
          ret

          MODIFIER_ALIGN(lit20)
          2 ** inc hl
          ret

          MODIFIER_ALIGN(add)
          jp skip_operand

          MODIFIER_ALIGN(sub)
          jp skip_operand

          MODIFIER_ALIGN(ind)
          jp skip_operand

          MODIFIER_ALIGN(ind_post)
          jp skip_operand

          MODIFIER_ALIGN(min)
          jp skip_operand

          MODIFIER_ALIGN(max)
          jp skip_operand

          MODIFIER_ALIGN(shift)
          jp skip_operand

      FILL -$ AND &FF,&F7
; TODO: skip other existing modifiers

push_hl
;------
; PUSH HL to AUM stack
; Out: HL in aum_stack, aum_sp --
     ; HL trashed 
          ex de,hl
          ld hl,(aum_sp)
          ld bc,aum_stack:or a:sbc hl,bc:add hl,bc
          call z,stack_overflow
          call c,stack_overflow
          dec l:ld (hl),d
          dec l:ld (hl),e
          ld (aum_sp),hl
          ret

pop_hl
;-----
; POP HL from AUM stack
; Out: HL = aum_sp[0]
          ; aum_sp ++
          ld hl,(aum_sp)
          ld bc,aum_stack_:or a:sbc hl,bc:add hl,bc
          call nc,stack_overflow ; well, "empty stack" rather
          ld e,(hl):inc l
          ld d,(hl):inc l
          ld (aum_sp),hl
          ex de,hl

          ld a,h:cp bytecode_start/&0100:call c,mess
;Note: bytecode can live among hosts, so past end of this source.
          cp &40:call nc,mess
          ret

cond_table
;Mask for each flag (e.g Z: bit 6) and then expected value
      BYTE 0,0          ; Note: not used as we shortcut for /always/
      BYTE &40,&40      ; /if_z/
      BYTE &40,0        ; /if_nz/
      BYTE &01,&01      ; /if_c/   
      BYTE &01,0        ; /if_nc/

      IF $-1/&0100 - cond_table/&0100
 !! Error confignement
      END

stack_overflow = mess

setup_one_reg
;-------------
          ld b,1
setup_regs              ; used by tracknrt
;---------
; Loop input registers
; IN: hl: source
    ;  b: nb register 
          ld de,aum_regs + in0*4
setup_regs'
;---------
.lp
          push bc
          push de
          ld bc,reg_size
          ldir
          pop de
          ld a,e:add 4:call z,mess
          ld e,a
          pop bc
          djnz .lp
          ret

; -----------------------------
;    Routines in AUM bytecode
; -----------------------------
bytecode_start

prepend_in_aum = 0

      IF prepend_in_aum
!!! aum_prepend_event still WIP
; For now that's harder for me to get it right in AUM!
; Plus, AUM is handy for its handling of time in 24 bits,
; Note so much for 16 bits pnt manipulation:
   ; -> longer code than z80
   ; -> use hacks (ind16)

          SIGN(2,1,FLAG_Z)
aum_prepend_event
;----------------                            
; Insert blank event at time t

; in0: track   (pnt in tracks)  
; in1: t 

tmp   = r0
void  = r1
pnt0_link = r2
          FUN2(set_hook_at,track,t)
          LD3(pnt0_link,out0 + add,lit + idsz + evt0_link)
; tmp = hook.evt0_link  (copy reg_size = 3 bytes, nevermind)
          LD3(tmp,pnt0_link + ind,lit + 0)
; create event
          CALL_EXT01(ext_new_event_node)
; hook.evt0_link = new_event
          LD2(pnt0_link + ind16,out0)
; new_event.link = tmp
; !!! note: only 16bits are copied, despite generic node with 24bits
          ; link
      IF todo
; ensure we use dedicate 'follow_next' (in ply that's an adhoc routine)
; at some point, just reserve 16 bits for links (YAGNI YET) 
      END
          LD4(out0 + ind16,lit + 0,tmp + ind,lit + 0)
          RET0()
      END

          SIGN(2,3,FLAG_Z)
set_hook_at
;----------             
; Add hook if not already present.
; in0: track   (pnt in tracks)
; in1: t: target time    
; out0: existing or new hook

; Get hook at t0 <= t 
dur   = r0
          FUN2(get_hook_at,track,t)
;t0= start of current hook (or 0 if none)
          LD3(dur,t + sub,t0)
          RET_Z()       ; Nothing to do if already event here
; We must insert hook at t > t0
; If t >= t0 + &10000, we must insert intermediate 
          CALL_EXT10(ext_is_24bits,dur)
          JP_Z(.ok)
;Recursive call.
;Note: not worth if to make a special macro for additional operands
          FUN2(set_hook_at,track,t0 + add):BYTE lit20:WORD &FFFF
;retry (quadratic behaviour, nevermind)
          JP(set_hook_at)

.ok
; hook.dur = t-t0
          LD3(out0 + ind16,lit + idsz + evt0_dur,dur)
          CALL_EXT11(ext_insert_hook_node_after,out0)
; new_hook.dur = t1-t
          LD4(out0 + ind16,lit + idsz + evt0_dur,t1 + sub,t)
          RET0()

          SIGN(2,3,FLAG_Z)
get_hook_at
;----------
; Given t, return NZ, hook spanning from t0..t1 such than t0 <= t < t1
; (or t0 <= t for last clip)
; Note: necessarily such a clip 

; in0: track   (pnt in tracks)
; in1: t: target time    
; out0: evt0 node
; out1: t0 (time start of hook)  
; out2: t1 (time start of following hook)  
track = in0
t     = in1
tgcaclip = out0
t0    = out1
t1    = out2
void  = r1
; t0 := 0
          LD2(t0,lit + 0)
; clip (out0) := track.events
          LD3(tgcaclip,track + ind,lit + tf_clips)
          BRK_Z()       ; Programming error. At least one event
.loop
; t1 = t0 + cur_clip.duration
          LD5(t1,t0 + add,conv16,tgcaclip + ind,lit + idsz + evt0_dur)
; loop while t >= t1 and eoc not met
          LD3(void,t + sub,t1)
          RET_C()       ; NZ
; next clip  
; clip := clip.next() (unless last one, unchanged)
          CALL_EXT11(ext_next_node,tgcaclip)
          RET_Z()
; Only update t0 if we effectively went to next clip
          LD2(t0,t1)
          JP(.loop)

          SIGN(2,3,FLAG_Z)
get_event_at
;-----------
; Like /get_hook_at/ but filter against reg_event
; !!! must be called at top-level since /ext_fetch_event/ reads in2
    ; directly. 
reg_event = in2
          LD2(t0,lit + 0)
          LD3(tgcaclip,track + ind,lit + tf_clips)
          BRK_Z()       ; Programming error. At least one event
.loop
          LD5(t1,t0 + add,conv16,tgcaclip + ind,lit + idsz + evt0_dur)
;!hack! reg_event passed implicitly
;TODO: decide proper API when passing several args
          CALL_EXT1'0(ext_fetch_event,tgcaclip+add,lit+idsz + evt0_link)
          LD3(void,t + sub,t1)
          RET_C()       ; NZ
          CALL_EXT11(ext_next_node,tgcaclip)
          RET_Z()
          LD2(t0,t1)
          JP(.loop)



Song_select_track
;----------------
;IN: A= track id
          call scope_bk_track
          ld (current_track),a
          ret

Song_select_new_track
;-------------------- 
; Create track (not attached to a subsong, for sharing and loading).
    ; Use Subsong_add_track afterwards.
;IN: A = Id
;Out: Track selected for track_* routines
   ; A preserved
    ; Assert if memory full.
; Note: we plug an empty event hook (necessarily at t=0 since
                                    ;no duration in header)
      ; It simplifies code (no test needed "null vs not-null")
      ; Especially when first real event inserted at t>0:
; We must have  header -> HOOK(dur=t, evt=null) -> HOOK(evt)
; Without dummy first HOOK already there,
; we would have to create 2 hooks. Ugly.

          call scope_bk_track
          push af
          cp 4:call nc,to_be_implemented ; see /todo1/
          cp MAX_TRACKS:call nc,mess
          ld (current_track),a

          call get_track_header
; --- Init list: dummy hook at t=0    
          ld a,idsz + evt0_size
          call New_node_x
          call hook_setup
          ld (hl),e:inc hl
          ld (hl),d
      IF tf_struct_size - 2
 !!! oversight
      END
          pop af
          ret

      END



Set_phrase_at_t
;--------------
; Set phrase into current track 
; In: A = id phrase        
    ; hl = pnt to t
;Out: hl = pnt hook
          call scope_bk_track
          push hl
          call Get_phrase:call z,mess
          ex de,hl
 ; Directly phrase itself instead of header
      IF dev_checks
 ; check assumption. May change with tiny chunks
          ld a,e:cp chunk_start:call nz,mess
      END
          ld e,phrase_start
          pop hl
          ld a,evt_change_phrase_lsb
;enchaine
set_event
;--------
; If event already exist, replace it.
; Otherwise, put it last (but before set_phrase).
; In:  A = type event  
    ; de = param event      
    ; hl = pnt to t
;Out: hl = pnt hook
          push de:push af
          call setup_track_t
          ld hl,set_hook_at
          call eval
 ; here hl= start hook structure
          pop af:pop de
          push hl
          push de:push af
          idsz + evt0_link ** inc hl
          call goto_event
          jr nz,.oknode
;Must insert new node so that set_phrase is always last.
; - Append (at hl) if set_phrase  
; - Insert before last (at de) other
          pop af:push af
          cp evt_change_phrase_lsb
          jr z,.okpos
          ex de,hl
.okpos
          ld a,idsz + evt_size
          call Insert_new_node:call nc,mess
          ex de,hl
      IF dev_checks
          ld a,h
          cp track_events/&0100:call c,mess
          cp track_events_/&0100:call nc,mess
      END
; Setup node itself
  ; We do it in z80 rather than aum for convenience
  ; (as time of writing no modifier to read/write single bytes)
          idsz ** inc hl ; skip link
.oknode
          pop af:pop de
          ASSERT(evt_type == 0)
          ld (hl),a:inc hl
          ASSERT(evt_param == 1)
          ld (hl),e:inc hl
          ld (hl),d
          pop hl
          ret


Set_transpose_at_t
;-----------------
; Set phrase into current track 
; !!See note at Set_phrase_at_t
; In: A = transpose (signed)        
    ; hl = pnt to t
;Out: hl = pnt hook
      IF todo
;!!! right now we use prepend_event, as we know that converter
; will call that first.
; Instead, we should check if event exist (and replace it)
      END
; Premultiply by 2 to match periods table.
          add a
          ld e,a
; For checks and neater serialisation, we put unused byte at 0.
; Future-proof as we can add flags later.
          ld d,0
          ld a,evt_set_transpose_lsb
          jr set_event


track_select_last_phrase
;--------------------
          call scope_bk_track ; when coming from phrasui
          ld hl,time_inf
          call track_select_phrase_at
          ld a,evt_change_phrase_lsb
          call track_get_event_at
          ld hl,fetched_t0
          ld de,time_param
          push de
          call copy_time
          pop hl
;enchaine
track_select_phrase_at
;---------------------
; Given t, selected phrase spanning from t0..t1 such than t0 <= t < t1
; or return Z if no such phrase.
; In: hl = pnt to t
;Out: If such phrase, NZ, phrase selected
                  ; HL = t - time at start of phrase MOD phrase duration
                  ; Carry if first iteration of phrase
    ; Otherwise, Z (for phrasui to detect end of track)
          call scope_bk_track
          push ix
          push de
          push hl
          ld a,evt_change_phrase_lsb
          call track_get_event_at
          jr z,_exit
; -- Select phrase
 ; Here de: phrase start (after header)
          ld hl,fc_index - clip_header_size
          add hl,de
          call get_phrase_id
          call song_select_phrase
      IF dev_checks
          call z,mess
      END
; -- Invariant fetched_t1 > t
; Correction needed when e.g transpose in middle of phrase
          pop de        ; was hl = t
          push de
          ld hl,fetched_t1
          call cp_ide_ihl
          jr c,.okt1
          push hl
          ex de,hl      ; hl = t
          call track_get_hook_at
          ld hl,aum_regs + t1*4
          pop de        ; was hl: fetched_t1
          call copy_time
.okt1
; -- AHL = t-t0
          pop bc        ; t
          ld hl,fetched_t0
          call sub_ade_ibc_ihl
          ex de,hl
; Now check if < phrase duration
          call phrase_get_duration
      IF dev_checks
          push af
          ld a,c:or e:or d:call z,mess
          pop af
      END
          call sub_ahl_cde
          jr c,.done    ; Carry if yes
; Get modulo dur to get pos in phrase
; and adjust t0 to point start of repetition
.mod
          push hl
          ld hl,fetched_t0
          call add_ihl_cde
          pop hl
          call sub_ahl_cde
          jr nc,.mod
          ccf           ; NC without touching NZ
.done
; NZ here
          push af
          call add_ahl_cde
; Note: A is discarded, as we only handle time offset in 16 bits
      IF dev_checks
          or a:call nz,mess
      END
          pop af
          push hl
_exit
          pop hl
          pop de
          pop ix
          ret

track_get_state_at
;-----------------
; For now, state consists on only transpose
; In: hl = pnt to t
; Out: A = transpose
     ; hl preserved
          call scope_bk_track
          push hl:push ix
          ld a,evt_set_transpose_lsb
          call track_get_event_at
          pop ix:pop hl
          ld a,0
          ret z
          ld a,e
          sra a
          ret

;-----------------------------------------
dec_ihl
;(hl) -= 1
          ld a,(hl):dec (hl):or a:ret nz
          inc hl
          ld a,(hl):dec (hl):or a:ret nz
          inc hl
          dec (hl)
          ret

cp_ide_ihl
          push de:push hl
          2 ** inc de
          2 ** inc hl
          call cp_ide_ihl_end
          pop hl:pop de
          ret

cp_ide_ihl_end
          ld a,(de):cp (hl):ret c:ret nz
          dec de:dec hl
          ld a,(de):cp (hl):ret c:ret nz
          dec de:dec hl
          ld a,(de):cp (hl)
          ret

sub_ahl_cde
; AHL -= CDE
; Return C/NC (!!!! Z flag not accurate, NZ if Carry)
          or a:sbc hl,de
          sbc c
          ret

sub_ade_ibc_ihl
; ADE = (bc) - (hl)
; Return C/NC (!!!! Z flag not accurate, NZ if Carry)
          ld a,(bc):sub (hl):ld e,a:inc bc:inc hl
          ld a,(bc):sbc (hl):ld d,a:inc bc:inc hl
          ld a,(bc):sbc (hl)
          ret

sub_ide_ihl_bc
; (de) = (hl) - bc
; Return C/NC (!!!! Z flag not accurate, NZ if Carry)
          ld a,(hl):inc hl:sub c:ld (de),a:inc de
          ld a,(hl):inc hl:sbc b:ld (de),a:inc de
          ld a,(hl):inc hl:sbc 0:ld (de),a
          ret

sub_ihl_de
; (hl) -= de               
; HL preserved
; Return C/NC (!!!! Z flag not accurate if NC, NZ if Carry)
          ld a,(hl):sub e:ld (hl),a:inc hl
          ld a,(hl):sbc d:ld (hl),a:inc hl
          ld a,(hl):sbc 0:ld (hl),a ; for N/NC
          2 ** dec hl
          ret


add_ahl_cde
; AHL += CDE
; Return C/NC (!!!! Z flag not accurate if NC, NZ if Carry)
          add hl,de
          adc c
          ret

      IF 0
sub_de_ibc_ihl
; DE = (bc) - (hl)
; Return C/NC (!!!! Z flag not accurate if NC, NZ if Carry)
          ld a,(bc):sub (hl):ld e,a:inc bc:inc hl
          ld a,(bc):sbc (hl):ld d,a:inc bc:inc hl
          ld a,(bc):sbc (hl)
      IF dev_checks
          call nz,mess  ; ovf
      END
          ret
      END

add_ihl_cde
; (hl) += cde
; AF preserved
          push af
          ld a,(hl):add e:ld (hl),a:inc hl
          ld a,(hl):adc d:ld (hl),a:inc hl
          ld a,(hl):adc c:ld (hl),a
          pop af
          ret

add_ihl_ibc_de
; (hl) = (bc) + de 
          ld a,(bc):add e:ld (hl),a:inc bc:inc hl
          ld a,(bc):adc d:ld (hl),a:inc bc:inc hl
          ld a,(bc):adc 0:ld (hl),a
          ret

add_ihl_de
; (hl) += de
          push hl
          ld a,(hl):add e:ld (hl),a:inc hl
          ld a,(hl):adc d:ld (hl),a:inc hl
          jr nc,.ok
          inc (hl)
.ok
          pop hl
          ret

      IF 0
add_ide_ibc_hl
; (de) = (bc) + hl
          ld a,(bc):add l:ld (de),a:inc bc:inc de
          ld a,(bc):adc h:ld (de),a:inc bc:inc de
          ld a,(bc):adc 0:ld (de),a
          ret
      END

copy_time
; in: hl = src
    ; de = dest
          3 ** ldi
          ret

track_get_event_at
;-----------------
; In:  A = event type
    ; hl = pnt to t
;Out: If such hook, NZ
                  ; hl = event structure
                  ; de = param (for convenience)
    ; Otherwise, Z
    ; AF, BC, IX? trashed
          call setup_track_t
          ld (aum_regs + reg_event*4),a
          ld hl,0:ld (fetched_event),hl
          ld hl,get_event_at
          call eval
          ret z         ; when past end
          ld hl,(fetched_event)
          ld a,l:or h
          ret z
          ASSERT(evt_param == 1)
          inc hl:ld e,(hl)
          inc hl:ld d,(hl) ; For convenience
          2 ** dec hl   ; NZ
          ret

get_timestamp_from_hook
;----------------------
; In: hl= hook pnt (typically loop)
    ; !! Corresponding track selected
;Out: If found, Carry, bc= pnt to timestamp
    ; NC otherwise
          ld bc,timestamp+2
          xor a
          ld (bc),a:dec bc
          ld (bc),a:dec bc
          ld (bc),a
          ex de,hl
          call get_current_track_header
.lp
          ld a,(hl):inc hl:or (hl):ret z ; not found
          ld a,(hl):dec hl:ld l,(hl):ld h,a
          or a:sbc hl,de:add hl,de:scf:ret z ; found
;Add duration and goto to next
          idsz ** inc hl
          ld a,(bc):add (hl):ld (bc),a:inc hl:inc bc
          ld a,(bc):adc (hl):ld (bc),a:dec hl:inc bc
          ld a,(bc):adc 0:ld (bc),a:2 ** dec bc
          idsz ** dec hl
          jr .lp


Set_hook_duration
;----------------                
; Needed by chipn 
; Usually a hook duration is set when adding a new one
; That doesn't work for last hook
; In; hl = pnt to hook timestamp
    ; de = duration (0 for 65536) 
          push de
          call track_get_hook_at
          pop de
          jr _set_duration_com

Set_last_hook_duration
;---------------------
; Needed by salo. Same rationale than Set_hook_duration
          push de
          call track_get_last_hook
          pop de
_set_duration_com
          idsz ** inc hl
          ld (hl),e:inc hl
          ld (hl),d
          ret

track_set_loop_at
;----------------
; Encoded as event. See rationale in journal
; Memory leak if set in middle of track, nevermind.
; In: hl = pnt time loop hook (t)
    ; de = pnt time loop dest (t0)
;Mod: AF, BC, DE, HL
          push hl
          ex de,hl
          call track_get_hook_at
          ex (sp),hl
          ld a,evt_track_loop_lsb
          call set_event

          pop de
          ld (hl),e:inc hl
          set 7,d
          ld (hl),d:inc hl
; set dur = 0 (since automaticaly added in ply.o)
          xor a
          ld (hl),a:inc hl
          ld (hl),a
          ret

track_get_last_hook
;------------------
;out: de = pnt last timestamp
          call scope_bk_track ; when coming from phrasui
          ld hl,time_inf
;enchaine
track_get_hook_at
;----------------
 ;In: hl = pnt to t
;Out: hl = hook structure
    ; de = pnt to timestamp start hook
          call setup_track_t
          ld hl,get_hook_at
          call eval
          ld de,aum_regs + t0*4
          ret

track_set_hook_at
;----------------
; Set hook if not already existing
 ;In: hl = pnt to t
;Out: hl = hook structure
    ; de = pnt to timestamp start hook
          call setup_track_t
          ld hl,set_hook_at
          call eval
          ld de,(aum_regs + out0*4)
          ret

setup_track_t
;------------
; Setup aum registers:
  ; in0=current track
  ; in1=t
; In: hl = pnt to t 
;Out: aum.in0 and in1
          push af:push de
          call connect_bk_track
          ld de,aum_regs + in1*4
          ld bc,reg_size
          ldir
          call get_current_track_header
      IF reg_size-3
 !! review that
      END
          ld (aum_regs + in0*4),hl
      IF dev_checks
;Track must exist
          inc hl:ld a,(hl):and &C0:cp &40:call nz,mess
      END
          ld a,BK_TRACK
          ld (aum_regs + in0*4 + 2),a
          pop de:pop af
          ret

goto_event
;---------
;Goto to specified event.
 ; If no such event, return last and before last link pnts
 ; (for append and insert before last event, respectively)
;in: hl= link to next event (typical evt field in evt0)
       ; Assume H<>0
   ;  a= event type (LSB routine)
;out: If found, NZ, HL points evt type, 
    ; otherwise  Z. HL points to last link (0000),
                  ; DE points to prev link (can be = HL when no node) 

    ; A preserved in any case
          push hl:pop de ; de = previous link
.find
          push hl
          push de
          call Next_node
          pop de
          jr z,.last
          pop de        ; de = previous link
          idsz ** inc hl
          ASSERT(evt_type == 0)
          cp (hl)
          jr z,.found
          idsz ** dec hl
          jr .find

.last
          pop hl
          ret

.found
          inc h:dec h   ; NZ 
      IF dev_checks
          call z,mess
      END
          ret

get_current_track_header
;-----------------------
;In: N/A
;out: hl: track pnt
          call connect_bk_track ; !! No /scope_bk_track/
          ld a,(current_track)
          jp get_track_header

set_empty_list
;in: pnt to list 
          ld b,idsz
.raz      ld (hl),0:inc hl:djnz .raz
          ret

Init_track_module
;----------------
      IF todo
; Fill tracks with 00 here,
; and release tracks to avoid memory leaks.
; Or init everything (e.G. track pool pointer) at reset time? 
  ; what would be the best when multiple modules?
      END
;enchaine
Reset_tracks_and_subsongs
;------------------------
; No tracks, no subsong.

          call scope_bk_track
      IF do_set_replay_period
          ld hl,replay_50_08Hz
          call set_replay_period
      END
;track index + variables reset
          ld hl,tracks
          ld b,track_zero_
;00 is needed to mark if track is used or not
          xor a
.fill     ld (hl),a:inc hl:djnz .fill

;Reset subsongs as well
          ld hl,subsongs
          ld (hl),a:inc l ; null link next subsong
          ld (hl),a:inc l ; link: no track for now
          ld a,l:ld (subsong_pool_pnt),a
          ret

New_module
;---------
; Create 3 track (one for each channel), with a phrase for each.
; User-friendly, and i don't want to handle empty tracks for now ui-wise
          call Reset_tracks_and_subsongs
;enchaine
          xor a
      IF todo
;number from 1?
      END
New_subsong
;----------    
; !!! lives here to avoid song->track dep.
;In: A = subsong ID    
      IF todo
;number from 1?
      END
          push bc:push hl
          call Subsong_add
          ld a,1
.lp
 ; No need to select it per se, only the "new_track" is of interest
          call Song_select_new_track
          ld hl,track_tmp
          ld (hl),a:inc l ; id
          ld (hl),a:dec l ; output 1 2 3  (channels A B C)
          ld c,2
          call Subsong_add_track
          inc a
          cp 4
          jr nz,.lp
          pop hl:pop bc
          ret

Song_attach_empty_phrases
; For UI: init each track with empty phrase of 64 rows
          ; - more user friendly
          ; - i don't want to handle display of empty tracks for now!
          ld a,1
.lp
          call Song_select_track
;-- phrase with 64 rows of delai
          push af
          call song_select_new_phrase
;-- hack for 2: two blanks rows to have desired duration
          ld a,delai_ui_default*64/2:call phrase_select_new_row
          ld a,delai_ui_default*64/2:call phrase_select_new_row
          pop af
;-- pin at 0
          push af
          ld hl,time_zero
          call Set_phrase_at_t

          pop af
          inc a
          cp 4
          jr nz,.lp
          ret

Song_add_map
;-----------
; Used by import (chipn, st128, ...)
; In; hl=table song map (3x phrase id, transpose)
    ;  b=patterns#

; Note: this routine lives here,
      ; as we don't want chung->track dependency

      IF todo
; [crunch] Don't set phrase or transpose if same! 
      END

          xor a
          call New_subsong

          xor a
          call .onechannel
          call .onechannel
          call .onechannel

          xor a
          call .onetranspose
          call .onetranspose
          call .onetranspose

          ret

.onechannel
; IN: a= channel number (1,2,3)
    ;  b=patterns#
          push af:push bc:push hl
          call .prep
.lpc
          push bc:push de:push hl
          add hl,de
          ld a,(hl)
          push af
          ld hl,timestamp
          push hl
          ld de,previous_timestamp
          ld bc,3:ldir
          pop hl
          call Set_phrase_at_t

; -- time += phrase duration (chipnsfx and madmax behavior)
      IF todo
; Starkos: how to do respect "phrase height"?
; -> answer dedicated table 
      END
          pop af
          call .advancetime
          pop hl
          ld de,6:add hl,de ; next row in input table
          pop de
          pop bc
          djnz .lpc

; -- Set last phrase duration
; For other phrases it is done automatically when next phrase is hooked
          call phrase_get_duration ; was selected by .advancetime
      IF dev_checks
          inc c:dec c:call nz,mess ; must be < &10000
      END
      IF todo OR makeroom
; use Set_last_hook_duration
      END
          ld hl,previous_timestamp
          call Set_hook_duration

      IF do_set_loop
;Set loop to 0 (good default). 
          ld hl,timestamp
          ld de,time_zero
          call track_set_loop_at
      END

          pop hl:pop bc:pop af
          inc a
          ret

.onetranspose
; IN: a= channel number (0,1,2)
          push af:push bc:push hl
          call .prep
.lpt
          push bc:push de:push hl
          add hl,de
          ld a,(hl):push af
          inc hl:ld a,(hl)
          ld hl,timestamp
          call Set_transpose_at_t

; time += phrase duration (chipnsfx and madmax behavior)
          pop af
          call .advancetime
          pop hl
          ld de,6:add hl,de ; new pos in table
          pop de
          pop bc
          djnz .lpt

          pop hl:pop bc:pop af
          inc a
          ret

.prep
          ld de,0
          ld (timestamp),de
          ld (timestamp+1),de
          ld e,a:sla e  ; de=a*2 (shift in input songmap)
          inc a         ; Start numbering at 1
          jp Song_select_track

.advancetime
;A:phrase id
          call song_select_phrase:call z,mess
          call phrase_get_duration
          ld hl,timestamp
          ld a,e:add (hl):ld (hl),a:inc hl
          ld a,d:adc (hl):ld (hl),a:inc hl
          ld a,c:adc (hl):ld (hl),a
          ret

;---------------------------------
;  ASM routines called from AUM
;---------------------------------
          SIGN(1,0,FLAG_Z)
ext_is_24bits
;------------
; In: CDE = value
;Out: NZ if CDE > &ffff
          ld a,c
          or a
          ret

          SIGN(1,1,NO_FLAGS)
ext_insert_hook_node_after
;-------------------------
;  IN: DE = pointer to link to next node, either in:
          ; - current node
          ; - track header
; OUT: DE = pnt new node 
     ; HL = pointer (was DE.in). Only used when called directly

; Ensure node is allocated in proper bank
          call connect_bk_track
; Just reserve the right size
      IF todo
; when freeing those nodes, they most by collected by free_list7
; (or should we do generic nodes knowing their own size?)
      END
          ex de,hl
          ld a,idsz + evt0_size
          call Insert_new_node
          call nc,mess  ; TODO: handle memory full
      IF dev_checks
          ld a,d:or a:call z,mess
      END
; Enchaine
hook_setup
          push de
; Init hook.
; Note: duration shouldn't matter:
    ; for last node there is no next event after this duration. 
; Yet we set it up:
   ; - ensure same code path is used when inserting a new hook
   ; - less perturbing than garbage when debugging
   ; - more thorough hook construction check in tracknrt
      IF evt0_dur
 !! review this
      END
          idsz ** inc de
last_duration = &DDDD   ; "grepable" 
          ld a,last_duration AND &FF
          ld (de),a:inc de
      IF last_duration/&0100 - [last_duration AND &FF]
          ld a,last_duration/&0100
      END
          ld (de),a

; -- Init link event to NULL. For now it's just the hook.
      IF evt0_link - 2
 !! review this
      END
          xor a
          inc de:ld (de),a
          inc de:ld (de),a
          pop de
          ret


          SIGN(1,1,FLAG_Z)
ext_next_node
;------------  ; Same routines
ext_connect_head
;---------------
; In: DE = pnt node 
; Out: If has next: NZ, DE = pnt next node (connected)
     ; Otherwise (end or loop), Z, DE inchanged     
; Note: generic routine in liszt, this is just to have signature
      ; and additional checks                            

          call connect_bk_track ; at least needed for head
          ex de,hl
          call Next_node ; hl=(hl) with checks
; Force C to 0:
  ; - Mark "regular pointer" (not really enforced in v0g)
  ; - Less perturbing than random value when debugging.
          ld c,0
          ex de,hl
          ret z
      IF dev_checks
          push af
; Bank musn't have changed
          call get_bk_connected
          cp BK_TRACK:call nz,mess
          pop af
      END
          ret

          SIGN(1,0,NO_FLAGS)
ext_fetch_event
;In: DE = pnt node (connected)
          ld a,(aum_regs + reg_event*4)
          ex de,hl
          call goto_event
          ret z

          ld (fetched_event),hl
          ld hl,aum_regs + t0*4
          ld de,fetched_t0
          3 ** ldi
          reg_pad*[t1-t0] - 3 ** inc hl
          3 ** ldi
          ret

      IF 0
          SIGN(1,1,FLAG_Z)
ext_get_track
;------------
;In: CDE = track#  (well, just E)
          ld a,c:or d:call nz,mess
;Out: If invalid #, Z
    ; Otherwise, NZ, CDE = track
;Valid if e+1 <= used_tracks 
          ld a,(used_tracks)
          inc e:cp e:jr c,.outofbond
          dec e
          ld a,e:call get_track_header
          ex de,hl
          or d          ; force NZ
          call z,mess   ; check NZ
          ret
.outofbond
          cp a          ; Z
          ret
      END

time_zero TIME(0)
time_inf FILL 3,&FF

;--------------------------
; Buffers and tmp variables     
;--------------------------
 ;         ALIGN(&20)    ; align for easier debug

;for phrasui
          ASSERT($ AND &C000 != &4000) ; out of bank for sharing
fetched_t0 TIME(0)
fetched_t1 TIME(0)
          ASSERT(fetched_t1 == fetched_t0+3)

fetched_event WORD 0
timestamp TIME(0)
previous_timestamp TIME(0)
time_param TIME(0)

;-----------------
; AUM Variables     
;-----------------
frame_pnt WORD          ; point 
aum_af WORD             ; A: Unused, but makes F easier to store
aum_sp WORD 
aum_pc WORD             ; for debug
aum_stack FILL MAX_FRAMES*2,0 ; only AUM'S PC saved.
aum_stack_
          CHECK_CONFINE(aum_stack)

; Since we manipulate all values by reference,
; we must store literals.
; The alternative would be a static array of litterals.
  ; -> Faster but requires &80 bytes.
          ALIGN(4)
tmp_lit FILL 4,0:CHECK_CONFINE(tmp_lit)
tmp_arg = tmp_lit
tmp_binary FILL 4,0:CHECK_CONFINE(tmp_binary)
tmp_ext_args FILL MAX_EXT_PARAMETERS * 2,0:CHECK_CONFINE(tmp_ext_args)

          ALIGN(&0100)
aum_regs
;4 * (32 regs * 4)
      FILL MAX_FRAMES * FRAME_REGS_SIZE,0 ; fill for easier debugs
aum_regs_


track_end

