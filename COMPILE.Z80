dev_checks = 1
hack_minimala = 1       ; actually hack kim!
todo  = 1
; Compile: Adapt data, flatten event list, inline tables, etc

; 2025  
; ----- v0l2 ------
 ; Mar
  ; 21 Encode song loop
  ; 20 Fix empty row handling: was replaced by instr_null 
           ; (since unconditional reading of instr)
           ; Now: replaced by /no_instr_escape_code/, 
                ; ply doing nothing in that case.
    ; Fix looping: must add evt_change_phrase explicitly
  ; 17
   ; Fix IF guards
   ; Track starts at 1
   ; Fix bk connection at /defend/ (was corrupting bk base)
   ; Fix comp_default (only pitch+noise)

; 2024  
; ----- v0l ------
  ; Jun    
    ;20 is_last_row now returns Z instead of NZ.
; ----- v0i ------
    ; 8 Add comp_chip_down_vib_noise  |
          ; comp_chip_down_arp        | for 4k08.chp

; ----- v0j ------    
  ; May                  
    ; 16 Fix copy/paste error: use chip_row_size' for noise+arp instr
       ; Hack: skip pattern &27
    ; 15 Hack: turn 01+ff duration (&100) into one single row
                 ; since we don't handle dummy/empty row for minimanal
                 ; (each row resets instruments, and we don't want
                 ; to reset or cut instrument at +&101)
             ; See journal.o at that date to see why alternative was
             ; discarded.
; ----- v0h ------    
    ; 14 Reprise. Fix /compiled_instr_chip_down_vib/ address
                ; tracks: must connect bk phrase!
  ; Apr               
    ; 29 Support instr_chip_down_arp_noise
       ; row_lp: fix end of chunk pre-detection
    ; 26 Various fix (instr: bufferization)
    ; 24 Fix
         ; Remove old code from chung vu (too much has changed anyway) 
    ; 23 v1 Rewrite Belo Horizonte!
  ; ???  v0 extracted from chung vu

      IMPORT "memmap.i" ; for instr_head_rows and co
      IMPORT "const.i"
; For compiler_player adr and co.
; Note: we don't use flags (use_*...) here, they are setup for the tool.
      ; Instead, we use dynamic flag (_use_note_flag etc), meant to be
      ; set up after analysis.
      IMPORT "plyconf.i"

      IMPORT "ply.o"
      IMPORT "track.o"
      IMPORT "phrase.o"
      IMPORT "chung.o"
      IMPORT "instr.o"  ; Note: version non compiled
      IMPORT "chunk.o"  ; Next_node
      IMPORT "memcpc.o" ; for connect_bk_io

;      IF ayane:ELSE
;!!! ayane must be = 1, to detect proper instruments
;      END

;=========================================

;Hack: we report here the LSB of routines for instr.o compiled with 
     ; ayane = 0 

compiled_instr_null = compiled_player + 0
      IF hack_minimala
;compiled_instr_default = compiled_player + 0 ; Not used for minimal
compiled_instr_default = compiled_player + &04 ; used for kim
      ELSE
      END
      IF 0
;minimala
compiled_instr_chip_down_vib = compiled_player + 4
compiled_instr_chip_down_arp_noise = compiled_player + &4D
      ELSE
;4k08
;compiled_instr_chip_down_vib = compiled_player + 4
;compiled_instr_chip_down_arp = compiled_player + &4D
;compiled_instr_chip_down_vib_noise = compiled_player + &95
compiled_instr_chip_down_vib = compiled_player + &36
compiled_instr_chip_down_arp = compiled_player + &52
      END

dest  = compiled_data

connect_bk_compile = connect_bk_io
error_confine = &BE00
      IF todo
;!! When not set, raise ambiguous label. Shouldn't it meant to be
;  &be00 everywhere? 
      END
to_be_implemented = &BE00

;------------------------------------------
      MACRO CHECK_DEST
      IF dev_checks
          call _check_dest
      END
      ENDM

;------------------------------------------

compile
;------             
;In: N/A
;Out: de=start (connected)
    ; hl=size
          ld de,dest+9  ; Leave room song list

instruments
;..........
          call connect_bk_compile

; Must add instr 0 = instr_null.
; Since ply inconditionaly jump to one instrument
          ld hl,instr_map
          ld (hl),e:inc h
          ld (hl),d
; Type, no params
          ld a,compiled_instr_null AND &FF
          ld (de),a:inc de

          ld hl,instr_map+1 ; l = instr #    
; We iterate on all possible instruments, as they are not contiguous 
instr_lp
; Store instrument pnt in compiled file
; (note: done even for empty instrument, to free HL)
          push hl
          ld (hl),e:inc h
          ld (hl),d

          ld a,l
          call Song_select_instr ; connect bk base
          jp z,instr_next

          call get_instr_pnt
          CHECK_DEST()

          ld a,(hl):inc hl
; instr_null not used in ayane module itself
;          cp instr_null AND &FF:jr z,comp_null
          cp instr_null AND &FF:call z,mess
          cp instr_default AND &FF
          jr z,comp_default
      IF use_instr_chip_down_vib
          cp instr_chip_down_vib AND &FF
          jp z,comp_chip_down_vib
      END
      IF use_instr_chip_down_vib_noise
          cp instr_chip_down_vib_noise AND &FF
          jp z,comp_chip_down_vib_noise
      END
      IF use_instr_chip_down_arp
          cp instr_chip_down_arp AND &FF
          jp z,comp_chip_down_arp
      END
      IF use_instr_chip_down_arp_noise
          cp instr_chip_down_arp_noise AND &FF
          jp z,comp_chip_down_arp_noise
      END
      BRK               ; unexpected

comp_default
          call poke_init
          ld a,compiled_instr_default AND &FF
          call poke_a
          call poke_flush
          ld de,(dest_pnt)
          call instr_get_loop
          xor a
.deflp
;de=dest (not buffer) for loop handling.
          call connect_bk_instr
          call is_last_row:jp z,.defend
          call Next_node:call z,mess

          push af
          push bc       ; save row
          push hl
          cp b
          jr nz,.loop_not_reached
          ld (loop_pnt),de
.loop_not_reached
          ld (last_row),de

          idsz ** inc hl ; skip link
;-pre check before deconnecting instr
          ld a,(_use_instr_arp):or a:jr z,.pre_noarp
; arp must be premultiplied by two
          ld a,(hl):rrca:call c,mess
          jr .pre_okarp
.pre_noarp
          ld a,(hl):or a:call nz,mess
.pre_okarp
          push de
          ld de,buffer
          push de
          ld bc,instr_row_size_max
          ldir
          call connect_bk_compile
          pop hl
          pop de
;link 
          inc de        ; room for link (set below)
; - arpegio

      IF instr_arp
 !! review that (expect arp column at 0)
      END
          ld a,(_use_instr_arp)
          or a:jr z,.no_instr_arp
          ldi
          jr .ok_instr_arp
.no_instr_arp
; We pretend there is no arp. Check that (and skip field)
          ld a,(hl):or a:call nz,mess
          inc hl
.ok_instr_arp

; - pitch   
      IF instr_pitch - 1
 !! review that  ; (expect pitch column at 1)
      END
          ld a,(_use_instr_pitch)
          or a:jr z,.no_instr_pitch
          ldi
          ldi
          jr .ok_instr_pitch

.no_instr_pitch
; Check it's null (and skip field)
; assume no pitch
          ld a,(hl):inc hl
          or (hl):inc hl:call nz,fail
.ok_instr_pitch

; - r7 flags 
; For now copy flags
      IF instr_flags - 3
 !! review that ; (expect flag column at 3)
      END
          ld a,(_use_flags)
          or a:jr z,.no_instr_flags
          ldi
          jr .ok_instr_flags

.no_instr_flags
          inc hl
.ok_instr_flags

; - noise
      IF instr_noise - 4
 !! review that  ; (expect noise column at 4)
      END
          ld a,(_use_noise)
          or a:jr z,.no_instr_noise
          ldi
          jr .ok_instr_noise

.no_instr_noise
          ld a,(hl):or a:call nz,mess ; there is noise!
          inc hl
.ok_instr_noise

; - vol
      IF instr_vol - 5
  !! review that  ; (expect vol column at 5)
      END
          ld a,(_use_hard_env):or a:jr z,.no_hard_env_vol
          call to_be_implemented
.no_hard_env_vol
; If no hard env, no need for flag. Put volume as is
          ld a,(hl):inc hl
          rrca:call c,mess ; NC: regular volume
          ld (de),a:inc de

      IF use_hard_env AND 0 ; deactivated for chp
!! review
; Must use instr_hard_arp BYTE     ; for hard env period
         ; instr_hard_pitch
; - hperiod
      IF instr_hperiod - 6 ; instr_
   !! review that
      END
          ld a,(_use_hard_env):or a:jr z,.no_hard_env
          call to_be_implemented
.no_hard_env
      END

; Link to next row (check &100 confined)
          ld hl,(last_row)
          ld a,h:cp d:call nz,error_confine ; Expect instr fit in &100
          ld a,e:sub l:ld (hl),a ; relative link

          pop hl
          pop bc
          pop af
          inc a
          jp .deflp

.defend
          call connect_bk_compile
          ld hl,(last_row)
          ld a,(loop_pnt)
          sub l:ld (hl),a
          jp instr_next

      IF use_instr_chip_down_vib
comp_chip_down_vib
          ld a,compiled_instr_chip_down_vib AND &FF
          ld b,2
          call setup_comp_chip_down
          jr com_chip_vib
      END

      IF use_instr_chip_down_vib_noise
comp_chip_down_vib_noise
;.......................
          ld a,compiled_instr_chip_down_vib_noise AND &FF
          call setup_comp_chip_down_3
      END
      IF use_instr_chip_down_vib OR use_instr_chip_down_vib_noise
com_chip_vib
      IF instr_head_rows - 1
 !! review! rows were expected after type
      END
          xor a
.cdvlp
;de= dest (not buffer), for detection
          call connect_bk_instr
          call is_last_row:jr z,.cdvend
          call Next_node:call z,mess

          push af
          push bc       ; save b=row
          push hl
          cp b
          jr nz,.loop_not_reached
          ld (loop_pnt),de
.loop_not_reached
          ld (last_row),de

          idsz ** inc hl ; skip link
chip_row_size = 2
          push de
          ld de,buffer
          ld bc,chip_row_size
          push de
          ldir
          call connect_bk_compile
          pop hl
          pop de
          ld a,chip_row_size+1
          ld (de),a
          inc de
;Just copy pitch
          chip_row_size ** ldi
          ld hl,(last_row)
          ld a,h:cp d:call nz,error_confine ; expect instr fit in &100

          pop hl
          pop bc
          pop af
          inc a
          jr .cdvlp
.cdvend
          call connect_bk_compile
          ld hl,(last_row)
          ld a,(loop_pnt)
          sub l:ld (hl),a
          jp instr_next
      END


      IF use_instr_chip_down_arp
comp_chip_down_arp
          ld a,compiled_instr_chip_down_arp AND &FF
          ld b,2
          call setup_comp_chip_down
          jr com_chip_arp
      END

      IF use_instr_chip_down_arp_noise
comp_chip_down_arp_noise
;.......................
          ld a,compiled_instr_chip_down_arp_noise AND &FF
          call setup_comp_chip_down_3
      IF need_room
; Factorize table setup.
; Here arp field (1 byte)
      END
      END

      IF use_instr_chip_down_arp OR use_instr_chip_down_arp_noise
com_chip_arp
          xor a
.cdanlp
;de= dest (not buffer), for detection row loop
          call connect_bk_instr
          call is_last_row:jr z,_chip_finalize_table
          call Next_node:call z,mess

          push af
          push bc       ; save b=row
          push hl
          cp b
          jr nz,.loop_not_reached
          ld (loop_pnt),de
.loop_not_reached
          ld (last_row),de

          idsz ** inc hl ; skip link
          ld c,(hl):inc hl
          call connect_bk_compile
chip_row_size' = 1
          ld a,chip_row_size'+1
          ld (de),a:inc de
;Just copy arp (noise constant set with instr)
          ld a,c
          ld (de),a:inc de
          ld hl,(last_row)
          ld a,h:cp d:call nz,error_confine ; expect instr fit in &100

          pop hl
          pop bc
          pop af
          inc a
          jr .cdanlp
      END

_chip_finalize_table
          call connect_bk_compile
          ld hl,(last_row)
          ld a,(loop_pnt)
          sub l:ld (hl),a
;enchaine
instr_next
          pop hl
          inc l
          jp nz,instr_lp

      IF hack_minimala
; For minimala: assume instr fit in &100
          ld a,d:cp dest/&0100:call nz,mess
      END

phrases
;......
; Same principle: iter all phrases, skip non-existing ones
; We iterate on all possible instruments, as they are not contiguous 
          ld hl,phrases_map ; L = phrase #
phrases_lp
      IF dev_checks
;Dest still in bank
          ld a,d:cp &40:call c,mess
          cp &80:call nc,mess
      END
          push hl
; Store instrument pnt in compiled file
; (note: done even for empty instrument, to free HL)
          ld (hl),e:inc h
          ld (hl),d

          ld a,l
      IF hack_minimala
; skip empty residual pattern
; otherwise, a phrase with no row is created,
; poke_flush issues 256 bytes.
      IF todo
 ; !! solve this bug instead
      END
          cp &27:jp z,phrases_next
      END
      ;    cp &1C:call nc,&BE00
          call song_select_phrase
          jp z,phrases_next

          call poke_init
          call connect_phrase_begin
.row_lp
      IF dev_checks
; Check pnt 
          ld a,h:cp &40:call c,mess
          cp phrases_/&0100:call nc,mess
      END

          ld c,(hl):inc hl ; duration
          ld b,(hl)     ; flags

; -- Phrase flag
      IF todo
;!!! a bit brittle.
; To accelerate a bit, we assume encoding of 'set phrase' pseudo-fx.
      END
          bit bit_fx0,b:jr z,.okrow
; End of phrase or link to next chunk 
          dec hl        ; rewind    
          call is_end_of_phrase
          jr z,.row_end
          call follow_link_if_eoc
          jr .row_lp

.okrow
          inc hl
          ld a,c
      IF hack_minimala
; Replace duration 1 + &ff by 0. More precisily:
; &01, note  -> 0, note
; &ff, empty -> skip it
          cp 1:jr nz,$+3:xor a
          cp &FF:jr nz,.okhack
; Check it's indeed empty row
          bit bit_instr,b:call nz,mess
          jr .ok_note
.okhack
      END
          call poke_a

; Must we copy flags byte itself?
; Yes if any of fx, instr, note, phrase flag is non-constant
          push hl
          ld hl,_nb_fx
          ld a,(hl):inc hl
          or (hl):inc hl
          or (hl):inc hl
          or (hl)
          pop hl
          ld a,b
          call nz,poke_a

; -- FX
          ld a,(_nb_fx):or a:jr z,.no_fx
          call to_be_implemented
.no_fx
; No fx used. We verify that
          ld a,b
          and mask_fx0 AND mask_fx1 AND mask_fx2 AND mask_fx3
          call nz,mess

; -- Instr
          ld a,(_use_instr_flag):or a:jr z,.no_instr_flag
          call to_be_implemented
.no_instr_flag
      IF hack_minimala
; Flag always set. Expect for:
  ; - empty intermediate row (skipped above for minimala)
  ; - empty phrase (actually contains one empty row)
          bit bit_instr,b:jr nz,.putinstr
; Empty row: neither instr nor note.
   ; - check that
          ld a,b:or a:call nz,mess
no_instr_escape_code = compiled_instr_null ; handled by ply
      IF compiled_data AND &FF
!! we rely on fact that at xx00, there is track list
 ; (so 0 cannot be the LSB of a real instr)
      END
          xor a
          call poke_a
;Do not poke note in that case
          jr .ok_note
      ELSE
; Flag always set. We verify that
          bit bit_instr,b:call z,mess
      END
.putinstr
          push hl
          ld l,(hl)
          ld h,instr_map / &0100
      IF hack_minimala
      IF dev_checks
; All instr in first &100, so only need for LSB
          inc h:ld a,(hl):dec h
          cp dest / &0100:call nz,mess
      END
          ld a,(hl)
          call poke_a
      ELSE
 !! todo. Dynamic flag "_are_instr_confined"
      END
          pop hl
          inc hl

; -- Note
          ld a,(_use_note_flag):or a:jr z,.no_note_flag
          call to_be_implemented
.no_note_flag
; Flag always set. We verify that
          bit bit_note,b:call z,mess
          call poke_ldi

.ok_note
; Skip reserved byte
          reserved_byte ** inc l
          jp .row_lp

.row_end
; -- marker loop (none for no)
          ld a,(_has_phrase_loop)
          or a:jr z,.okloop
          call to_be_implemented
.okloop
          call poke_flush
          ld de,(dest_pnt)

phrases_next
          pop hl
          inc l
          jp nz,phrases_lp

tracks
;.....           
          ld hl,dest    ; songlist
          ld a,1        ; track start at 1
track_lp
      IF dev_checks
;Dest still in bank
          push af
          ld a,d:cp &40:call c,mess
          cp &80:call nc,mess
          pop af
      END
          push hl
          call connect_bk_compile
          ld (hl),e:inc hl
          ld (hl),d:inc hl
          ld (hl),a:inc hl
          push af
          call get_track_header
          call poke_init
          call connect_bk_track
          call Next_node ; From header to head of list of hooks
;Flatten all events 
.hooklp
          push hl
          idsz ** inc hl
          2 ** call poke_ldi ; duration
; Now follow list of event 
          call Next_node
; Might be empty (intermediate hook)
; For now, not suported
          call z,to_be_implemented
      IF hack_minimala
; For now, rely on the fact there is always transpose following by
; phrase (aka "static")
  ; -> No need for indirection (would take space)
  ; -> We could still leverage phrase looping (if same transpose)
          push hl
          idsz ** inc hl
          ld a,(hl)
          cp evt_set_transpose AND &FF:call nz,mess
          inc hl
          call poke_ldi
          pop hl
          call Next_node
;Must be last event (link=0)
          ld a,(hl):inc hl
          or (hl):call nz,mess
          inc hl
          ld a,(hl):inc hl
          cp evt_change_phrase AND &FF:call nz,mess
          call Next_node ; phrase start in chunk
          call connect_bk_phrase
          ld l,chunk_start+fc_index
          ld l,(hl)
; We poke full address rather than id:
   ; - no indirection
   ; - *might* compress as well (ref needed!)
          ld h,phrases_map/&0100
          ld a,(hl):call poke_a
          inc h
          ld a,(hl):call poke_a
      ELSE
.evtlp
;tmp dbg
          ld a,(&4525):cp &4A:call nz,&BE00
          push hl
          idsz ** inc hl
          ld a,(hl)
          cp evt_set_transpose:jr z,.set_transpose
          cp evt_change_phrase:jr z,.set_phrase
 !!!todo
      END

          pop hl
          call connect_bk_track
          call Next_node
          jr nz,.hooklp

          call poke_flush
          ld de,(dest_pnt)
; Encode loop via fake event
          pop af
          pop hl        ;songlist
          push af
          call connect_bk_compile
          xor a
      3 ** [ld (de),a:inc de] ; no duration, no transpose
; Link with bit 15 set: track reset instead of phrase link
          ldi
          ld a,(hl):inc hl
          set 7,a
          ld (de),a:inc de
          inc hl        ; skip output in songlist
          pop af
          inc a
          cp 4
          jp c,track_lp

;Return de=start (connected), hl=size
          ex de,hl      ; hl = current pnt
          ld de,dest
          or a:sbc hl,de
          call connect_bk_io
          ret
; FINITO!!!

; ---------- Helpers -----------------------------------

setup_comp_chip_down_3
          ld b,3        ; vol step, initial vol, noise
;enchaine
setup_comp_chip_down
; In: a = type (= LSB routine)
    ; b = nb params to copy
    ; de= dest
    ; hl= pnt in rows field in head instr
;Out: de= dest (advanced)
    ;  b= loop row # 
    ; hl preserved

          call poke_init
          call poke_a
; ext params, before table
          push hl
      IF instr_head_rows - 1
 !! review that. Rows were expected after type
      END
          instr_head_ext - instr_head_rows ** inc hl
.copy     call poke_ldi:djnz .copy
          call poke_flush
          ld de,(dest_pnt)
          call instr_get_loop
          pop hl
          ret

poke_init
;--------
;For trans-bk bufferization
      IF dev_checks
; Cannot be buffer itself! 
; it must be the real destination
          push af
          ld a,d:cp buffer/&0100:call z,mess
          pop af
          CHECK_DEST()
      END
          ld (dest_pnt),de
          ld de,buffer
          ret

poke_ldi
; LDI-like, without dec bc
          ld a,(hl):inc hl
;enchaine
poke_a
      IF dev_checks
          push af
; We only have to test bk if poking directly in dest
          ld a,d:cp buffer/&0100:jr z,.ok
          CHECK_DEST()
          call get_bk_connected
          cp BK_IO:call nz,mess
.ok
          pop af
      END
          ld (de),a
          inc e
          ret nz
;enchaine
poke_flush
          push af:push bc:push hl
          call get_bk_connected
          push af
          call connect_bk_io
          ld c,e:ld b,0:dec c:inc bc ; bc=size
          ld hl,buffer
dest_pnt = $+1
          ld de,&C000
          ldir
          ld (dest_pnt),de
          pop af
          call connect_a
          pop hl:pop bc:pop af
          ld de,buffer
          ret

      IF dev_checks
_check_dest
          push af
          ld a,d
          cp buffer/&0100:jr z,.ok
          cp dest/&0100:call c,mess
          cp dest/&0100+8:call nc,mess ; limit for chp (minimala:&468)
.ok
          pop af
          ret

          push af
          call get_bk_connected
          cp BK_IO:call nz,mess
          pop af
          ret
      END

      FILL -$ AND &FF,0
buffer FILL 256,0
instr_map FILL 512,0
phrases_map FILL 512,0

; ----- Tmp variables ----
var
loop_pnt WORD 
last_row WORD 

; ----- Flags for compilation -----
      IF todo
; Set them after analysis phase
      END
;--instr
_use_instr_arp BYTE 0
_use_instr_pitch BYTE 1
_use_flags BYTE 0       ; 0: Infer from noise value
_use_noise BYTE 1       ; 1 for kim
_use_hard_env BYTE 0
;--phrase
_nb_fx BYTE 0
_use_instr_flag BYTE 0  ; Flag not needed when always instr in row
_use_note_flag BYTE 0   ; Flag not needed when always note in row
_has_phrase_loop BYTE 0 ; 0: no loop, phrase changed on time 

      IF _use_instr_flag - _nb_fx - 1
 !! must be contiguous
      END
      IF _use_note_flag - _use_instr_flag - 1
 !! must be contiguous
      END
      IF _has_phrase_loop - _use_note_flag - 1
 !! must be contiguous
      END


