; ---- Tests for phrase.o ----

; 2025
; -- alpha1 --
; Dec 
  ; 15: Add test_phrase_set_blank_crosschunk
      ; Add call test_clone_phrase
  ; 14: Add test_phrase_get_row_crosschunk
  ; 12: Add test_phrase_get_last_row
; Nov
  ; 27: Add test_get_duration_10000
  ; 22: Add test_phrase_get_row_at'
  ; 19: Add test_phrase_select_row_at_past
  ; 18: Add test_phrase_get_row_at_inf
      ; Add test_unpack_row_at_inf
      ; Add test_phrase_select_row_far

  ; 16: Remove testlib dep

; -- v0.a? ---
; Oct
  ; 17: Add test_unpack_row_at

; -- v0.a? ---
; Aug  8: Use testlib for init
        ; Add test_phrase_get_rows#
; Jun 12: Just version

      ORG &0100
      ENT tests

 ;      IMPORT "testlib.o"  ; unnecessary deps
      IMPORT "phrase.o"
      IMPORT "memmap.i" ; for phrases_
      IMPORT "chunk.o"  ; for Init_chunk_module

fail  = &BE00

tests
          call test_phrase_get_rows#
          call test_phrase_get_row_at
          call test_phrase_get_row_at'
          call test_phrase_get_row_at_inf
          call test_phrase_get_row_crosschunk
          call test_phrase_set_blank_row_at
          call test_phrase_set_blank_row_at'
          call test_phrase_set_blank_crosschunk
          call test_phrase_select_row_at
          call test_phrase_select_row_at_insert
          call test_phrase_select_row_from_empty_phrase
          call test_phrase_select_row_far
          call test_phrase_select_row_at_past
          call test_phrase_get_last_row
          call test_get_duration_empty
          call test_get_duration_single
          call test_get_duration_16bits
          call test_get_duration_10000
          call test_intermediate_row
          call test_row_set
          call test_unpack_row_at
          call test_unpack_row_at'
          call test_unpack_row_at_inf
          call test_clone_phrase
          ret

nrt_init
          ld a,".":call &BB5A
          call Init_chunk_module
          call phrase_reset
          ret

test_phrase_get_rows#
;-------------------- 
          call nrt_init
          xor a:call song_select_new_phrase
          call phrase_get_rows#
          or a:call nz,fail
          xor a:call phrase_select_new_row
          call phrase_get_rows#
          cp 1:call nz,fail
          ret

test_phrase_get_row_at
;---------------------
; Check API
          call nrt_init
          xor a:call song_select_new_phrase

;No row
          ld de,0:call phrase_get_row_at
          call c,fail

          xor a:call phrase_select_new_row
;Blank row
          ld de,0:call phrase_get_row_at
          call nc,fail
          call nz,fail
          call check_blank_row
          ret

test_phrase_get_row_at'
;----------------------
; Same thing when first row duration <> 0 
; Also test phrase_get_rows#
          call nrt_init
          xor a:call song_select_new_phrase

          call phrase_get_rows#
          or a:call nz,fail

dur1  = 11
          ld a,dur1:call phrase_select_new_row

          call phrase_get_rows#
          cp 1:call nz,fail

          ld de,0:call phrase_get_row_at:call nc,fail
          call nz,fail
          ld a,(hl):cp dur1:call nz,fail
          ret

test_phrase_get_row_at_inf
;-------------------------
; When "infinite" phrase, row_t1 must be &ffff
; Same thing when first row duration <> 0 
; Also test phrase_get_rows#
          call nrt_init
          call dummy_phrase_inf
          ld de,nrt_delai:call phrase_get_row_at:call nc,fail
          call nz,fail
          ld hl,(row_t1)
          ld a,l:cp &FF:call nz,fail
          ld a,h:cp &FF:call nz,fail
          ret

test_phrase_get_row_crosschunk
;-----------------------------      
; Must follow link eoc and point on a concrete row
          call nrt_init
          call dummy_phrase
; point first row of second chunk (a bit brittle, nevermind)
; a more complete test is done later view check_phrase
          ld de,60*nrt_delai
          call phrase_get_row_at:call nc,fail
          call nz,fail
          ld a,(hl):cp nrt_delai:call nz,fail
          ret

test_phrase_set_blank_row_at
;---------------------------         
; Check API (and that no new phrase is created)
; Prerequiste: test_phrase_get_row_at
          call nrt_init
          xor a:call song_select_new_phrase
          ld de,0:call phrase_set_blank_row_at
          push hl
          call check_blank_row
          ld de,0:call phrase_set_blank_row_at
; Check same pointer is returned
          pop de
          or a:sbc hl,de:add hl,de
          call check_blank_row
          ret

test_phrase_set_blank_row_at'
;----------------------------
; Same, but at time > 0
          call nrt_init
          xor a:call song_select_new_phrase
          ld de,nrt_delai:call phrase_set_blank_row_at
          push hl
          call check_blank_row ; inserted row
          call .check_row ; padding row
          ld de,nrt_delai:call phrase_set_blank_row_at
; Check same pointer is returned
          pop de
          or a:sbc hl,de:add hl,de
          call check_blank_row
          call .check_row
          ret

.check_row
; Check empty row with delai 6
          ld de,0:call phrase_get_row_at:call nc,fail
          call nz,fail
          ld a,(hl):cp nrt_delai:call nz,fail
          inc l
          ld a,(hl):or a:call nz,fail ; flags = 0
          ret

test_phrase_set_blank_crosschunk
;-------------------------------      
; Must follow link eoc and point on a concrete row
          call nrt_init
.rows# = 200
          ld b,.rows#
          call dummy_phrase_custom
          ld b,.rows#
          call check_phrase
          ld de,nrt_delai*80+1:call phrase_set_blank_row_at
          ld de,nrt_delai*80
          call phrase_select_row_at
          call row_get_note:cp 80:call nz,fail
          ld de,nrt_delai*81
          call phrase_select_row_at
          call row_get_note:cp 81:call nz,fail

          ld de,nrt_delai*140+1:call phrase_set_blank_row_at
          ld de,nrt_delai*140
          call phrase_select_row_at
          call row_get_note:cp 140:call nz,fail
          ld de,nrt_delai*141
          call phrase_select_row_at
          call row_get_note:cp 141:call nz,fail
          ret


test_phrase_select_row_at
;------------------------
; Just check no assertion triggered, and right row selected
          call nrt_init
          xor a:call song_select_new_phrase

          ld a,0:call phrase_select_new_row:call nc,fail
          ld a,note1:call row_set_note

;sanity check
          call row_get_note
          cp note1:call nz,fail

          ld de,0:call phrase_select_row_at
          call row_get_note
          cp note1:call nz,fail
          ret

test_phrase_select_row_at_insert
;-------------------------------
; Test insertion
          call nrt_init
          xor a:call song_select_new_phrase

          ld a,0:call phrase_select_new_row:call nc,fail
          ld a,note1:call row_set_note

          ld de,&10:call phrase_select_row_at
          ld a,note2:call row_set_note
          call row_get_note
          cp note2:call nz,fail

; Read back note 1 at 0
          ld de,0:call phrase_select_row_at
          call row_get_note
          cp note1:call nz,fail

; Insert note3 in between
          ld de,&08:call phrase_select_row_at
          ld a,note3:call row_set_note

; Read back note 1 at 0
          ld de,0:call phrase_select_row_at
          call row_get_note
          cp note1:call nz,fail

; Read back note 3 at 8
          ld de,8:call phrase_select_row_at
          call row_get_note
          cp note3:call nz,fail

; Read back note 2 at &10
          ld de,&10:call phrase_select_row_at
          call row_get_note
          cp note2:call nz,fail
          ret

test_phrase_select_row_from_empty_phrase
;---------------------------------------
;This one doesn't append an empty phrase (phrase_select_new_row)
;prerequisite: test_phrase_set_blank_row_at'
          call nrt_init
          xor a:call song_select_new_phrase

          ld de,nrt_delai:call phrase_select_row_at
          ld a,note1:call row_set_note
          ld de,nrt_delai:call phrase_get_row_at:call nc,fail
          call nz,fail
          call row_get_note:cp note1:call nz,&BE00
          ret

test_phrase_select_row_far
;-------------------------
; Prerequisite : test_phrase_select_row_from_empty_phrase
          call nrt_init
          xor a:call song_select_new_phrase

          ld de,&0100:call phrase_select_row_at
          ld a,note1:call row_set_note
          ld de,&0100:call phrase_get_row_at:call nc,fail
          call nz,fail
          call row_get_note:cp note1:call nz,&BE00
          ret

test_phrase_select_row_at_past
;-----------------------------
; Time > total duration

          call nrt_init
          xor a:call song_select_new_phrase
;finite duration
          ld a,nrt_delai:call phrase_select_new_row:call nc,fail

          ld de,&0300:call phrase_select_row_at
          ld a,note2:call row_set_note
          ld de,&0300:call phrase_get_row_at:call nc,fail
          call nz,fail
          call row_get_note:cp note2:call nz,&BE00
          ret

test_phrase_get_last_row
;-----------------------
          call nrt_init
          xor a:call song_select_new_phrase
;finite duration
          ld a,11:call phrase_select_new_row:call nc,fail
          ld a,13:call phrase_select_new_row:call nc,fail ; at +11
          ld a,15:call phrase_select_new_row:call nc,fail ; at +11+13

          call phrase_get_last_row
          ld a,e:cp 11+13:call nz,fail
          ld a,d:or a:call nz,fail
          ret

check_blank_row
; Check row is valid and blank
; In: HL: row pnt.
          push hl
; -- check pnt is in proper phrase area
          ld a,h:cp &40:call c,fail
          cp phrases_/&0100:call nc,fail
; -- duration must be 0
          ld a,(hl):or a:call nz,fail
; -- flags must be 0
          inc hl
          ld a,(hl):or a:call nz,fail
          pop hl
          ret

test_get_duration_empty
;----------------------
; Just created phrase: must return zero

          call nrt_init
          xor a:call song_select_new_phrase
          call phrase_get_duration
          ld a,c:or e:or d:call nz,fail
          ret

test_get_duration_single
;-----------------------
; Just one row: must return duration of this row

          call nrt_init
          xor a:call song_select_new_phrase
          ld a,13:call phrase_select_new_row:call nc,fail
          call phrase_get_duration
          ld a,c:or d:call nz,fail
          ld a,e:cp 13:call nz,fail
          ret

test_get_duration_16bits
;-----------------------
; When ovf 8 bits, an intermediate row is created.
          call nrt_init
          xor a:call song_select_new_phrase
          ld a,127:call phrase_select_new_row:call nc,fail
          ld a,255:call row_add_duration
          call phrase_get_duration
          ld a,c:or a:call nz,fail
          ld a,d:cp 1:call nz,fail
          ld a,e:cp 126:call nz,fail
          ret

test_get_duration_10000
;--------------------
; duration 0 interpreted as 10000
          call nrt_init
          call dummy_phrase_inf
          call phrase_get_duration
; &10000 + nrt_delai
          ld a,c:cp 1:call nz,fail
          ld a,d:cp 0:call nz,fail
          ld a,e:cp nrt_delai:call nz,fail
          ret

test_intermediate_row
;--------------------
; The intermediate row for duration >= &100 must be inserted AFTER.
; Prerequisite: test_get_duration_16bits, test_phrase_select_row_at
          call nrt_init
          xor a:call song_select_new_phrase
          ld a,&80:call phrase_select_new_row:call nc,fail
note1 = &14
note2 = &16
note3 = &18
          ld a,note1:call row_set_note
;sanity check
          call row_get_note
          cp note1:call nz,fail

          ld a,&80:call row_add_duration

;Real check: selected row still carries the note
          call row_get_note
          cp note1:call nz,fail

;Sanity: first row was the one selected
          ld de,0:call phrase_select_row_at
          call row_get_note
          cp note1:call nz,fail
          ret

test_row_set
;-----------
; Test setting note, vol, instr
;1/with non-zero duration
          ld a,&80:call check_row_set
;2/with zero initial duration
          xor a:call check_row_set
          ret

check_row_set
          push af
          call nrt_init
          xor a:call song_select_new_phrase
          pop af
          call phrase_select_new_row:call nc,fail
; --- sanity: only 1 row
          call phrase_get_rows#:cp 1:call nz,fail
; -- Additional duration
          ld a,42
          call row_add_duration
          call phrase_get_rows#:cp 1:call nz,fail
; --- With fx
 ;  TODO
; --- With note
          ld a,43
          call row_set_note
          call row_get_note:cp 43:call nz,fail
          call phrase_get_rows#:cp 1:call nz,fail
; --- With vol            
          ld a,&0E
          call row_set_vol
          call row_get_vol:cp &0E:call nz,fail
          call phrase_get_rows#:cp 1:call nz,fail
; --- With instr
; (instr isn't defined: that shouldn't matter)
          ld a,1
          call row_set_instr
          call row_get_instr:cp 1:call nz,fail
          call phrase_get_rows#:cp 1:call nz,fail
; -- Other fields still ok?
          call row_get_vol:cp &0E:call nz,fail
          call row_get_note:cp 43:call nz,fail
          ret


test_unpack_row_at
          call nrt_init
          call dummy_phrase

          ld b,nrt_rows#
          push bc

          ld hl,0       ; time
          ld de,nrt_buf
          call unpack_row_at
          call nc,fail
          call z,fail
          ld ix,0       ; time
          jr .entry
.lp
          push bc
          ld de,nrt_buf
          call unpack_next_row
          call nc,fail
          call z,fail
.entry
;check de was preserved
          ld a,e:cp nrt_buf AND &FF:call nz,fail
          ld a,d:cp nrt_buf / &0100:call nz,fail
;check hl was preserved
          ld a,l:cp ixl:call nz,fail
          ld a,h:cp ixh:call nz,fail
;next row time
          ld de,nrt_delai:add ix,de
          add hl,de
;check "row next time"
          ld a,c:cp ixl:call nz,fail
          ld a,b:cp ixh:call nz,fail
;check unpacked
          pop bc
          ld a,nrt_rows#:sub b
          push hl
          ld hl,nrt_buf
          cp (hl):call nz,fail ; note
          inc l
          ld a,(hl):cp &FF:call nz,fail ; instr not set
          inc l
          ld a,(hl):cp &FF:call nz,fail ; vol not set
          pop hl
          djnz .lp

;no more row
          ld de,nrt_buf ; sanity
          call unpack_next_row:call c,fail
          ret

test_unpack_row_at'
; phrase with instr and vol
; mainly check it doesn't assert
          call nrt_init
          xor a:call song_select_new_phrase

          ld a,0:call phrase_select_new_row:call nc,fail
          ld a,note1:call row_set_note
          ld a,1:call row_set_instr
          ld de,nrt_delai:call phrase_select_row_at
          ld a,note1+1:call row_set_note
          ld a,&0F:call row_set_vol
          ld de,nrt_delai*16+2:call phrase_select_row_at
          ld a,note2:call row_set_note

          ld b,3        ; 3 rows to test
          push bc

          ld hl,0       ; time
          ld de,nrt_buf
          call unpack_row_at
          call nc,fail
          call z,fail
          jr .entry
.lp
          push bc
          ld de,nrt_buf
          call unpack_next_row
          call nc,fail
          call z,fail
.entry
;check de was preserved
          ld a,e:cp nrt_buf AND &FF:call nz,fail
          ld a,d:cp nrt_buf / &0100:call nz,fail
          pop bc
          djnz .lp

;no more row
          ld de,nrt_buf ; sanity
          call unpack_next_row:call c,fail
          ret


test_unpack_row_at_inf
;---------------------
; These when "infinite duration" (last row with duration 0)
; Prerequisite: test_phrase_get_row_at_inf
          call nrt_init
          call dummy_phrase_inf

;existing row
          ld hl,nrt_delai ; time
          ld de,nrt_buf
          call unpack_row_at
          call nc,fail
          call z,fail   ; non empty
;bc=&ffff
          ld a,b:cp &FF:call nz,fail
          ld a,c:cp &FF:call nz,fail

;past last row (but not past phrase)
          ld hl,nrt_delai+1
          ld de,nrt_buf
          call unpack_row_at
          call nc,fail
          call nz,fail  ; empty
;bc=&ffff
          ld a,b:cp &FF:call nz,fail
          ld a,c:cp &FF:call nz,fail
          ret

test_clone_phrase
          ld b,3
          call .check_clone_phrase
          ld b,200      ; now spanning on several chunks
          call .check_clone_phrase
          ret

.check_clone_phrase
          push bc
          call nrt_init
          pop bc
          push bc
          call dummy_phrase_custom
          pop bc
          push bc
; Sanity check
          call check_phrase
          call phrase_clone
          cp 1:call nz,fail
          pop bc
          call check_phrase
          ret

dummy_phrase
; Create phrase spanning on several chunks
nrt_delai = 6
nrt_rows# = 100
          ld b,nrt_rows#
dummy_phrase_custom
          ld c,b
          xor a:call song_select_new_phrase
.lp
          push bc
          ld a,nrt_delai:call phrase_select_new_row:call nc,fail
          pop bc
          push bc
;note 0,1,2 ...
          ld a,c:sub b
          call row_set_note
          pop bc
          djnz .lp
          ret

dummy_phrase_inf
; Create phrase with "infinite" duration (last row duration = 0)
          xor a:call song_select_new_phrase
          xor a:call phrase_select_new_row
          ld de,nrt_delai:call phrase_select_row_at
; Sanity check         
          ld de,nrt_delai:call phrase_get_row_at:call nc,fail
          call nz,fail
; expected duration = 0
          ld a,(hl):or a:call nz,fail
          ret

check_phrase
; Check phrase created by dummy_phrase
; IN: b: rows#      
          ld c,b
          ld de,0
.lp
          push de
          push bc
          call phrase_select_row_at
          pop bc
          ld a,c:sub b:ld e,a
          call row_get_note:call z,fail
          cp e:call nz,fail
          pop hl
          ld de,nrt_delai
          add hl,de
          ex de,hl
          djnz .lp
          ret



      SKIP -$ AND &FF
nrt_buf SKIP &0100

      SKIP ramlimit - $

