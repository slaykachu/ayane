todo  = 1
may_optim = 1
need_room = 1

; <<<<<< bouts de player, player debout. Not your ayerage player! >>>>>>

; Execution outline:
 ; ---- /track_loop/
   ; Check RDVs
 ; ---- /play_phrase/
   ; ---- /read_row/      
     ;  read_fx : read fx and install them  (generic)
     ;  read_ins: read ins and install it   (generic)
     ;  read_vol: (adr from code_stack.jps_channel1_)
     ;  read_note (enchaine)
   ; ---- /play_tick/

 ; See /track_stack/

; \/\/\/ 2026 \/\/\/\/\
; ----- Alpha1 -----
  ; Jan
   ;02 Amorce_song: must scope bk (when called from PHRASUI)
   ;01 read_vol: Must add track volume, since it will be sub in instr.o
               ; (track volume cannot be set right now, so the bug
                 ;didn't manifest)
; \/\/\/ 2025 \/\/\/\/\
; ----- v0au -----
  ; Nov
   ;10 fx_set_phrase: fix routine

; ----- v0at -----
   ; 5 Move get/set_diapasion in periods.o
  ; Oct
   ;28 Move Init_periods in periods.o
   ;16 Amorce_song: use channel info from subsong (moved from tracks)

; ----- v0as -----
   ;14 diapason on 16 bits

      IMPORT "plyconf.i"
      IF 1-ayane
      ORG compiled_player
      END

      IMPORT "const.i"
      IMPORT "memmap.i"
      IMPORT "macro.i"
      IMPORT "instr.o"
check_pc
      IMPORT "periods.o" ; skipped, just for c0/c1 labels
      IF check_pc - $
 !!! periods must be imported at the right location by instr.o
      END
      IF ayane
      IMPORT "assert.o"
      IMPORT "memcpc.o" ; scope_bk_base
      IMPORT "song.o"   ; Song_get_first_track and co
      IMPORT "tracknub.o" ; get_track_header
      ELSE
psg_regs = compiled_psg_regs
      END

; Note: the only dependency is fx_noFx 
; As other fx LSB are encoded directly in phrases (generic hooks)
; Anyway we need:
    ; - to know fx_code MSB
    ; - to put fx_set_phrase in same &100 area

      IF nb_fx
      IMPORT "timer.o"  ; Only for replay_period_in_nops
      IMPORT "fx.o"

ply_code
          jp Amorce_song
          jr play

fx_set_phrase
          ASSERT($ == fx_set_phrase_jp)
; Fake FX: update row pnt.
;  Needed for:
     ; - go to next chunk
     ; - auto-loop phrase 
     ; - /empty_phrase/

          pop de        ; param = phrase pnt
; -- clear fx to avoid infinite loop
          push de
          ld hl,fx_noFx:push hl
; -- restore BC = tick (to set up real nxt rdv)
; Rely on fact that pseudo row with this fake fx has duration=0
; so current tick was stored at /read_row/
          ld hl,track_rdv_row - track_fx:add hl,sp:ld sp,hl
          pop bc

          ex de,hl
          pop de        ; skip old pnt

; For now we know it's the same bank.
      IF phrases_across_banks
 !! review connection
      END
          SUB_TM(29+3)
          jp read_row

      IF fx_code/&0100 - fx_set_phrase/&0100
  !! confiment issue
 ; !!! That might be because fx.o was imported at a different
 ; !!! address by an earlier source
  ; Mitigation: always import ply.o rather than fx.o! 
      END
      END

 ; TODO optim? shortcut note2tone -> finalize
 ; TODO optim? place vibrato after note2tone, so that no tempory write
             ; is needed. 
             ; -> would imply to break fx/inst separation

 ; ----------------------------------------------
 ; Player use ALL registers except BC' DE' HL' I.

 ; Nb2: IX could be freed, en gerant les poke (vol&noise) en absolu,
      ; comme pour buf_periodCorr

 ;AF'= counter TM.
 ; HL' and AF' freed if no SFX interleaved 
 ; ---------------------------------------


r7    = psg_regs+7
      IF use_hard_env
r13   = psg_regs+13
      END
      IF sfx
r14   = psg_regs+14     ; start of virtual regs
      END


      MACRO SET_TRANSPOSE
; must preserve bc
          ld a,(de)     ; transpose signed
      IF ayane
set_transpose_tm = 10
      ELSE
set_transpose_tm = 12
          inc de        ; inlined events
      END
      IF dev_checks
 ; must be pre-doubled 
          SUB_TM''(5)
          bit 0,a:call nz,mess
      END

      IF may_optim
; use ix for such modif?  NO! Not be worth it
   ; - gain (5us vs 8us here) nullified by setup (add ix,sp)
   ; - IX no more available for more noble purposes
      END
          ld hl,track_transpose -4 ; -4: already 
          add hl,sp
          ld (hl),a
      ENDM


      MACRO CHANGE_PHRASE
; update track pnt for next time
          ld a,(de):inc de ; LSB or index
      IF ayane
change_phrase_tm = 14
          ld l,a
          ld a,(de)
          ld h,a
      ELSE

      IF sfx
change_phrase_tm = !! TODO
      END

      IF is_compiled_phrase_indexed
;Special case: since no link for track hooks, we use
;escape code 00 to flag track loop, as it cannot a valid LSB for phrase
          or a
          jr nz,.okphrase
          ld a,(de):inc de:ld l,a
          ld a,(de):ld h,a
          jr track_reset
.okphrase
; We expect index in first &100 segment
; This is enforce
          ld l,a
          ld h,compiled_data/&0100
          ld a,(hl):inc l
          ld h,(hl):ld l,a
      ELSE
          inc de
;Special case: since no link for track hooks, we reuse
; phrase link to flag track loop  
      IF compiled_data AND &8000
      IF compiled_data AND &C000 - &C000
          rlca:sra a    ; Bit 7 in carry and set in A
      ELSE
    !!! todo
      END
          ld h,a
          jr nc,track_reset
      ELSE
          rlca:srl a    ; Bit 7 in carry and cleared in A
          ld h,a
          jr c,track_reset
      END
      END
; compiled: update track pnt for next time
; (ayane: was done by link beforehand)
          push de
          pop de
      END

          pop de        ; skip row RDV
          pop de        ; skip current row pnt (since new one)
      ENDM


      MACRO UPDATE_INSTR flags_in_b,phrase_in_de
;Indirection. Rational from vAF:
 ;  Don't hardcode instr adr in phrase, but use its number
               ; - take less space
               ; - ease compile (hu?)
               ; - more future proof (ease changing instr while played)
                                     ; e.g. "alternate instr"

      IF is_instr_indexed
      IF phrase_in_de
  !! review this
      END
;Done preemptively, as we must do it before push
;Timer might be triggered a bit too soon, nevermind
      IF ayane AND sfx
update_instr_tm = 61
      ELSE
 !!! todo
      END
          EX_AF'()
          SUB_TM_CALL(update_instr_tm-1)
          EX_AF'()
          push hl       ; save phrase pnt
          ld l,(hl)     ; idx instru

      IF instr_head_size-8
 !! review this
      END
      IF instr_idx AND &07FF
 !! review this
      END
          ld h,instr_idx / &0800
          3 ** add hl,hl

      IF ayane
          ld a,b
          ld bc,&7F00+BK_INSTR:out (c),c
          ld b,a
      END

          ld a,(hl):inc hl
          ld (de),a:inc e ; LSB instr routine

          ld a,instr_code / &0100
          ld (de),a:inc e
; we put pointer in header for instruments that needs 2 words of param
          ld a,l:ld (de),a:inc e
          ld a,h:ld (de),a:inc e

          pop hl
          INC_HL()
      ELSE
; Here instrument defined directly by its LSB, pointing to:
; type, params, [inlined rows]
      IF flags_in_b
          inc bc        ; So B not changed by LDI
!! todo. we use bc for indirection
      END
      IF sfx
 !! todo
      END
      IF 1-phrase_in_de
  !! error
      END
          ld a,(de):inc de
; 0 only used for empty row: no instr to install and no note to read
          or a:jr z,_no_note
          ld c,a
          ld b,compiled_data / &0100 ; instr data MSB
          ld a,(bc):inc c ; type -> lsb routine
          ld (hl),a:inc l
          ld (hl),instr_code / &0100:inc l
          ld (hl),c:inc l ; pnt params
          ld (hl),b
      END

      IF ayane
          ld a,b
          ld bc,&7F00+BK_PHRASE:out (c),c
          ld b,a
      END
      ENDM

      MACRO UPDATE_NOTE phrase_in_de
      IF phrase_in_de
          ld a,(de):INC_DE()
; Periods in word, so we multiply*2 before storing.
  ; - More optimised (don't have to redo it for next ticks)
  ; - Trigger flags for future uses (and checks right now).
          add a
      IF sfx
!! todo
      END
      IF dev_checks
          call c,mess   ; >= 128: reserved
      END
          pop hl
; l: note+transpose (aka current note)
; h: transpose
          add h:ld l,a
          push hl
      ELSE
update_note_tm = 15
;same but de,hl exchanged
          ld a,(hl):INC_HL()
          add a
      IF dev_checks
          call c,mess   ; >= 128: reserved
          SUB_TM''(3)
      END
          pop de
          add d:ld e,a
          EX_AF'()
          SUB_TM_CALL(update_note_tm-1) ; -1 jr not taken
          EX_AF'()
          push de
      END
      ENDM

      MACRO NOT_REACHED
      BRK
      ENDM

      MACRO INC_HL
      IF ayane
          inc l         ; We know we are in a chunk
      ELSE
          inc hl
      END
      ENDM

; ------------------------------------------------
play
; ------------------------------------------------
; Play one tick of the music to fill /regs/
; (no sound emitted at this point (must call set_psg for that)

;In:
      IF sfx
       ; hl': routine timer a entrelacer
       ;  A: cpt TM 
      END
;Out: /regs/ buffer filled up
    ; hl: iter# so far, (e.g. 1 after first call)  warp after &ffff
    ;  a: cpt TM

;Used:
    ; SP: track info
    ; IX: channel info (voice A, B, C, independent on each track)
    ; HL: work variable
  ; Later:
     ; B: Volume  (with track volume tacken into account)
     ; C: Note    (with track transposition tacke into account)
     ;DE: pitch shift to apply    

; DI Needed since SP used 
; Better to do it ourself to avoid crash in case of oversight.
          di
tm0   = 1+15            ; until track_loop
          ld hl,r7
      IF use_flag_channel
          ld (hl),&3F
      ELSE
          ld (hl),&38
      END
;r13 : keep value from previous iter to detect if retrig needed
;r14 : sentinelle set in instr.o
          ld (savesp+1),sp
          SUB_TM_CALL(tm0) ; before sp change
          ld sp,track_stack

;Enchaine
track_loop
; Here: A = TM
      IF ayane
;only needed if RDV. Nevermind
          ld bc,&7F00 + BK_TRACK:out (c),c
tm1   = 24              ; until 'jr play_phrase' taken 
      ELSE
tm1   = 17
      END

tick      ld bc,0       ; Nb tick (1st iter:0)

; ---------------------------------
; -- RDV track event
; ---------------------------------
; See journal.o for rational 16 bits 
          pop hl
; Comparaison to mimimize maximum TM
; (rather than average TM. Not sure if it's the best choice!)
          or a:sbc hl,bc
          pop hl        ; Track pnt
          jr nz,play_phrase

; ---------------------------------
; -- Next RDV
; ---------------------------------
      IF may_optim
; use "inc l" if each track is confined
      END
      IF ayane
tm1'  = 5               ; until end_of_track (taken)
tm2   = 14+5+12+10-1    ; until evt_handle_loop ; -1: jr not taken
          inc h:dec h:jr z,end_of_track ; cannot use A(')
; read link next event hook
          ld e,(hl):inc hl
          ld d,(hl):inc hl
          res 7,d       ; Clear loop flag
          SUB_TM_CALL(tm2) ; before push!
          EX_AF'()
          push de
      ELSE
      IF sfx
!! todo     
      END
track_reset
; For compiled no link. we'll update pointer once we've processed events
; for now write dummy value so we can update RDV
          push de
      END
; ---------------------------------
; Add duration for next RDV 
; ---------------------------------
;!!! oh bug: numeric AND between &60 & 1
;      IF pattern_size AND [1-ayane]
      IF pattern_size * [1-ayane] ; ayane: always dynamic
;Constant pattern size
      IF sfx
!! todo
      END
          ld d,b
          ld a,c:add pattern_size:ld e,a:jr nc,$+3:inc d
      ELSE
          ld a,(hl):inc hl:add c:ld e,a
          ld a,(hl):inc hl:adc b:ld d,a
      END
          push de
          pop de        ; skip rdv
          pop de        ; skip pnt

; ---------------------------------
; Handle events.
; ---------------------------------
      IF use_event_type
; We have an optional list of setters,
; Follow by evt_new_phrase (nothing after that, we jump directly)
      IF ayane
evt_handle_loop
;--------------
tm_evt_play_phrase = 11 ; until jr play_phrase' (taken)
tm_evt_iter = 10+15+3   ; until jp hl (play_phrase' not taken)
;following link
          ld e,(hl):inc hl
          ld d,(hl)
          ld a,e:or d
          jr z,play_phrase' ; Null link = no more evet

          ld (nxt_event_pnt+1),de
          idsz ** inc de ; skip link
          ld a,(de):inc de
          ld l,a
      IF dev_checks
          SUB_TM''(5)
          cp evt_set_transpose AND &FF:jp z,.oklsb ; jp: stable
          SUB_TM''(5)
          cp evt_change_phrase AND &FF:jp z,.oklsb
      BRK
.oklsb
      END
      ELSE
;no link here
          ex de,hl      ; hl used as work variable
evt_handle_loop
; For now, we know all event lists end with evt_change_phrase:
; no need to test for end of list.
          ld a,(de):inc de
          ld l,a
      END
          ld h,events/&0100
          jp hl

      ELSE
; For compiled chp: always transpose and set phrase
          ex de,hl      ; need hl as work variable
          SET_TRANSPOSE()
          CHANGE_PHRASE()
          jr read_row
      END

      IF ayane
end_of_track
;continue to play phrase/instr.
          SUB_TM(tm1'+3-1) ; -1 jr nz,play_phrase not taken
          jr play_phrase
      END
; Set flag not to call the player again.
; And/or put address of null row in stack. 
; Better: just jump to play_tick, so we continue play instr/fx.
        ; actually we could also play last pattern in loop?
        ; -> hum, no, as this could be done explicitly as loop.

      IF nb_fx
_nofx0
_nofx0_tm = 7
          4 ** inc e
          jr _okfx0
      END

;End of track: no-op. Will be triggered again in &10000 ticks, nevermind
play_phrase'
;---------- 
; Coming from event loop
          EX_AF'()
          SUB_TM(tm_evt_play_phrase+1)

;enchaine
play_phrase
;----------
; -- RDV phrase event? (only 1 type: read_row)
; In 16 bits for crunchability / uniformity
          SUB_TM(tm1+14)
          pop hl
          or a:sbc hl,bc
          pop hl        ; Next row position
          jp nz,play_tick ; JP: stable TM  (out of reach anyway)

read_row
;------- 
      IF ayane
      IF dev_checks
; Check pointer in bank (hence only makes sense in-tool)
          EX_AF'()
          ld a,h:cp &40:call c,mess
          cp phrases_/&0100:call nc,mess
tm_read_row = 12 + 43   ; until read_fx
      ELSE
          EX_AF'()
tm_read_row = 1 + 43    ; until read_fx
      END

          ld d,b
          ld a,c
      IF phrases_across_banks
      !!! BK not more static anymore
      END
          ld bc,&7F00 + BK_PHRASE:out (c),c
          ld b,d
; +duration for next RDV 
          add (hl)
          INC_HL()
      ELSE
; Can use BC directly here
          ld a,(hl):INC_HL():add c
      END
          ld c,a
          jr nc,$+3:inc b
          push hl
          EX_AF'()
          SUB_TM_CALL(tm_read_row) ; before PUSH!
          EX_AF'()
          push bc
          pop hl        ; Just skip RDV
; DE = SP+2 (FX and instr hooks) 
; -> We use DE to install routines in stack
; ( if we wanted to do it with SP, we would have either to juggle or
  ; or do it backward: not handy)
; Side benefit: SP remains at the right address to update phrase pnt
; and continue at .ok_phrase
          ld hl,track_fx - track_phrase_pnt
          add hl,sp
      IF ayane
          ex de,hl
          pop hl        ; restore phrase pnt
      ELSE
          pop de
      END
;-----------------------------------------
      IF use_flags
          ld b,(hl)     ; flags   
          INC_HL()

; --- Start by fx 
;   - Historical reason
       ; we install FX before handling ins,
       ; since they must be ready when amorcing ins play. 
         ; (NB: ins play amorce optimization not done yet,
         ; so actually it doesn't matter much.)        
         ; - I have no idea what i meant here
   ;- Actual reason: order matters!
       ; - Technically: arpeggio and stuff must be ready before instr,
                      ; which do the finalization (note to tone and
                      ; sending to psg).
       ; - Musically: we want to allow.
              ; - Send to PSG
              ; - Add arpeggio (e.g. +12) 
              ; - Send as sid    
    ; (well this isn't possible via track fx since PSG sent in instr)

   ; But why fx before note or volume?
      ; -> arbritary since doesn't matter!

      IF nb_fx
read_fx
;------  
tm_read_fx0 = 5 + _nofx0_tm ;  When jr taken
          rr b
          jr nc,_nofx0

          ld a,(hl):INC_HL() ; LSB fx
          ld (de),a:inc e
          ld a,fx_code/&0100
          ld (de),a:inc e

      2 ** [
          ld a,(hl):INC_HL() ; word param no matter what
          ld (de),a:inc e
          ]
          SUB_TM''(23-1-_nofx0_tm) ; -1 for jr not taken
_okfx0

      IF nb_fx - 1      ; should be nb_fx > 1
 !!! todo
      END
      END

read_instr
;---------
; Instr after fx (see rationale above)
; Instr before note and vol to free DE.
tm_read_instr = 5       ; when no instr
          bit bit_instr-nb_fx,b ; (compense RR b)
          jr z,.okinstr ; no need to skip if no instr: de discarded
          UPDATE_INSTR(1,0)
.okinstr

read_note
;--------            
tm_read_note = 5
          bit bit_note-nb_fx,b:jr z,.oknote
          UPDATE_NOTE(0)
.oknote

read_vol
;-------                 
      IF use_volume
tm_read_vol = 11 + 17   ; when .okvol taken
          pop de        ;skip note
          pop de
; d: row volume+track volume (aka current volume) 
   ; In MSB since we want it in B ultimately
; e: track volume 
          bit bit_vol-nb_fx,b:jr z,.okvol

      IF use_track_volume
          ld a,(hl)
          INC_HL()
          add e         ; no need to clip. If >=&10 will mute non-hard.
          ld d,a
          SUB_TM''(5-1) ; -1 compensate jr
      ELSE
          ld d,(hl)
          INC_HL()
          SUB_TM''(3-1)
      END
.okvol
          push de
          2 ** dec sp   ; skip note
      END
          reserved_byte ** INC_HL()

      ELSE
; Version minimala.chp!
; Read instr and note inconditionally
      IF nb_fx
 !! todo 
      END
          UPDATE_INSTR(0,1)
          UPDATE_NOTE(1)
_no_note
          ex de,hl
      IF use_volume
 !! todo
      END
      END

          EX_AF'()
; Those one weren't worse counting before
tottm = tm_read_fx0+tm_read_instr+tm_read_note
          SUB_TM_CALL(tottm+tm_read_vol) ; before push!
          push hl       ; Update phrase pnt
          pop hl        ; just skip
;Enchaine
play_tick
;--------         
;Here A= TM  (A') 
; Play current row

      IF ayane
;For header and tables
play_tick_tm = 3+7
          ld bc,&7F00+BK_INSTR:out (c),c
      ELSE
play_tick_tm = 3
      END
          pop bc        ; c=note with current transpose
      IF use_volume
tick_vol_tm = 4
          pop de
          ld b,d        ; b=current vol
      ELSE
tick_vol_tm = 0
      END
      IF use_phrase_pitch
tick_pitch_tm = 3
          ld de,0       ; Reset pitch shift
      ELSE
tick_pitch_tm = 0
      END
; Jump to fx_0, fx_1, instr, and then track_loop  
      IF dev_checks
          pop hl
          push hl
          EX_AF'()
          ld a,l:cp fx_noFx AND &FF:jr z,.okfx
          cp fx_set_phrase AND &FF:call nz,mess
          SUB_TM''(5-1)
.okfx
          ld a,h:cp fx_noFx/&0100:call nz,mess
          EX_AF'()
          SUB_TM(21)
      END
; Jump to fx_0, fx_1, instr, and then track_loop   
          RET_ROUT(play_tick_tm + tick_vol_tm + tick_pitch_tm)

track_end
;All tracks have been handled
          ld hl,(tick+1)
          inc hl
          ld (tick+1),hl
savesp    ld sp,&3131
          RET_ROUT(15)

      IF ayane
; ----------------------
; Getter/setters        
; (put before /events/ to help with alignement
; ----------------------

set_replay_period
; In: hl = period
; Init in Track_init_module
          xor a         ; id tool box. 
; Start with highest periods to keep NC
          ex de,hl
          ld hl,replay_25_04Hz:sbc hl,de:jr z,.ok
          inc a
          ld hl,replay_50_08Hz:sbc hl,de:jr z,.ok
          inc a
          ld hl,replay_100_16Hz:sbc hl,de:jr z,.ok
          inc a
          ld hl,replay_300_48Hz:sbc hl,de

          call nz,mess
.ok
          ex de,hl
          call scope_bk_base
          ld (replay_period),hl
          ld (replay_period_ui),a
          ld (replay_period_in_nops),hl
          ret

      END

; ------
; Events
; ------

      MACRO SIGN_EVT type
      IF ayane
      BYTE type
      END
; Check confinement
      IF $/&0100 - events/&0100
 !! error confine
      END
      ENDM

type_evt_comment = 0    ; Todo 
type_evt_change_phrase = 1
type_evt_transpose = 2
;type_evt_row ; todo
;type_evt_set ; todo? or use via type_evt_row?

; In ram, no need for null event, as null link serves this purpose.
; Needed for serialization.
; That's why we use -1, for consistency with SENTINELLE
; (not very important though) 
type_evt_null = -1
; Dedicated for serialization (and compiled version)
; In-tool we use null link and link with bit15 set.
type_evt_stop = -2
type_evt_loop = -3

events
          SIGN_EVT(type_evt_transpose)
evt_set_transpose
          ASSERT(evt_set_transpose_lsb == [$ AND &FF])
          SET_TRANSPOSE()
      IF ayane
nxt_event_pnt ld hl,0
      IF dev_checks
          ld a,l:or h:call z,mess
          EX_AF'()
          SUB_TM(tm_evt_iter+set_transpose_tm+7+5)
      ELSE
          EX_AF'()
          SUB_TM(tm_evt_iter+set_transpose_tm+7)
      END
      ELSE
 !! todo: tm
      END
          jp evt_handle_loop

          SIGN_EVT(type_evt_change_phrase)
evt_change_phrase
; Necessarily end of list
          ASSERT(evt_change_phrase/&0100 == events/&0100) ;confine
          ASSERT(evt_change_phrase_lsb == [$ AND &FF])
          CHANGE_PHRASE()
;We don't do the whole loop, since we jump to read_row directly
          EX_AF'()
;Only count tm1 + tm2 once!
      IF todo
; What if evt_set_transpose and then null link!?!
      END
          SUB_TM(tm1+tm_evt_iter+change_phrase_tm+4)
          jp read_row


;-------------------------------------
      IF 1-ayane
; For ayane: handled in timer.o
psg
          ld hl,psg_regs
          ld b,&F4
          xor a
          exx
          ld bc,&F680
          ld d,&C0
.psglp
          out (c),d
          exx
          out (c),a
          exx:out (c),0:exx
          inc b:outi
          exx:out (c),c
          inc a
      IF use_hard_env
          cp 13
      ELSE
          cp 11
      END
          jr c,.psglp

      IF use_hard_env
          out (c),d
          exx
          ld d,a        ;13
          ld a,(hl)
          inc a:jr nz,$+3:inc d ;14: /dev/null
          out (c),d
          exx:out (c),0:exx
          dec a:out (c),a
          exx:out (c),c:out (c),0
      ELSE
          out (c),0     ; ?? needed ??
      END
          ret
      END

;-------
Amorce_song
; Setup internal variables and stacks.
; + init period table
;In:
      IF ayane
   ; N/A (subsong selected)
      ELSE
   ; HL= tracks (determines which sub_song)
      END
          ld de,track_stack
      IF ayane
          call scope_bk_track ; when called from PHRASUI
          call Song_get_first_track
.tracklp
          push hl
          ss_trackid ** inc l
          ld a,(hl)
          push hl
          call get_track_header
      ELSE
          lb bc,&336 ; cpt, mask chan A
.tracklp
          push bc
      END
          ld c,(hl):inc hl
          ld b,(hl)
      IF ayane
          ld a,c:or b:jr nz,.not0
          pop hl
          jr .next
.not0
      ELSE
          inc hl:push hl
      END
; RDV event: 0 (triggered at first iter)
          xor a
          ld (de),a:inc e
          ld (de),a:inc e

      IF dev_checks
 ; Check for buffer overflow (in case index corrupted or wrong address
 ; passed in hl).  
          ld hl,track_stack_ - 1 ; -1 for compare
          or a
          sbc hl,de:add hl,de
          call c,mess
      END

; Track pnt   
          ex de,hl
          ld (hl),c:inc hl
          ld (hl),b:inc hl
          ex de,hl
          ld hl,track_stack_init
          ld bc,track_stack_init_size
          ldir
          ex de,hl
      IF ayane
          pop de        ; was hl: subsong params
          ss_channel-ss_trackid ** inc e
          ld a,(de)
; A= Channel (1=A, 2=B, 3=C)
          or a:call z,mess ; "no output channel: not tracked now|
          ld bc,&0836   ; volume, OR mask channel A
          dec a:jr z,.ok
          ld bc,&092D   ; idem channel B
          dec a:jr z,.ok
          ld bc,&0A1B
.ok
          ld (hl),c:inc hl
          ld (hl),psg_regs/&0100:inc hl
          ld (hl),b:inc hl ;volume
      ELSE
          pop bc
          ld (hl),c:inc hl
          ld a,8+3:sub b
          ld (hl),psg_regs/&0100:inc hl
          ld (hl),a:inc hl ;volume
;update mask
          sl1 c
          res 6,c
;110110
;101101
;011011
      END
          ld (hl),psg_regs/&0100:inc hl
          ld (hl),track_loop AND &FF:inc hl
          ld (hl),track_loop / &0100:inc hl
          ex de,hl

.next
          pop hl
      IF ayane
          call Song_get_next_track
          jr nz,.tracklp
      ELSE
          djnz .tracklp
      END

; Replace jump loop by jump end
      IF dev_checks
          ld hl,track_stack
          or a:sbc hl,de
          call z,mess
; Fail if no tracks at all
      END
          ex de,hl
          dec hl:ld (hl),track_end / &0100
          dec hl:ld (hl),track_end AND &FF

      IF ayane
          ld hl,0:ld (tick+1),hl
          jp init_periods
      ELSE
;Enchaine (save a call)
          INIT_PERIODS()
      END

; -----------------------------
vars

      IF use_volume
track_stack_size0 = 12  ; Only read with POP: no MSB issue 
      ELSE
track_stack_size0 = 10
      END
;track_stack_size1 = nb_fx*4 + 4 ; FX and instr: use inc e
track_stack_size2 = 6   ; Only read with POP

      IF ayane
track_stack_init = $
; RDV row and current pnt doesn't matter
; since we assume track will set_phrase at RDV 0.
; But for tool, we nevertheless put sensible values.
      WORD &FFFF
      WORD &BAD0        ; will detect not in &4000 
      ELSE
; Init RDV row and current pnt with garbage for crunchability
track_stack_init = $ - 4
      END
      IF use_volume
      BYTE 0,0          ;volumes
      END
      BYTE 0,0          ;note/transpose
          nb_fx * 2 ** WORD fx_noFx
      WORD instr_null
;+2 for dummu  instr_noop parameter 
track_stack_init_size = $-track_stack_init + 2

      IF ayane
      SKIP -$ AND &FF   ; For easy debug
      SKIP 2            ; Help confine
      ELSE
      IF $-$$
 !! unexpected
      END
save_org = $
ho
; We can eat into psg_regs: init routine overwritten, nevermind.
;      FILL compiled_periods - $,0
      SKIP compiled_periods + &30 - $
      ORG compiled_stack
      END

track_stack
; Each stack consist of:

 ; Word 0            ; RDV event
 ; Word     ; Track pnt 
track_rdv_row = 4
 ; Word 0            ; RDV row
track_phrase_pnt = 6
 ; Word     ; Phrase pnt
track_transpose = 9
 ; word Note : LSB: row (current note) MSB: track (aka transpose)
 ; word Volume:LSB: track (0: max)     MSB: row   (0: max)
      IF use_volume
track_fx = 12
      ELSE
track_fx = 10
      END

 ; nb_fx ** word:word  (fx)
 ; word:word (instr)
 ; regs + mask
 ; regs + volume
 ; jump loop / end

      IF ayane
USED_TRACKS = MAX_TRACKS
      ELSE
USED_TRACKS = 3
      END

      USED_TRACKS ** [
;note: use FILL for overlap detection
     ; and quiet "not covered" messages when saving
      FILL track_stack_size0,0
      nb_fx + 1 ** [
 ; for fx and instrument we use LDI:inc e:LDI:LDI
.fx   WORD 0
      IF $/&0100 - .fx/&0100
   !!! error confine    
      END
      WORD 0
          ]
      FILL track_stack_size2,0
          ]

size_per_track = track_stack_size0 + track_stack_size2 + [nb_fx+1]*4
track_stack_
hi
      IF 1-ayane
      ORG save_org
      END


