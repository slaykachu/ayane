crossbanks = 0          ; 0: Each bank now has its own allocation housekeeping
todo  = 1
need_room = 1
; <<<<<<< Memory management >>>>>>>>
; Ayane version! 

; Dependencies: None
; Dependent: chung, liszt, heap

;   All routines return NC in case of error,
;   or BRK if failed assertion. (no 'exit/exception' mecanism)

      IMPORT "memmap.i" ; for checks and Init_chunk_module
      IMPORT "assert.o"
      IMPORT "memcpc.o"

dev_checks' = 1         ; forced for now

chunk_offset = &40

chead_next = 0
chead_last = 2
chead_last' = 0         ;for node pool (not linked)
;chead_checksum = 3
chead_lines# = 4        ;0 if empty, -1 if unknown
chunk_header_size = 5
chunk_start = chunk_header_size

chunk_aap_header_size = 4

ec_esc = &7F
;ec2_eoc = 0             ;end of chunk  !! must remain 0

; ===========================================

      MACRO CHECK_ID
      IF dev_checks'
          call check_id
      END
      ENDM


      MACRO CHECK_HL_IN_BANK
      IF dev_checks'
          call check_hl_in_bank
      END
      ENDM

      MACRO CHECK_DE_IN_BANK_OR_NULL
      IF need_room
; move into routine
      END
      IF dev_checks'
          push af
          ld a,e:or d:jr z,.ok
          ex de,hl
          call check_hl_in_bank
          ex de,hl
.ok
          pop af
      END
      ENDM

chunk_code
; ===========================================
Init_chunk_module
;----------------
; Cold init. Bank &c4, &c5
      IF BK_PHRASE - &C4
 !!! review                  
      END
          ld c,&C4:ld a,phrases_-&4000 / &0100:call .init_bank
      IF BK_BASE - &C5
 !!! review
      END
; Only tracks use chunks (via list api)
      IF todo
; Remove chunking, as we use 16 bits links pointeur anymode
; For now events are created via New_node_x, which uses chunking for
; legacy reason (orgams need it, since cross-banks shared memory alloc)
      END
      IF track_events - &4000
  !! must adapt chunk_offset
      END
          ld c,&C5:ld a,track_events_-&4000 /&0100:call .init_bank
          jp connect_bk_base

.init_bank
;In c= bank, A=nb chunks
          call connect_c
      IF dev_checks'
; C rather than 0 to help with orgams bank detection
          ld hl,&4000:ld (hl),c:ld de,&4001:ld bc,&3FFF:ldir
      END
          ld (v_free_chunks),a
          ld hl,zeroed
          ld b,zeroed_
          xor a
.fill     ld (hl),a:inc hl:djnz .fill
          scf
          ret

new_node_x_no_init
;-----------------
; Return id of fresh *uninitialized* chunk of size A.
; In: a = size node
; Out: DE:pnt 
      IF crossbanks
!!! code may have rotten in this case!
     ; C = bank
     ; C,HL preserved
     ; Bk base connected    
      ELSE
     ; BC,HL preserved 
     ; Same bank connected
      END
     ; Carry if OK, NC otherwise

          push bc
          push hl
          ld b,a        ; for get_node_list AND .no_node_freed
          call get_node_list
          ld a,(hl)
          or a:jr z,.no_node_freed

          inc l:ld c,(hl)
          inc l:ld l,(hl)
          ld h,c
;get next link and reset it
          push hl
          ld e,(hl):ld (hl),0:inc hl
          ld d,(hl):ld (hl),0
          call get_node_list
          ld (hl),e:inc l
          ld (hl),d
          pop de
          jr .popretok

.no_node_freed
;Allocate new chunk if needed
;IN:   A = node size
;OUT: CDE = pnt (connected)  
          ld hl,(v_node_pool)
          ld a,l:or h:jr nz,.ok_pool

.new_pool_chunk
;NB: Those chunks won't ever be freed. "False leak".
   ; Instead, the nodes within them are.
          call New_chunk:jr nc,.popret
      IF 1-crossbanks AND dev_checks'
; No crossbank: must stay in same bank.
          call get_bk_connected
          cp l:call nz,mess
      END
      IF chead_last'
 !! review that
  ; For now we use fact that first byte is 0
  ; (initialized as null link, used as 'last' field)
      END
      IF crossbanks
          call connect_bk_base
      END
          ld (v_node_pool),hl
.ok_pool
      IF crossbanks
          ld c,l        ; Returned bank
          call connect_chunk_from_id
      END
          ld l,chead_last'
          ld a,(hl)
          ld e,a
; If full, we just ask a new chunk. They are not linked,
; since they are never freed anyway.
          add b:jr c,.new_pool_chunk

          ld (hl),a
          inc e         ; post previous last = free node
          ld d,h
      IF crossbanks
          ld a,c
      END
.popretok
          scf
.popret
          pop hl
          pop bc
      IF crossbanks
          ld c,a
      END
          ret

get_node_list
;In:   B= node size
;Out: HL= corresponding list 
          push af
          ld a,b
          ld hl,v_free5_list:cp 5:jr z,.ok
          ld hl,v_free6_list:cp 6:jr z,.ok
          ld hl,v_free7_list:cp 7:jr z,.ok
          ld hl,v_free9_list:cp 9:jr z,.ok
      BRK
;TODO: other size or more generic system!
.ok
          pop af
          ret

free_list7
; NB: Tested in liszt.o
          ld hl,v_free7_list
;enchaine
free_list3
; TODO: factorize with /free_list/ (at least in term of style)

; Free list whose links are 3 bytes (bk + adr)
; In:  HL= pnt to link freed list
    ; CDE= ID list to release
; Out: bhl cde conversed.
          call connect_bk_base
          push bc
; X = bhl = freed id
          ld b,(hl):inc l
          ld a,(hl):inc l
          push hl
          ld l,(hl):ld h,a
          push hl
          call list3_gotoend ; end of CDE list
; Last.next = X  (link)
          ld (hl),b:inc l
          pop bc
          ld (hl),b:inc l
          ld (hl),c
          call connect_bk_base
; freed = cde (replug)
          pop hl
          pop bc
          ld (hl),e:dec l
          ld (hl),d:dec l
          ld (hl),c
          ret

list3_gotoend
; in: cde= id list  (!! non empty)
;out:  hl points on start of last node (link field).
    ; bcde conserved
          push bc
          ld b,c:ld h,d:ld l,e
l3ge
          call list3_next
          jr nz,l3ge
          pop bc
          ret

list3_next
; in: bhl= pnt node (!!not null)
;out: if next, NZ, bhl= pnt next node (connected)
    ; if last,  Z, bhl unchanged  
    ; cde conversed
          call connect_b
          ld a,(hl):or a:ret z
          ld b,a
          inc l:ld a,(hl)
      IF dev_checks'
          and &C0:cp &40:call nz,mess
      END
          ld a,(hl)
          inc l:ld l,(hl):ld h,a
      IF dev_checks'
;Cannot point to first byte of chunk, since used for 'last' field.
          ld a,l:or a:call z,mess
      END
          jp connect_b


new_chunk_no_init
;----------------
; Return id of fresh *uninitialized* chunk.
; In:  Bank for when we want the chunk must be connect
; Out: HL:Id. Ie H: MSB, L: Bk  (chunk left uninitialized)
;    : BC, DE preserved
     ; A trashed.
;    ; Carry if OK, NC otherwise
     ; Bk base connected !!  (todo: change that?)

; Must start by picking from freed list,
; otherwise fresh id computation would be off.

          ld hl,(v_free_list)
          ld a,l:or h:jr z,.no_freed
          call check_id
          push hl
          call connect_chunk_from_id
 ; next chunk (will be reset when copying header)
          call get_next
          call connect_bk_base
          ld (v_free_list),hl
          pop hl
          scf
          ret

.no_freed
          ld hl,v_free_chunks
          ld a,(hl)
          or a:jp z,memory_full ; -> No more chunks
          dec (hl)

;Use MSB in decreasing order (simpler code)
          add chunk_offset-1
      IF dev_checks'
          cp &40:call c,mess
          cp &7F:call nc,mess
      END
          ld h,a

; Note: Bank only useful is cross-bank access (e.G. index in base_bk)
          call get_bk_connected
          ld l,a
          scf
          jp connect_bk_base

get_next
;IN:  HL point anywhere in chunk (connected)
;OUT: HL=nxt id (not connected). Can be 0.
          ld l,chead_next
; Check first without modifying hl:
; in case of breakpoint we'll know the culprit.
          ld a,(hl):call _check_bk0
          inc l
          ld a,(hl):call _check_msb0
          dec l
          ld l,(hl):ld h,a
          ret


Next_node
; Follow next node (unless loop)
; In: HL = point on current node.link
;Out: If such a link: NZ, HL= new link
    ; Otherwise Z, HL unchanged! (needed to plug new nodes)
    ; A preserved.
          push de
          ld e,(hl):inc hl
          ld d,(hl):dec hl
          bit 7,d
          jr z,.ok
;loop: act as last node
          cp a          ; Z
          jr .exit
.ok
; !! Assume node pnt never has MSB =0
          inc d:dec d:jr z,.exit ; test D=0 without trashing A
          ex de,hl
.exit
          pop de
          ret


Insert_new_node
;--------------
; In:  A = total node size (with link)
    ; HL = point on current node.link
;Out: HL preserved 
    ; DE: pnt new link
    ; BC preserved

          push bc
      IF 0
 !! cannot: for now track index is in main RAM for debug purpose
 ; oh the irony
;        CHECK_HL_IN_BANK()
      ELSE
      IF dev_checks'
          inc h:dec h:call z,mess
      END
      END
; tmp = cur.next     
          ld e,(hl):inc hl
          ld d,(hl)
          CHECK_DE_IN_BANK_OR_NULL()
          push de
          call New_node_x
          CHECK_DE_IN_BANK_OR_NULL()
; cur.next = new node
          ld (hl),d:dec hl
          ld (hl),e
; new.next = tmp
          ex de,hl
          pop bc
          ld (hl),c:inc hl
          ld (hl),b:dec hl
          ex de,hl
          pop bc
          ret

New_node_x
;---------
; Connect new node of size A with 'next' field initialized (0).
; Used by track.o
; In: A= total size (with 'next' field)
; Out: C:bk DE:pnt  !! connected
;    : B, HL preserved
;    ; Carry if OK, NC otherwise

          call new_node_x_no_init:ret nc
          ex de,hl
          ld (hl),0:inc l
          ld (hl),0
          dec l
          ex de,hl
      IF dev_checks'
         ; Carry still set here
          call nc,mess
      END
          ret

New_chunk
;--------
; Connect new chunk with 'next' field initialized (0).
;  In: N/A
; Out: hl: id new chunk (connected).
     ; BC, DE preserved

     ; !! Last, checksum,etc field NOT SET  

          call new_chunk_no_init:ret nc
          push hl
          call connect_chunk_from_id
          xor a:ld l,a
          ld (hl),a:inc l:ld (hl),a
          pop hl
          scf
          ret


connect_next
; Simple version, but check.
; In: chunk connect
    ; h points in chunk
;Out: If ok,      NZ, chunk is connected and hl=id
    ; If no next,  Z, HL unchanged.
; All other register preserved (including A)

          push de
          ld d,l
          ld l,chead_next
          ld e,(hl):inc e:dec e:jr z,cnret
          inc l         ; NZ forced here
          ld d,(hl)
          ex de,hl
          call connect_chunk_from_id
      BYTE &16          ; Hack: ld d,n to skip ld l,d
cnret
          ld l,d        ; restore L only is no next.
          pop de
          ret

connect_chunk_from_id
;in : h=MSB, l=bk 
;out: Bk connected, all registers preserved
          CHECK_ID()
          jp connect_l


chunk_def
      BYTE 0,0,chunk_header_size-1 ;next (bk, MSB), pos last
      FILL 0,0          ;csum, row#


_check_bk0
;Check proper bank. 0 is ok (case null id)
;!! Change F.
;TODO, check lowbk <= A <= hibk (I-3)  -> Even more secure!
          or a:ret z
          push af
          and &C4:cp &C4:jr z,okpopaf
          pop af
      BRK
okpopaf   pop af
          ret

_check_msb0
;Check proper location. 0 is ok (case null id)
          or a:ret z
          cp &40:call c,mess
          cp &7F:call nc,mess
          ret

; =========== Persistent Variables ==============

savepc = $
saveobj = $$

      ORG chunk_var,$$
v_free_chunks BYTE      ; Nb of never used chunks
zeroed
v_free_list WORD        ; List of freed chunks
v_node_pool WORD        ; Last chunk dedicated to nodes (size agnostic)
v_free5_list SKIP 3     ; List of free nodes of size 5 (full pnt)
v_free6_list SKIP 3     ; List of free nodes of size 6 (full pnt)
v_free7_list SKIP 3     ; List of free nodes of size 7 (full pnt)
v_free9_list SKIP 3     ; List of free nodes of size 7 (full pnt)
zeroed_ = $-zeroed

      SKIP chunk_var_ - $ ; poor's man limit.

; ------ no more code / var allocation ------------------

fail_memoryfull = 251
fail_unexpectedmess = 247

      ORG savepc,saveobj ; for host


