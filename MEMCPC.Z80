; << Memory bank handling for ayane >>
; CPC specific PAGING (out &7fxx,&cX)
; 2025 Jun 20: jump table

dev_checks = 1
todo  = 1

      IMPORT "memmap.i"

mess  = &BE00

; Store currently connected bank 
; (for interruptions or co-routine to be able to store/restore)
bk_connected = &3C
;3d reserved (MSB bk).  !!!! Not used for now.
;3e 3f free

memcpc_code
          jp set_sp_backup
          jp reset_sp
          6 ** BRK
          12 ** BRK
      IF 0
          jp connect_bk_base
          jp connect_bk_track
          jp connect_bk_phrase
          jp connect_bk_instr
          jp connect_bk_io
          jp connect_a
          jp connect_b
          jp connect_c
          jp connect_l
          jp scope_bk_base
          3 ** BRK
          jp scope_bk_phrase
          6 ** BRK
          jp get_bk_connected
      END

;----------------------------
; ---- Main work bank ------
;----------------------------

connect_bk_base
;--------------
          push af
          call get_bk_base
          call connect_a
          pop af
          ret

      IF BK_TRACK - BK_BASE
 !! review that
      END
connect_bk_track = connect_bk_base
      IF BK_INSTR - BK_BASE
 !! review that
      END
connect_bk_instr = connect_bk_base

connect_bk_phrase
;----------------
          push bc
          ld c,BK_PHRASE
          call connect_c
          pop bc
          ret

connect_bk_io
;------------
          push bc
          ld c,BK_IO
          call connect_c
          pop bc
          ret


get_bk_base
;----------
;Ayane bk base is static for now (&c6)
;And I is reserved for another purpose (tba)
          ld a,BK_BASE
          ret

get_bk_connected
;---------------
          ld a,(bk_connected)
          call check_bk_a
          ret

;-----------------------------------------
; ----- Low-level page connections ------
;-----------------------------------------

connect_a
          push bc:ld c,a:call connect_c:pop bc:ret
connect_b
          push bc:ld c,b:call connect_c:pop bc:ret
connect_l
          push bc:ld c,l:call connect_c:pop bc:ret
connect_c
          push bc
      IF dev_checks
          push af
          ld a,c:call check_bk_a
_connect_com
          pop af
      END
          ld b,&7F
          ld (bk_connected),bc
          out (c),c
          pop bc
          ret

      IF dev_checks
connect_c_c0
;Like connect C, but also allows bank C0 (not only 
          push bc
          push af
          ld a,c:cp &C0:call nz,check_bk_a
          jr _connect_com
      END


scope_bk_base
; Temporarily change bk
; Client use:
   ; call scope_bk_base ; <- bk base connected
   ; <code>
   ; ret           ; <- here initial bk is automatically reconnected
          ex (sp),hl
          ld (_jump+1),hl
          ld hl,(bk_connected)
          ex (sp),hl
          call connect_bk_base
_jump     call mess
          ex (sp),hl
          call connect_l
          pop hl
          ret

scope_bk_phrase
          ex (sp),hl
          ld (_jump+1),hl
          ld hl,(bk_connected)
          ex (sp),hl
          call connect_bk_phrase
          jr _jump


set_sp_backup
;------------
; Must be called at init time
          pop hl        ; correct sp (caller's value)
          ld (save_sp+1),sp
          jp hl

reset_sp
;------- 
          pop hl
      IF dev_checks
          push af
          ld a,(save_sp+2)
          cp &BF:call nz,mess ; set_sp_backup must have been called
          pop af
      END
save_sp   ld sp,0
          jp hl

;----------------------------------------
; ---- Checks related to CPC Paging ----
;----------------------------------------

      IF dev_checks
check_b_bank
          push af
          ld a,b:call check_bk_a
          pop af
          ret

check_bk_a
          push af
          cp &C0:jr z,.ok
          cp &C1:jr z,.ok
; Must be in bank < &c7  (well actually < &cf for chunk.nrt)
          and &F4
          cp &C4:call nz,mess
.ok
          pop af
          ret

check_id0
; Like check_id, but hl can be 0 as well.
          push af
          inc l:dec l:jr nz,_check_id
; l=0, so h **must** be 0
          ld a,h:or a:call nz,mess
          pop af
          ret

check_id
; All register preserved. Simply BRK if wrong iD
          push af
_check_id
          ld a,l
          call check_bk_a
          pop af
;enchaine
check_hl_in_bank
          push af
          ld a,h:and &C0:cp &40:call nz,mess
          pop af
          ret

      IF 0
check_id0_cde_
          push af
          ld a,c:or a:jr nz,_check_id_cde_
; if c=0, de must be 0
          ld a,e:or d:call nz,mess
          pop af
          ret
      END


check_id_cde
          push af
_check_id_cde_
          ld a,c:and &C4:cp &C4:call nz,mess
          ld a,d:and &C0:cp &40:call nz,mess
; cannot point on start of chunk ('last' field)
          ld a,e:or a:call z,mess
          pop af
          ret

check_id_bhl
          push af
          ld a,b:ld b,c:ld c,a:ex de,hl ; swap bhl <-> cde
          call check_id_cde
          ld a,b:ld b,c:ld c,a:ex de,hl
          pop af
          ret

check_bk_base
; check bk base is connect
          push af:push bc
          call get_bk_base
          ld c,a
          ld a,(bk_connected)
          cp c
          call nz,mess
          pop bc:pop af
          ret
      END


