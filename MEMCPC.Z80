; << Memory bank handling for ayane >>
; CPC specific PAGING (out &7fxx,&cX)
; 2025 Aug 25: Remove jump table. Short module: neater to import
     ; Jun 20: jump table

todo  = 1

      IMPORT "memmap.i"
     ; IMPORT "const.i"  ; dev_checks

dev_checks' = 1         ; for now, don't use const.dev_checks
; -> allow to detect programming errors even when we deactivate 
   ; dev_checks for ply, timer etc...

; /// 2025 ///
   ; -- v0.0an --
       ;25: Adopt JP_DISP / 


mess  = &BE00
fail  = mess

; Store currently connected bank 
; (for interruptions or co-routine to be able to store/restore)
bk_connected = &3C
;3d reserved (MSB bk).  !!!! Not used for now.
;3e 3f free


; ---------------------------------
      MACRO JP_DISP adr
          call jp_disp:WORD adr
;note: doesn't return here, but at caller's level
      ENDM

      MACRO JP_STATUS adr
          call jp_status:WORD adr + &8000
;note: doesn't return here, but at caller's level
      ENDM

; ---------------------------------

memcpc_code

connect_bk_base
;----------------
; Main work bank
;----------------
          push af
          call get_bk_base
          call connect_a
          pop af
          ret

      IF BK_TRACK - BK_BASE
 !! review that
      END
connect_bk_track = connect_bk_base
      IF BK_INSTR - BK_BASE
 !! review that
      END
connect_bk_instr = connect_bk_base

connect_bk_phrase
;----------------
          push bc
          ld c,BK_PHRASE
          call connect_c
          pop bc
          ret

connect_bk_io
;------------
          push bc
          ld c,BK_IO
          call connect_c
          pop bc
          ret


get_bk_base
;----------
;Ayane bk base is static for now (&c6)
;And I is reserved for another purpose (tba)
          ld a,BK_BASE
          ret

get_bk_connected
;---------------
          ld a,(bk_connected)
          call check_bk_a
          ret

;-----------------------------------------
; ----- Low-level page connections ------
;-----------------------------------------

connect_a
          push bc:ld c,a:call connect_c:pop bc:ret
connect_b
          push bc:ld c,b:call connect_c:pop bc:ret
connect_l
          push bc:ld c,l:call connect_c:pop bc:ret
connect_c
          push bc
      IF dev_checks'
          push af
          ld a,c:call check_bk_a
_connect_com
          pop af
      END
          ld b,&7F
          ld (bk_connected),bc
          out (c),c
          pop bc
          ret

      IF dev_checks'
connect_c_c0
;Like connect C, but also allows bank C0 (not only 
          push bc
          push af
          ld a,c:cp &C0:call nz,check_bk_a
          jr _connect_com
      END


scope_bk_base
; Temporarily change bk
; Client use:
   ; call scope_bk_base ; <- bk base connected
   ; <code>
   ; ret           ; <- here initial bk is automatically reconnected
          ex (sp),hl
          ld (_jump+1),hl
          ld hl,(bk_connected)
          ex (sp),hl
          call connect_bk_base
_jump     call mess
          ex (sp),hl
          call connect_l
          pop hl
          ret

scope_bk_phrase
          ex (sp),hl
          ld (_jump+1),hl
          ld hl,(bk_connected)
          ex (sp),hl
          call connect_bk_phrase
          jr _jump


set_sp_backup
;------------
; Must be called at init time
          pop hl        ; correct sp (caller's value)
          ld (save_sp+1),sp
          jp hl

reset_sp
;------- 
          pop hl
      IF dev_checks'
          push af
          ld a,(save_sp+2)
          cp &BF:call nz,mess ; set_sp_backup must have been called
          pop af
      END
save_sp   ld sp,0
          jp hl

;-----------------------------------
; ---- Helpers to CALL in bank ----
;-----------------------------------

call_disp
;--------     
; Connect bk_disk, and connect back connected bk
;Usage: call call_disp:word adr  

; Get adr
          ex (sp),hl
          push af
          ld a,(hl):inc hl
          ld (.hook+1),a
          ld a,(hl):inc hl
          ld (.hook+2),a
          pop af
          ex (sp),hl    ; put back Ret address

          push hl
          push af
          call get_bk_connected
          ld l,a
          ld a,BK_DISP
          call connect_a
      IF dev_checks'
; verify code has been loaded
init_disp_adr = disp    ; used for checks in call_disp
          ld a,(init_disp_adr):cp &C3:call nz,fail ; jp
          ld a,(init_disp_adr+3):cp &C3:call nz,fail
      END
          pop af
          ex (sp),hl

.hook     call 0

          ex (sp),hl
          call connect_l
          pop hl
          ret

call_status
;----------     
; Connect &c1, call routine, and connect back connected bk
;Usage: call call_disp:word adr  

          ex (sp),hl
          push af
          ld a,(hl):inc hl
          ld (.hook+1),a
          ld a,(hl):inc hl
          ld (.hook+2),a
          pop af
          ex (sp),hl    ; put back Ret address

          push hl
          push af
          call get_bk_connected
          ld l,a
      IF BK_DISP-&C7
 !! review                 
      END
          ld a,&C1
          call connect_a
      IF dev_checks'
; verify code has been loaded
          ld a,(init_disp_adr+&8000):cp &C3:call nz,fail ; jp
          ld a,(init_disp_adr+&8003):cp &C3:call nz,fail
      END
          pop af
          ex (sp),hl

.hook     call 0

          ex (sp),hl
          call connect_l
          pop hl
          ret


jp_disp
;--------     
; !!!JP!!! to address in disp bk.
;Usage: call jp_disp:word adr   
      ; (act as jp)

; Get adr
          ex (sp),hl    ; !! RET address will be discarded !!
          push af
          ld a,(hl):inc hl
          ld h,(hl):ld l,a
          ld (.hook+1),hl

          call get_bk_connected
          ld l,a
          ld a,BK_DISP
          call connect_a
      IF dev_checks'
; verify code has been loaded
          ld a,(init_disp_adr):cp &C3:call nz,fail ; jp
          ld a,(init_disp_adr+3):cp &C3:call nz,fail
      END
          pop af
          ex (sp),hl

.hook     call 0

          ex (sp),hl
          call connect_l
          pop hl
          ret

jp_status
;--------     
; Like jp_disp, but bank &c1
;Usage: call jp_disp:word adr   
      ; (act as jp)

; Get adr
          ex (sp),hl    ; !! RET address will be discarded !!
          push af
          ld a,(hl):inc hl
          ld h,(hl):ld l,a
          ld (.hook+1),hl

          call get_bk_connected
          ld l,a
      IF BK_DISP - &C7
  !! review
      END
          ld a,&C1
          call connect_a
      IF dev_checks'
; verify code has been loaded
          ld a,(init_disp_adr+&8000):cp &C3:call nz,fail ; jp
          ld a,(init_disp_adr+&8003):cp &C3:call nz,fail
      END
          pop af
          ex (sp),hl

.hook     call 0

          ex (sp),hl
          call connect_l
          pop hl
          ret

;----------------------------------------
; ---- Checks related to CPC Paging ----
;----------------------------------------

      IF dev_checks'
check_b_bank
          push af
          ld a,b:call check_bk_a
          pop af
          ret

check_bk_a
          push af
          cp &C0:jr z,.ok
          cp &C1:jr z,.ok
; Must be in bank < &c7  (well actually < &cf for chunk.nrt)
          and &F4
          cp &C4:call nz,mess
.ok
          pop af
          ret

check_id0
; Like check_id, but hl can be 0 as well.
          push af
          inc l:dec l:jr nz,_check_id
; l=0, so h **must** be 0
          ld a,h:or a:call nz,mess
          pop af
          ret

check_id
; All register preserved. Simply BRK if wrong iD
          push af
_check_id
          ld a,l
          call check_bk_a
          pop af
;enchaine
check_hl_in_bank
          push af
          ld a,h:and &C0:cp &40:call nz,mess
          pop af
          ret

      IF 0
check_id0_cde_
          push af
          ld a,c:or a:jr nz,_check_id_cde_
; if c=0, de must be 0
          ld a,e:or d:call nz,mess
          pop af
          ret
      END


check_id_cde
          push af
_check_id_cde_
          ld a,c:and &C4:cp &C4:call nz,mess
          ld a,d:and &C0:cp &40:call nz,mess
; cannot point on start of chunk ('last' field)
          ld a,e:or a:call z,mess
          pop af
          ret

check_id_bhl
          push af
          ld a,b:ld b,c:ld c,a:ex de,hl ; swap bhl <-> cde
          call check_id_cde
          ld a,b:ld b,c:ld c,a:ex de,hl
          pop af
          ret

check_bk_base
; check bk base is connect
          push af:push bc
          call get_bk_base
          ld c,a
          ld a,(bk_connected)
          cp c
          call nz,mess
          pop bc:pop af
          ret
      END


