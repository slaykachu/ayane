do_profile = 1
; <<<<< Automated test for timer >>>>>

      IMPORT "const.i"
      IMPORT "memmap.i"
      IMPORT "plyconf.i"
      IMPORT "macro.i"

      ORG code_start
      ENT tests

      IMPORT "testlib.o" ; import it before timer for periods padding
      IMPORT "timer.o"
      IF do_profile
      IMPORT ":orgrel/prof.o"
      END

; /\/\/\/ 2025 \/\/\/\/\/
   ; ----- v0.0ao ------
  ; Sep
    ;16 Add test_simulate_timer_double'
      ; run_simulation: also profile (CANCELLED!)
   ; ----- v0.0am ------
  ; Aug                               
    ;29 Add test_insert_event
    ;27 Add test_simulate_timer 
      ; Add test_simulate_timer_double         
    ;25 Add test_waitlines test_sync test_anchor
    ;24 Add test_simulate_high_note
    ;23 Move macros in macro.i

   ; ----- v0.0ab ------
  ; Mar
    ; 1 Use :orgrel/prof.o (rather than ums:) 

; ------------------------------------------------
      MACRO VOL n
; Encode as expected -> xxxx0
      BYTE n*2
      ENDM

fail  = &BE00
nrtfail = &BE00
MAX_TM = &80

tests
          call test_simulate_timer_double'
      BRK
      2 ** [
          call test_null
          call test_start_sync_buzzer
          call test_start_sync_buzzer_fx_end
          call test_change_sync_buzzer
          call test_stop_sync_buzzer
          call test_program_next_event
     ;     call test_program_next_event_same_slot  not needed rn
          call test_insert_event
          call test_double_event_at_0
          call test_simulate_high_note
          call test_simulate_timer
          call test_simulate_timer_double
          call test_simulate_timer_double'
          ]
      IF do_profile
          call test_waitlines
          call test_vsync
          call test_anchor
      END
          ret

test_null
;--------
; Mainly test testing framework itself: proper profiling?
; (boilerplate + almost empty routine fx_end)
          call nrt_init_custom_clock

          ld hl,stack_null
          call run_fx
          ret

test_start_sync_buzzer
;---------------------
          call nrt_init_custom_clock

          ld hl,stack0
          call run_fx
          ld hl,ref0
          ld de,events
          ld bc,ref0_
          call compare_sized

; sanity
          call check_no_cut
          call check_no_change
; just for TM checks
          call run_set_timer_and_psg
          ret

ref0
      BYTE &10          ; link to next free slot
      BYTE [clock0 AND &FF] / 2 ; cpt
      BYTE anchor+hdr_cpt AND &FF ; link to next event
      BYTE clock0 / &0100
      BYTE clock0 AND &FF
; installed routine
          ex af,af
          ld a,env_type0
period0 = &D4D4         ; c# + arp 1
          ld de,period0 + shift0
          jp set_reg13_insert_and_program
ref0_ = $ - ref0

test_start_sync_buzzer_fx_end
;----------------------------   
; Same but jump to fx_end
          call nrt_init_custom_clock

          ld hl,stack0_fx_end
          call run_fx
          ld hl,ref0
          ld de,events
          ld bc,ref0_
          call compare_sized

          call check_no_cut
          call check_no_change
          ret


test_double_event_at_0
;---------------------  
; Two events at time 0
          call nrt_init_custom_clock

          ld hl,stack_double
          call run_fx   ; Will only call sync_buzzer_register
          ld hl,refd0
          ld de,events
          ld bc,ref0_
          call compare_sized
          ld hl,refd1
          ld de,events + EVENT_MAX_SIZE
          ld bc,ref0_
          call compare_sized

          call check_no_cut
          call check_no_change
          ret

.refd0
      BYTE &10          ; link to next free slot (once this one freed)
      BYTE [clock0 AND &FF] / 2 ; cpt
      BYTE EVENT_MAX_SIZE+hdr_cpt ; link to next event
      BYTE clock0 / &0100
      BYTE clock0 AND &FF
          ex af,af
          ld a,env_type0
          ld de,period0 + shift0
          jp set_reg13_insert_and_program
.refd1
      BYTE &20          ; link to next free slot
      BYTE [clock0 AND &FF] / 2 ; cpt
      BYTE anchor+hdr_cpt AND &FF ; link to next event
      BYTE clock0 / &0100
      BYTE clock0 AND &FF
          ex af,af
          ld a,env_type1
          ld de,period0 + shift1 ; !!! period0: same base note
          jp set_reg13_insert_and_program

test_insert_event
;----------------
; Prerequisite for test_simulate_timer_double
          call nrt_insert_event

          ld hl,.evt00:ld bc,EVENT_MAX_SIZE:ld de,events
          ldir
          ld hl,_evt1:ld bc,EVENT_MAX_SIZE:ld de,events+EVENT_MAX_SIZE
          ldir

;Setting: we manually set _evt0 at clock &300 (idx 3, cpt 0)
          ld a,hdr_cpt:ld (header_events+3),a
        ; Now we insert _evt1 at &310 
          ld de,&0310
          ld hl,events + EVENT_MAX_SIZE + hdr_code
          call nrt_insert_event
; First event must be _evt0
          ld a,(header_events+3):cp hdr_cpt:call nz,fail
; Must link to _evt1
          ld a,(events + hdr_link_next)
          cp EVENT_MAX_SIZE+hdr_cpt:call nz,fail
; _evt1 cpt (double nops) 
          ld a,(events + EVENT_MAX_SIZE + hdr_cpt)
          cp &10/2:call nz,fail
; link to anchor
          ld a,(events + EVENT_MAX_SIZE + hdr_link_next)
          cp anchor_event:call nz,fail
          ret

.evt00
;Like _evt0, but link to anchor
      BYTE EVENT_MAX_SIZE
      BYTE 0
      BYTE anchor_event
      WORD 0
          ld de,nrtper0
          ld b,evtmarker0 / &0100
          jp _evt_dbg


test_simulate_timer
;------------------
; Simulate 1 event running during one frame or so
          call nrt_init

;Use _evt1 which links to anchor (last event)
nrtper1 = &0340

          call clear_markers
;Hardcoded. Brittle, but hey.
          ld hl,_evt1:ld bc,EVENT_MAX_SIZE:ld de,events
          ldir

          call run_simulation

          ld hl,evtmarker1
          ld bc,nrtper1
          call check_markers
          ret

test_simulate_timer_double
;-------------------------  
; Simulate 2 events running during one frame or so
; Prerequiste: test_insert_event
          call nrt_init

nrtper0 = &0240         ; 2.25 lines
          call clear_markers

;Hardcoded. Brittle, but hey.
          ld hl,_evt0:ld bc,EVENT_MAX_SIZE:ld de,events
          ldir
          ld hl,_evt1:ld bc,EVENT_MAX_SIZE:ld de,events+EVENT_MAX_SIZE
          ldir

          call run_simulation

          ld hl,evtmarker0
          ld bc,nrtper0
          call check_markers
          ld hl,evtmarker1
          ld bc,nrtper1
          call check_markers
          ret


test_simulate_timer_double'
;-------------------------  
; Same but with identical periods
; Prerequiste: test_insert_event
          call nrt_init

          call clear_markers

;Hardcoded. Brittle, but hey.
          ld hl,_evt0:ld bc,EVENT_MAX_SIZE:ld de,events
          ldir
          ld hl,_evt0':ld bc,EVENT_MAX_SIZE:ld de,events+EVENT_MAX_SIZE
          ldir

          call run_simulation

          ld hl,evtmarker0
          ld bc,nrtper0
          call check_markers
          ld hl,evtmarker1
          ld bc,nrtper0
          call check_markers
          ret

;-----------
          ASSERT(hdr_link_free == 0)
          ASSERT(hdr_cpt == 1)
          ASSERT(hdr_link_next == 2) ; next event 
          ASSERT(hdr_clock == 3) ; clock (MSB then LSB)
          ASSERT(hdr_code == 5) ; execution
_evt0
      BYTE EVENT_MAX_SIZE
      BYTE 0
      BYTE EVENT_MAX_SIZE + hdr_cpt
      WORD 0
          ld de,nrtper0
          ld b,evtmarker0 / &0100
          jp _evt_dbg
_evt0'
      BYTE EVENT_MAX_SIZE
      BYTE 0
      BYTE anchor_event
      WORD 0
          ld de,nrtper0
          ld b,evtmarker1 / &0100
          jp _evt_dbg
_evt1
      BYTE EVENT_MAX_SIZE*2
      BYTE 0
      BYTE anchor_event
      WORD 0
          ld de,nrtper1
          ld b,evtmarker1 / &0100
          jp _evt_dbg   ; !! JP needed, copied header

_evt_dbg
          ex af,af
          ld a,(current_anchor)
          dec a         ; compensete inc for nxt anchor
          ld c,a
          ld a,(dbg_tm_marker)
          ld (bc),a

          call nrt_insert_event
          ex af,af
          PROGRAM_NEXT_EVENT(8 + 13 + insert_event_tm + 9)

nrt_insert_event
;IN: hl = events + hdr_cpt
   ; de = period to add to clock
          INSERT_EVENT()
          ret

clear_markers
          ld hl,evtmarker0
          ld de,evtmarker0+1
          ld bc,&01FF
          ld (hl),l
          ldir
          ret

run_simulation
;Well, do nothing for a while. SUB_TM_CALL will call HL'
          ld a,hdr_cpt  ; 1st event
          ld (header_events),a

          ld hl,anchor + hdr_code
          exx
          xor a         ; To have consistent tm marking
simulation_len = 152    ; half a frame
          ld b,simulation_len
.lp
      IF do_profile AND 0
!! no, cannot compare real tm against A,
 ; since A is updated with next event rdv.
          push bc
          ld iy,nrt_sub_tm_call
          call nrt_profile_check'
          pop bc
      ELSE
          4 ** SUB_TM_CALL(0) ; 4* 12 nops
          SUB_TM_CALL(4)
      END
          djnz .lp
          ret

nrt_sub_tm_call
          SUB_TM_CALL(3)
          ret

check_markers
;IN: hl = table
;  ; bc = period

          ld de,0       ; clock
.lp
; In table+D must find E 
          ld l,d
          ld a,e:srl a  ;unit is double nop
          cp (hl):call nz,fail
; update clock
          ex de,hl:add hl,bc:ex de,hl
          ld a,d
          cp simulation_len/4 ; &100 -> 4 lines
          jr c,.lp
          ret

test_simulate_high_note
;----------------------
; Program sync_buzzer with b7 (period 16bits = &107)
          ld a,MAX_TM
.lp
          push af
          call nrt_init ; does init_timer

          ld bc,&7F10:out (c),c ; for raster anchor

          ld hl,stack0_fx_end'
          ld (nrt_sp+1),hl
          call nrt_fx_setup
c0offset = 12           ; c0 offset in periods table
; Note a#6, whose 16 bits period is &10c > &100 
          ld ixl,[7*12 + 10 + c0offset]*2
          call nrt_fx   ; simulate play_instr
; Event should be at clock 0
          ld a,(header_events)
          cp hdr_cpt:call nz,nrtfail
; Try with each possible timer left 
          pop af
          push af
          exx
          ld hl,events+hdr_code
          exx
; Check it doesn't ASSERT
          call set_timer_and_psg
; force events for a full frame 
          ld b,312/4
.evt
          call jp_hl'
          djnz .evt

          pop af
          dec a
          jp p,.lp
          ret

stack0
      WORD sync_buzzer_register
env_type0 = 7
      BYTE env_type0
arp0  = 1
      BYTE arp0*2
shift0 = 13             ; pitch
      WORD shift0
      WORD nrt_ret

stack0_fx_end
      WORD sync_buzzer_register
      BYTE env_type0
      BYTE arp0*2
      WORD shift0
stack_null
      WORD fx_end

stack0_fx_end'
;same with arp and pitch = 0
      WORD sync_buzzer_register
      BYTE env_type0
      BYTE 0
      WORD 0
      WORD fx_end

stack1
      WORD sync_buzzer_register
env_type1 = 8
      BYTE env_type1
      BYTE arp0*2
shift1 = -12
      WORD shift1
      WORD fx_end

stack_double
; Program two events -> pseudo conflit at time 0
      WORD sync_buzzer_register
      BYTE env_type0
      BYTE 1*2
      WORD shift0
      WORD sync_buzzer_register
      BYTE env_type1
      BYTE 1*2
      WORD shift1
      WORD fx_end


test_change_sync_buzzer
;----------------------
; At second iteration, mustn't install routine but bufferize changes.

          call nrt_init_custom_clock

          ld hl,stack0:call run_fx
;Sanity checks
          call check_no_cut
          ld hl,ref0
          ld de,events
          ld bc,ref0_
          call compare_sized
          ld a,(fx_by_track)
          cp fx_type_sync_buzzer:call nz,fail

;New iter
          ld hl,stack1:call run_fx
          ld a,(fx_by_track)
          cp fx_type_sync_buzzer:call nz,fail
          call check_no_cut
          ld hl,refchange
          ld de,change_list
          ld bc,4
          call compare_sized
;Event mustn't have been touched
          ld hl,ref0
          ld de,events
          ld bc,ref0_
          call compare_sized

          call run_set_timer_and_psg

;Now event updated
          ld hl,ref1
          ld de,events
          ld bc,ref1_
          call compare_sized
          ret

refchange
      BYTE fx_type_sync_buzzer
      BYTE 0+hdr_code+skip_prelude
      BYTE env_type1
      WORD &D4D4+shift1

ref1
      BYTE &10          ; link to next free slot
      BYTE [clock0 AND &FF] / 2 ; cpt
      BYTE anchor+hdr_cpt AND &FF ; link to next event
      BYTE clock0 / &0100
      BYTE clock0 AND &FF
; installed routine
          ex af,af
          ld a,env_type1
          ld de,&D4D4 + shift1 ; c# + arp 1 
          jp set_reg13_insert_and_program
ref1_ = $ - ref1
      IF ref1_-1 AND &F0
 !!! routine too big
      END


test_stop_sync_buzzer
;--------------------
          call nrt_init_custom_clock

          ld hl,stack0_fx_end:call run_fx
          ld hl,stack_null:call run_fx

          ld a,(cut_list):cp 0+hdr_code:call nz,fail
          ld a,(cut_list+1):or a:call nz,fail
;Event mustn't have been touched
          ld hl,ref0
          ld de,events
          ld bc,ref0_
          call compare_sized

          call run_set_timer_and_psg

;Event replaced by no-op
          ld hl,ref_null
          ld de,events
          ld bc,ref_null_
          call compare_sized

;Slot should have been released
          ld a,(free_slot)
          cp hdr_link_free:call nz,fail
          ld a,(events+hdr_link_free)
          cp hdr_link_free+EVENT_MAX_SIZE:call nz,fail
          ret

ref_null
      BYTE &10          ; link to next free slot
      BYTE [clock0 AND &FF] / 2 ; cpt
      BYTE anchor+hdr_cpt AND &FF ; link to next event
      BYTE clock0 / &0100
      BYTE clock0 AND &FF
; routine replace by no-op
          SUB_TM(4)
          exx
          ret
ref_null_ = $ - ref_null


test_program_next_event
;----------------------

          call nrt_init_custom_clock

          ld hl,stack0
          call run_fx
;sanity check
          ld hl,ref0
          ld de,events
          ld bc,ref0_
          call compare_sized

period1 = &BABE
          ld de,period1
; Current event cpt will be removed, so must be null for comparison
          xor a:ld (events+hdr_cpt),a
          ld hl,events+hdr_code
          call run_set_psg_insert_and_program
nxtevt = clock0 + period1
          ld hl,header_events + nxtevt/&0100
          ld a,(hl)
          cp 0+hdr_cpt:call nz,fail ; Should points to event 0
          ld hl,events
          ld de,ref0'
          ld bc,ref0'_
          call compare_sized
          ret

ref0'
; Same event with updated clock
      BYTE &10          ; link to next free slot
      BYTE [nxtevt AND &FF] / 2 ; cpt
      BYTE anchor+hdr_cpt AND &FF ; link to next event
      BYTE nxtevt / &0100
      BYTE nxtevt AND &FF
; installed routine
          ex af,af
          ld a,env_type0
          ld de,&D4D4 + shift0 ; c# + arp 1 
          jp set_reg13_insert_and_program
ref0'_ = $ - ref0'

test_program_next_event_same_slot
;--------------------------------
;Same that previous, but event is set in same slot
      BRK
;todo if needed

      IF do_profile
test_anchor
;----------   
          call nrt_init

; Current event cpt will be removed, so must be null for comparison
          ld iy,.nrt_anchor
          call nrt_profile_check
          ret

.nrt_anchor
          SUB_TM(4)
          exx
          jp anchor + hdr_code
      END

;------------------------------------------
; -------- Helpers ---------------------
;------------------------------------------

check_no_cut
;cut_list must be empty
          ld hl,(cut_pnt)
          ld de,cut_list:or a:sbc hl,de:add hl,de:call nz,fail
          ld a,(hl)
          or a:call nz,fail
          ret

check_no_change
;cut_list must be empty
          ld hl,(change_pnt)
          ld de,change_list:or a:sbc hl,de:add hl,de:call nz,fail
          ld a,(hl)
          or a:call nz,fail
          ret



run_fx
;------
;In: HL = SP stack
          ld (nrt_sp+1),hl

;Normally done by init_timer or at the end of set_timer_and_psg
;We don't call init_timer (done in nrt_init): must mimick regular loop
          INIT_LISTS()

          call nrt_fx_setup
          ex af,af
          ld a,TM_MAX
          ld ixl,26     ; note (c#0)
      IF do_profile
          ld iy,nrt_fx
          call nrt_profile_check
      ELSE
          call nrt_fx
      END

;Normally at the start of set_timer_and_psg
          CLOSE_LISTS()
          ret

nrt_fx
;-----
; Setup sp (cannot do it before for profile)
          SUB_TM(12)
          ld (ret_sp),sp
;      BRK
nrt_sp    ld sp,0
          ret           ; sync_buzzer_register or fx_end
; Might also jump back to fx_end (eg /stack1/)
nrt_ret
          SUB_TM(9)
          ld sp,(ret_sp)
          ret


run_set_timer_and_psg
;--------------------
; reset psg regs for accurate check
          ld hl,psg_regs
          ld b,14
untouched = &3F         ; avoid setting bit 6 for r7
.raz      ld (hl),untouched:inc l:djnz .raz

          call nrt_fx_setup
;     ld a,MAX_TM:BRK:call set_timer
;/set_timer/ expect TM in A'
          ld a,MAX_TM
      IF do_profile
          ld iy,set_timer_and_psg
          call nrt_profile_check
      ELSE
          call set_timer_and_psg
      END
          ret


run_set_psg_insert_and_program
;-----------------------------     
; reset psg regs for accurate check
; In: HL= event  (hl')
    ; DE= period  
          di
          ld bc,&F40E   ; reg14
          xor a         ; sanity (don't set bit 6 on reg 7)
      IF do_profile
; Cannot use nrt_profile_check (D' is used)
  ; - 'set_psg_insert_and_program' is meant to be in EXX already.
  ; - not interrupted 
  ; - A' is reloaded (TM until next event)
      ; -> if it is anchor event, shouldn't change anything
  ; - Time taken by routine isn't counted inside routine,
      ; but in event (cf set_reg13_insert_and_program_tm)
          ex af,af
tm_trigger = -1         ; simulate 
          ld a,tm_trigger
          ex af,af
;Acutally we profile from set_reg13_insert_and_program,
;as its timing is counted inconditionaly
          call profile_jp:WORD set_reg13_insert_and_program
          neg
          add a
;-3: final 'ret' not counted by profile
;-base_fx_tm: counted inconditionaly, but not executed here
          add tm_trigger*2-3 - base_fx_tm
          cp l:call nz,fail
          ld a,h:or a:call nz,fail ; shouldn't take more than 256 nops
      ELSE
          call set_psg_insert_and_program
      END
;Some common checks
          exx
          ld a,h:cp events/&0100:call nz,fail
          exx
          ret

trap
      BRK
; shouldn't have been called
          exx
          ret

nrt_fx_setup
; Reset D to 0 (Needed for profiling)
; Set HL' (since we will jump into it)
; Preserve all registers
          di
          exx
; Instr routine might > 256 nops.
          ld d,0        ; MSB cpt
          ld hl,timer_nop
          exx
          ret

      IF do_profile

test_waitlines
          call nrt_init
          ld b,13
          ld iy,waitlines_tm
          call nrt_profile_check
          ret

test_vsync
          call nrt_init
          ld iy,vsync_timed
          call nrt_profile_check
          ret

nrt_profile_check
;In: iy = routine to profile
   ; Can pass BC DE HL
   ; (we want to pass IX and HL, depending on the routine)
          ld (.jp),iy
          exx
          ld d,0
          exx
          ex af,af
          ld a,MAX_TM
          call profile_jp
.jp   WORD 0
          neg
          add a
          add MAX_TM*2-3 ;-3: final 'ret' not counted by profile
          cp l:call nz,fail
          ld a,h:exx:cp d:call nz,fail:exx
          ret
      END

nrt_profile_check'
;Same a nrt_profile_check but:
   ; keep A = TM
   ; expect TM < &100
          ld (.jp),iy
          ld (.ref_tm+1),a
          exx
          ld d,0
          exx
          call profile_jp
.jp   WORD 0
          push af
          neg
.ref_tm   add 0
          add a
          add -3        ;-3: final 'ret' not counted by profile
          cp l:call nz,fail
          ld a,h:or a:call nz,fail
          pop af
          ret


nrt_init
;-------
          call init_timer
          jr _nrt_init_com

nrt_init_custom_clock
;--------------------
          call init_timer
; Clock doesn't have to be init explicitly, 
; since remaining in sync with anchor_pnt.
; Only setup for ref checking.
clock0 = &0146
          ld hl,clock0:ld (current_clock),hl
_nrt_init_com
          SYNC_ANCHOR()
          call nrt_init_periods
; Not striclty needed, but ease testing.
          ld hl,events:ld (free_slot),hl
; Kill firmware: needed to setup exx' without interference
                 ; since profile temporarily EI.
               ; And we need to setup HL'
          ld hl,&C9FB:ld (&38),hl
; Must be done early because even preplay_init might trigger JP HL'
          ld hl,timer_nop
          exx
          ret

      SKIP -$ AND &FF
evtmarker0 SKIP &0100
evtmarker1 SKIP &0100

          LIMIT(ramlimit)
