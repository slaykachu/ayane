do_profile = 1
; <<<<< Automated test for timer >>>>>

      IMPORT "const.i"
      IMPORT "memmap.i"
      IMPORT "plyconf.i"
      IMPORT "macro.i"

      ORG code_start
      ENT tests

      IMPORT "assert.o" ; mitigate orgams bug
      IMPORT "testlib.o" ; import it before timer for periods padding
      IMPORT "timer.o"
      IF do_profile
      IMPORT ":orgrel/prof.o"
      END

      IF nrt_marker == 0
  !! set it, otherwise inf loop waiting for nrt_msb_tm to change
      END

; /\/\/\/ 2026 \/\/\/\/\/
   ; --- alpha 2 ---
  ; Jan 23 Remove obsolete test_waitlines
         ; Fix tests themselves:
     ; - test_change_sync_buzzer: fix ref
     ; - test_sync_on_off'': must use nrt_profile_check_against_event
     ; - test_simulate_timer_double': flaky?
            ; or works again since we removed PSG_L_HL_FAST?
; /\/\/\/ 2025 \/\/\/\/\/
   ; ----- v0.0ar ------
  ; Oct 
    ; 8 Add test_sync_on_off_high_note
    ; 2 Add test_sync_on_off'''
    ; 1 Use nrt_msb_tm instead of D' (which can be modified by rout)
   ; ----- v0.0aq ------
  ; Sep 
    ;30 Add test_fx_null
      ; Add test_sync_on_off
    ;27 c-0 is now 0
   ; ----- v0.0ao ------
    ;16 Add test_simulate_timer_double'
      ; run_simulation: also profile (CANCELLED!)
   ; ----- v0.0am ------
  ; Aug                               
    ;29 Add test_insert_event
    ;27 Add test_simulate_timer 
      ; Add test_simulate_timer_double         
    ;25 Add test_waitlines test_sync test_anchor
    ;24 Add test_simulate_high_note
    ;23 Move macros in macro.i

   ; ----- v0.0ab ------
  ; Mar
    ; 1 Use :orgrel/prof.o (rather than ums:) 

; ------------------------------------------------
      MACRO NRT_INIT_ANCHOR
;init_timer set a lag, but we want run_simulation to start at first
;event. no race condition, since nrt_timer_setup set hl'=timer_nop
          xor a:ld (current_anchor),a
      ENDM

fail  = &BE00
nrtfail = &BE00
MAX_TM = &80

tests
      1 ** [
          call test_null
          call test_fx_null
          call test_start_sync_buzzer
          call test_start_sync_buzzer_fx_end
      IF 1 - [do_profile AND dev_checks]
; With dev_checks, sync_buzzer_register is too slow: tm wraps without
; a chance to detect 
; Solution: Test carry instead of P? As sync_buzzer_register called
          ; with A>0 (after RET_ROUT in instr.o)
          call test_sync_on_off
      END
          call test_sync_on_off'
          call test_sync_on_off''_0
          call test_sync_on_off''
          call test_change_sync_buzzer
          call test_stop_sync_buzzer
          call test_program_next_event
     ;     call test_program_next_event_same_slot  not needed rn
          call test_insert_event
          call test_double_event_at_0
          call test_simulate_high_note
          call test_simulate_timer
          call test_simulate_timer_double
      IF 1-dev_checks
; todo: don't know what's going on here
          call test_simulate_timer_double'
      END
          ]
      IF do_profile
          call test_vsync
          call test_anchor
      END
;very long (1 minute or so)
          call test_sync_on_off'''
          call test_sync_on_off_high_note
          ret

test_null
;--------
; Mainly test testing framework itself: proper profiling?
; (boilerplate + almost empty routine fx_end)
          call nrt_init_custom_clock

          ld hl,stack_null
          call run_fx
          ret

test_fx_null
;-----------  
;fx_null must eat params, so stack in proper place
          call nrt_init_custom_clock

          ld hl,stack_fx_null
          call run_fx
          ret


test_start_sync_buzzer
;---------------------
          call nrt_init_custom_clock

          ld hl,stack0
          call run_fx
          ld hl,ref0
          ld de,events
          ld bc,ref0_
          call compare_sized

; sanity
          call check_no_cut
          call check_no_change
; just for TM checks
          call run_set_timer_and_psg
          ret

ref0
      BYTE &10          ; link to next free slot
      BYTE [clock0 AND &FF] / 2 ; cpt
      BYTE anchor+hdr_cpt AND &FF ; link to next event
      BYTE clock0 / &0100
      BYTE clock0 AND &FF
; installed routine
          ex af,af
          ld a,env_type0
period0 = &D4D4         ; c# + arp 1
          ld de,period0 + shift0
          jp set_reg13_insert_and_program
ref0_ = $ - ref0

test_start_sync_buzzer_fx_end
;----------------------------   
; Same but jump to fx_end
          call nrt_init_custom_clock

          ld hl,stack0_fx_end
          call run_fx
          ld hl,ref0
          ld de,events
          ld bc,ref0_
          call compare_sized

          call check_no_cut
          call check_no_change
          ret

test_sync_on_off
;---------------
; Mainly test it doesn't hang
; !! half-baked: since cut fx isn't removed (no set_timer_and_psg),
               ; old events pile up.

          call nrt_init

          ld b,128
.lp
          push bc
          ld hl,stack0_fx_end:call run_fx
          call check_no_cut
          ld hl,stack_fx_null:call run_fx
          call check_cut
          pop bc
          djnz .lp
          ret

test_sync_on_off'
;---------------
; Same but actually set-up/cut the event
          call nrt_init

          ld b,128
.lp
          push bc
          ld hl,stack0_fx_end:call run_fx
          call check_no_cut
          call run_set_timer_and_psg

          ld hl,stack_fx_null:call run_fx
          call check_cut
          call run_set_timer_and_psg

          pop bc
          djnz .lp
          ret

test_sync_on_off''_0
;-------------------
; Same with 2 fx (1st one cut) but don't interleave with timer events
          call nrt_init
          NRT_INIT_ANCHOR()

          ld b,128
.lp
          push bc
          ld hl,stack_double:call run_fx
          call check_no_cut
          call run_set_timer_and_psg'
      IF 1
          ld a,(events+EVENT_MAX_SIZE+hdr_link_next)
      ELSE
          ld a,(events+hdr_link_next)
      END
          cp anchor_event:call nz,fail

          ld hl,stack_null_and_fx:call run_fx
          call check_cut
          call run_set_timer_and_psg'
;Note: first event was reused
          ld a,(events+hdr_link_next)
          cp anchor_event:call nz,fail

          pop bc
          djnz .lp
          ret


test_sync_on_off''
;----------------
; Same with 2 fx (1st one cut)
          call nrt_init

          ld b,128
.lp
          push bc
;          ld a,b:cp &66:call z,&BE00
;Don't init list: 
    ; - at first iteration: done by nrt_init via init_timer
    ; - then handled by run_set_timer_and_psg
          ld hl,stack_double:call run_fx
          call check_no_cut
          call run_set_timer_and_psg'
; No. Events linked at first iter, but then at <> timestamps
      ;    ld a,(events+hdr_link_next)
      ;    cp EVENT_MAX_SIZE + hdr_cpt:call nz,fail 
      IF 1
          ld a,(events+EVENT_MAX_SIZE+hdr_link_next)
      ELSE
          ld a,(events+hdr_link_next)
      END
          cp anchor_event:call nz,fail

          ld hl,stack_null_and_fx:call run_fx
          call check_cut
          call run_set_timer_and_psg'
;Note: first event was reused
          ld a,(events+hdr_link_next)
          cp anchor_event:call nz,fail

          pop bc
          djnz .lp
          ret


test_sync_on_off'''
;------------------
; With simulation. No tests as links are updated by simulation
; !! Warning. Invariant broken by this test: at most one instance of
   ; each event in /events/. Because we simulate half a frame,
   ; not all events are cleared
   ; Solution: simulate whole frame or advance at 100hz (current_clock)
          call nrt_init
          NRT_INIT_ANCHOR()
      IF do_profile
          ld b,8        ; too slow otherwise
      ELSE
          ld b,128
      END
.lp
          push bc
;Don't init list: handled by run_set_timer_and_psg
          ld hl,stack_double:call run_fx
          ld a,hdr_cpt:call check_at_most_one_event
          call check_no_cut
          call run_set_timer_and_psg
          ld a,hdr_cpt:call check_at_most_one_event
          call run_simulation
          ld a,hdr_cpt:call check_at_most_one_event
          ld a,hdr_cpt + EVENT_MAX_SIZE:call check_at_most_one_event
          call check_no_self_loop

          ld hl,stack_null_and_fx:call run_fx
          call check_cut
          call run_set_timer_and_psg
          call run_simulation
          ld a,hdr_cpt:call check_at_most_one_event
          ld a,hdr_cpt + EVENT_MAX_SIZE:call check_at_most_one_event
          call check_no_self_loop

          pop bc
          djnz .lp
          ret

test_sync_on_off_high_note
;-------------------------
; With just 1 fx and lower period
; Also, more accurate simulation: don't reset hl'
          call nrt_init
          xor a:ld (current_anchor),a
          ld hl,anchor_code:exx
      IF do_profile
          ld b,8        ; too slow otherwise
      ELSE
          ld b,128
      END
.lp
          ld a,&F0:call progress_bar
          push bc
          call nrt_init_lists
          ld hl,stack1:ld ixl,84*2:call run_fx_custom_note_no_reset
          ld a,hdr_cpt:call check_at_most_one_event
          call check_no_cut
          call run_set_timer_and_psg'
          ld a,hdr_cpt:call check_at_most_one_event
          call run_simulation
          ld a,hdr_cpt:call check_at_most_one_event
          ld a,hdr_cpt + EVENT_MAX_SIZE:call check_at_most_one_event
          call check_no_self_loop

          call nrt_init_lists
          ld hl,stack_null:ld ixl,84*2:call run_fx_custom_note_no_reset
          call check_cut
          call run_set_timer_and_psg'
          call run_simulation
          ld a,hdr_cpt:call check_at_most_one_event
          ld a,hdr_cpt + EVENT_MAX_SIZE:call check_at_most_one_event
          call check_no_self_loop

          pop bc
          djnz .lp
          ret


test_double_event_at_0
;---------------------  
; Two events at time 0
          call nrt_init_custom_clock

          ld hl,stack_double
          call run_fx   ; Will only call sync_buzzer_register
          ld hl,refd0
          ld de,events
          ld bc,ref0_
          call compare_sized
          ld hl,refd1
          ld de,events + EVENT_MAX_SIZE
          ld bc,ref0_
          call compare_sized

          call check_no_cut
          call check_no_change
          ret

.refd0
      BYTE &10          ; link to next free slot (once this one freed)
      BYTE [clock0 AND &FF] / 2 ; cpt
      BYTE EVENT_MAX_SIZE+hdr_cpt ; link to next event
      BYTE clock0 / &0100
      BYTE clock0 AND &FF
          ex af,af
          ld a,env_type0
          ld de,period0 + shift0
          jp set_reg13_insert_and_program
.refd1
      BYTE &20          ; link to next free slot
      BYTE [clock0 AND &FF] / 2 ; cpt
      BYTE anchor+hdr_cpt AND &FF ; link to next event
      BYTE clock0 / &0100
      BYTE clock0 AND &FF
          ex af,af
          ld a,env_type1
          ld de,period0 + shift1 ; !!! period0: same base note
          jp set_reg13_insert_and_program

test_insert_event
;----------------
; Prerequisite for test_simulate_timer_double
          call nrt_init

          ld hl,.evt00:ld bc,EVENT_MAX_SIZE:ld de,events
          ldir
          ld hl,_evt1:ld bc,EVENT_MAX_SIZE:ld de,events+EVENT_MAX_SIZE
          ldir

;Setting: we manually set _evt0 at clock &300 (idx 3, cpt 0)
          ld a,hdr_cpt:ld (header_events+3),a
        ; Now we insert _evt1 at &310 
          ld de,&0310
          ld hl,events + EVENT_MAX_SIZE + hdr_code
          call nrt_insert_event
; First event must be _evt0
          ld a,(header_events+3):cp hdr_cpt:call nz,fail
; Must link to _evt1
          ld a,(events + hdr_link_next)
          cp EVENT_MAX_SIZE+hdr_cpt:call nz,fail
; _evt1 cpt (double nops) 
          ld a,(events + EVENT_MAX_SIZE + hdr_cpt)
          cp &10/2:call nz,fail
; link to anchor
          ld a,(events + EVENT_MAX_SIZE + hdr_link_next)
          cp anchor_event:call nz,fail
          ret

.evt00
;Like _evt0, but link to anchor
      BYTE EVENT_MAX_SIZE
      BYTE 0
      BYTE anchor_event
      WORD 0
          ld de,nrtper0
          ld b,evtmarker0 / &0100
          jp _evt_dbg


test_simulate_timer
;------------------
; Simulate 1 event running during one frame or so
          call nrt_init

;Use _evt1 which links to anchor (last event)
nrtper1 = &0340

          call clear_markers
;Hardcoded. Brittle, but hey.
          ld hl,_evt1:ld bc,EVENT_MAX_SIZE:ld de,events
          ldir
          ld a,hdr_cpt:ld (header_events),a ; 1st event

          call run_simulation

          ld hl,evtmarker1
          ld bc,nrtper1
          call check_markers
          ret

test_simulate_timer_double
;-------------------------  
; Simulate 2 events running during one frame or so
; Prerequiste: test_insert_event
          call nrt_init

nrtper0 = &0240         ; 2.25 lines
          call clear_markers

;Hardcoded. Brittle, but hey.
          ld hl,_evt0:ld bc,EVENT_MAX_SIZE:ld de,events
          ldir
          ld hl,_evt1:ld bc,EVENT_MAX_SIZE:ld de,events+EVENT_MAX_SIZE
          ldir
          ld a,hdr_cpt:ld (header_events),a ; 1st event

          call run_simulation

          ld hl,evtmarker0
          ld bc,nrtper0
          call check_markers
          ld hl,evtmarker1
          ld bc,nrtper1
          call check_markers
          ret


test_simulate_timer_double'
;-------------------------  
; Same but with identical periods
; Prerequiste: test_insert_event
; !!!! broken. generate too many events!!
          call nrt_init

          call clear_markers

;Hardcoded. Brittle, but hey.
          ld hl,_evt0:ld bc,EVENT_MAX_SIZE:ld de,events
          ldir
          ld hl,_evt0':ld bc,EVENT_MAX_SIZE:ld de,events+EVENT_MAX_SIZE
          ldir
          ld a,hdr_cpt:ld (header_events),a ; 1st event

          call run_simulation

          ld hl,evtmarker0
          ld bc,nrtper0
          call check_markers
          ld hl,evtmarker1
          ld bc,nrtper0
          call check_markers
          ret

;-----------
          ASSERT(hdr_link_free == 0)
          ASSERT(hdr_cpt == 1)
          ASSERT(hdr_link_next == 2) ; next event 
          ASSERT(hdr_clock == 3) ; clock (MSB then LSB)
          ASSERT(hdr_code == 5) ; execution
_evt0
      BYTE EVENT_MAX_SIZE
      BYTE 0
      BYTE EVENT_MAX_SIZE + hdr_cpt
      WORD 0
          ld de,nrtper0
          ld b,evtmarker0 / &0100
          jp _evt_dbg
_evt0'
      BYTE EVENT_MAX_SIZE
      BYTE 0
      BYTE anchor_event
      WORD 0
          ld de,nrtper0
          ld b,evtmarker1 / &0100
          jp _evt_dbg
_evt1
      BYTE EVENT_MAX_SIZE*2
      BYTE 0
      BYTE anchor_event
      WORD 0
          ld de,nrtper1
          ld b,evtmarker1 / &0100
          jp _evt_dbg   ; !! JP needed, copied header

_evt_dbg
          ex af,af
          ld a,(current_anchor)
          dec a         ; compensete inc for nxt anchor
          ld c,a
          ld a,(dbg_tm_marker)
          ld (bc),a

          call nrt_insert_event
          ex af,af
          SUB_TM(8 + 13 + insert_event_tm + 9 + program_next_event_tm)
          PROGRAM_NEXT_EVENT()

nrt_insert_event
;IN: hl = events + hdr_cpt
   ; de = period to add to clock
          COMPENSATE_AND_INSERT_EVENT()
          ret

clear_markers
          ld hl,evtmarker0
          ld de,evtmarker0+1
          ld bc,&01FF
          ld (hl),l
          ldir
          ret

run_simulation
;Well, do nothing for a while. SUB_TM_CALL will call HL'

          ld hl,anchor_code
          exx
;simulation_len = 39     ; half a frame
simulation_len = 78     ; full frame to clear each events
          xor a
          ld (nrt_msb_tm),a
; A= TM = 0 to trigger immediatly (doesn't matter much)
          ld c,simulation_len
.lp
      IF do_profile
          push bc
          ld iy,nrt_sub_tm_call
          call nrt_profile_check_against_event
          pop bc
      END
;trigger all events but anchor_event
;So that next frame with start with right anchor event
.wait
          ex af,af
          exx
          ld a,l:cp anchor_code AND &FF
          exx
          jr z,.nxt

      IF do_profile
          jr .lp
      ELSE
          ex af,af
          SUB_TM_CALL(9+3)
          jr .wait
      END
.nxt
          ld a,(nrt_msb_tm)
          cp c
          ret z
      IF 1-do_profile
          ex af,af
          SUB_TM_CALL(9+8+3)
      END
          jr lp

nrt_sub_tm_call
          SUB_TM_CALL(3)
          ret

check_markers
;IN: hl = table
;  ; bc = period

          ld de,0       ; clock
.lp
; In table+D must find E 
          ld l,d
          ld a,e:srl a  ;unit is double nop
          cp (hl):call nz,fail
; update clock
          ex de,hl:add hl,bc:ex de,hl
          ld a,d
          cp simulation_len/4 ; &100 -> 4 lines
          jr c,.lp
          ret

test_simulate_high_note
;----------------------
; Program sync_buzzer with b7 (period 16bits = &107)
          ld a,MAX_TM
.lp
          push af
          call nrt_init ; does init_timer

          ld bc,&7F10:out (c),c ; for raster anchor

          ld hl,stack0_fx_end'
          ld (nrt_sp+1),hl
          call nrt_timer_setup
c0offset = 0            ; c0 offset in periods table
; Note a#6, whose 16 bits period is &10c > &100 
          ld ixl,[7*12 + 10 + c0offset]*2
          call nrt_fx   ; simulate play_instr
; Event should be at clock 0
          ld a,(header_events)
          cp hdr_cpt:call nz,nrtfail
; Try with each possible timer left 
          pop af
          push af
          exx
          ld hl,events+hdr_code
          exx
; Check it doesn't ASSERT
          call set_timer_and_psg
; force events for a full frame 
          ld b,312/4
.evt
          call jp_hl'
          djnz .evt

          pop af
          dec a
          jp p,.lp
          ret

stack0
      WORD sync_buzzer_register
env_type0 = 7
      BYTE env_type0
arp0  = 1
      BYTE arp0*2
shift0 = 13             ; pitch
      WORD shift0
      WORD nrt_ret

stack_null_and_fx
      WORD fx_null
      WORD fail
      WORD fail
;enchaine
stack0_fx_end
      WORD sync_buzzer_register
      BYTE env_type0
      BYTE arp0*2
      WORD shift0
stack_null
      WORD fx_end

stack_fx_null
      WORD fx_null
      WORD fail
      WORD fail
      WORD fx_end



stack0_fx_end'
;same with arp and pitch = 0
      WORD sync_buzzer_register
      BYTE env_type0
      BYTE 0
      WORD 0
      WORD fx_end

stack1
      WORD sync_buzzer_register
env_type1 = 8
      BYTE env_type1
      BYTE arp0*2
shift1 = -12
      WORD shift1
      WORD fx_end

stack_double
; Program two events -> pseudo conflit at time 0
      WORD sync_buzzer_register
      BYTE env_type0
arp1  = 30
  ;    BYTE arp1*2
      BYTE 1*2
      WORD shift0
      WORD sync_buzzer_register
      BYTE env_type1
   ;   BYTE arp1*2
      BYTE 1*2
      WORD shift1
      WORD fx_end


test_change_sync_buzzer
;----------------------
; At second iteration, mustn't install routine but bufferize changes.

          call nrt_init_custom_clock

          ld hl,stack0:call run_fx
;Sanity checks
          call check_no_cut
          ld hl,ref0
          ld de,events
          ld bc,ref0_
          call compare_sized
          ld a,(fx_by_track)
          cp fx_type_sync_buzzer:call nz,fail

;New iter
          ld hl,stack1:call run_fx
          ld a,(fx_by_track)
          cp fx_type_sync_buzzer:call nz,fail
          call check_no_cut
          ld hl,refchange
          ld de,change_list
          ld bc,4
          call compare_sized
;Event mustn't have been touched
          ld hl,ref0
          ld de,events
          ld bc,ref0_
          call compare_sized

          call run_set_timer_and_psg

;Now event updated
          ld hl,ref1
          ld de,events
          ld bc,ref1_
          call compare_sized
          ret

refchange
      BYTE fx_type_sync_buzzer
      BYTE 0+hdr_code+skip_prelude
      BYTE env_type1
      WORD &D4D4+shift1

ref1
      BYTE &10          ; link to next free slot
      IF 0
.clockref = clock0
      ELSE
;well set_reg13_insert_and_program was trigerred, so clock +period
.clockref = clock0 + &D4D4 + shift1 ; not shift0 ???
      END
      BYTE [.clockref AND &FF] / 2 ; cpt
      BYTE anchor+hdr_cpt AND &FF ; link to next event
      BYTE .clockref / &0100
      BYTE .clockref AND &FF
; installed routine
          ex af,af
          ld a,env_type1
          ld de,&D4D4 + shift1 ; C# + arp 1 = D
          jp set_reg13_insert_and_program
ref1_ = $ - ref1
      IF ref1_-1 AND &F0
 !!! routine too big
      END


test_stop_sync_buzzer
;--------------------
          call nrt_init_custom_clock

          ld hl,stack0_fx_end:call run_fx
          ld hl,stack_null:call run_fx

          ld a,(cut_list):cp 0+hdr_code:call nz,fail
          ld a,(cut_list+1):or a:call nz,fail
;Event mustn't have been touched
          ld hl,ref0
          ld de,events
          ld bc,ref0_
          call compare_sized

          call run_set_timer_and_psg

;Event removed
          call check_no_events

;Slot should have been released
          ld a,(free_slot)
          cp hdr_link_free:call nz,fail
          ld a,(events+hdr_link_free)
          cp hdr_link_free+EVENT_MAX_SIZE:call nz,fail
          ret


test_program_next_event
;----------------------

          call nrt_init_custom_clock

          ld hl,stack0
          call run_fx
;sanity check
          ld hl,ref0
          ld de,events
          ld bc,ref0_
          call compare_sized

period1 = &BABE
          ld de,period1
; Current event cpt will be removed, so must be null for comparison
          xor a:ld (events+hdr_cpt),a
          ld hl,events+hdr_code
          call run_set_psg_insert_and_program
nxtevt = clock0 + period1
          ld hl,header_events + nxtevt/&0100
          ld a,(hl)
          cp 0+hdr_cpt:call nz,fail ; Should points to event 0
          ld hl,events
          ld de,ref0'
          ld bc,ref0'_
          call compare_sized
          ret

ref0'
; Same event with updated clock
      BYTE &10          ; link to next free slot
      BYTE [nxtevt AND &FF] / 2 ; cpt
      BYTE anchor+hdr_cpt AND &FF ; link to next event
      BYTE nxtevt / &0100
      BYTE nxtevt AND &FF
; installed routine
          ex af,af
          ld a,env_type0
          ld de,&D4D4 + shift0 ; c# + arp 1 
          jp set_reg13_insert_and_program
ref0'_ = $ - ref0'

test_program_next_event_same_slot
;--------------------------------
;Same that previous, but event is set in same slot
      BRK
;todo if needed

      IF do_profile
test_anchor
;----------                
;!! Warning, anchor called twice, because normally triggered when a<0
; Here triggered with A=&80, PROGRAM_NEXT_EVENT adds &80-anchor_event_tm
; which doesn't trigger Carry (the sign that we have free time again)
;!! Actually helps us? A is updated with nxt event RDV, so unfit
  ; for profile check. But done twice : +&100 -> no change
          call nrt_init
          exx
          ld hl,anchor_code
          exx
          ld iy,nrt_sub_tm_call
          call nrt_profile_check_against_event
          ret
      END

;------------------------------------------
; -------- Helpers ---------------------
;------------------------------------------

check_no_cut
;cut_list must be empty
          ld hl,(cut_pnt)
          ld de,cut_list:or a:sbc hl,de:add hl,de:call nz,fail
;don't test sentinelle 0 as it is put later by set_timer_and_psg
 ;         ld a,(hl):or a:call nz,fail
          ret

check_cut
;cut_list must not be empty
          ld hl,(cut_pnt)
          ld de,cut_list:or a:sbc hl,de:add hl,de:call z,fail
          ld a,(de)
          or a:call z,fail
          ret

check_no_change
;cut_list must be empty
          ld hl,(change_pnt)
          ld de,change_list:or a:sbc hl,de:add hl,de:call nz,fail
          ld a,(hl)
          or a:call nz,fail
          ret

check_no_events
          ld hl,header_events
.lp
          ld a,(hl):cp anchor_event:call nz,fail
          inc l
          jr nz,.lp
          ret

check_exactly_one_event
          call check_at_most_one_event
          dec c:call nz,fail
          ret

check_at_most_one_event
;Note: the event might not be in header, but piggy-backed instead
;in: a = evt pnt (hdr_cpt)
          ld c,0
          ld hl,header_events
.lp
          cp (hl):jr nz,.nxt
          inc c:dec c:call nz,fail
          inc c
.nxt
          inc l
          jr nz,.lp
          ret

check_no_self_loop
          ld a,(events + hdr_link_next):cp hdr_cpt:call z,fail
          ret

run_fx
;------
;In: HL = SP stack
          call nrt_init_lists
          ld ixl,2 + note_c_0_encoding ; note (c#0)
run_fx_custom_note
          call nrt_timer_setup
run_fx_custom_note_no_reset
          ld (nrt_sp+1),hl
          ex af,af
          ld a,TM_MAX
      IF do_profile
          ld iy,nrt_fx
          call nrt_profile_check
      ELSE
          call nrt_fx
      END
          ret

nrt_fx
;-----
; Setup sp (cannot do it before for profile)
          SUB_TM(12)
          ld (ret_sp),sp
nrt_sp    ld sp,0
          ret           ; sync_buzzer_register or fx_end
; Might also jump back to fx_end (eg /stack1/)
nrt_ret
          SUB_TM(9)
          ld sp,(ret_sp)
          ret


run_set_timer_and_psg'
;---------------------
; Don't reset hl'
          ld hl,psg_regs
          ld b,14
untouched = &3F         ; avoid setting bit 6 for r7
.raz      ld (hl),untouched:inc l:djnz .raz

          call nrt_reset_msb
          xor a
      IF do_profile
          ld iy,set_timer_and_psg
          call nrt_profile_check_against_event
      ELSE
          call set_timer_and_psg
      END
          ret

run_set_timer_and_psg
;--------------------
; reset psg regs for accurate check
          ld hl,psg_regs
          ld b,14
untouched = &3F         ; avoid setting bit 6 for r7
.raz      ld (hl),untouched:inc l:djnz .raz

          call nrt_timer_setup
          ld hl,anchor_code:exx
       ;   ld a,MAX_TM
          xor a
      IF do_profile
          ld iy,set_timer_and_psg
          call nrt_profile_check
      ELSE
          call set_timer_and_psg
      END
          ret


run_set_psg_insert_and_program
;-----------------------------     
; reset psg regs for accurate check
; In: HL= event  (hl')
    ; DE= period  
          di
          ld bc,&F40E   ; reg14
          xor a         ; sanity (don't set bit 6 on reg 7)
      IF do_profile
; Cannot use nrt_profile_check (D' is used)
  ; - 'set_psg_insert_and_program' is meant to be in EXX already.
  ; - not interrupted 
  ; - A' is reloaded (TM until next event)
      ; -> if it is anchor event, shouldn't change anything
  ; - Time taken by routine isn't counted inside routine,
      ; but in event (cf set_reg13_insert_and_program_tm)
          ex af,af
tm_trigger = -1         ; simulate 
          ld a,tm_trigger
          ex af,af
;Acutally we profile from set_reg13_insert_and_program,
;as its timing is counted inconditionaly
          call profile_jp:WORD set_reg13_insert_and_program
          neg
          add a
;-3: final 'ret' not counted by profile
;-base_fx_tm: counted inconditionaly, but not executed here
          add tm_trigger*2-3 - base_fx_tm
          cp l:call nz,fail
          ld a,h:or a:call nz,fail ; shouldn't take more than 256 nops
      ELSE
          call set_psg_insert_and_program
      END
;Some common checks
          exx
          ld a,h:cp events/&0100:call nz,fail
          exx
          ret

trap
      BRK
; shouldn't have been called
          exx
          ret

nrt_timer_setup
; Reset nrt_msb_tm to 0 
  ; Needed for profiling as Instr routine might > 256 nops 
  ; Especially with dev_checks = 1 
; Set HL' (since we will jump into it)
; Preserve all registers
          di
          exx
          ld hl,timer_nop
          exx
        ;  call nrt_init_lists
;enchaine
nrt_reset_msb
          push af
          xor a:ld (nrt_msb_tm),a
          pop af
          ret
nrt_reset_msb_compensate
; We trigger event_anchor at the very start,
; which INC (nrt_msb_tm)
          push af
          ld a,-1:ld (nrt_msb_tm),a
          pop af
          ret

nrt_init_lists
;Normally done by ply preloop
          push hl
          ld a,MAX_TM   ; prevent triggering event
          call preplay
          pop hl
          ret

      IF do_profile

test_vsync
          call nrt_init
          ld iy,vsync_timed
          call nrt_profile_check
          ret

nrt_profile_check
;In: iy = routine to profile
   ; Can pass BC DE HL
   ; (we want to pass IX and HL, depending on the routine)
          ld (.jp),iy
          call nrt_reset_msb
          ex af,af
          ld a,MAX_TM
          call profile_jp
.jp   WORD 0
          neg
          add a
          add MAX_TM*2-3 ;-3: final 'ret' not counted by profile
          cp l:call nz,fail
          ld a,(nrt_msb_tm)
          cp h:call nz,fail
          ret


nrt_profile_check_against_event
;Same a nrt_profile_check but:
   ; set A to event cpt
          ld (.jp),iy
          exx
          ld (nrt_cur_event),hl
; !! No, must keep nrt_msb_tm for simulation
;          ld a,l:cp anchor+hdr_code AND &FF
;          push af:call z,nrt_reset_msb_compensate
;          pop af:call nz,nrt_reset_msb
          push hl
          hdr_code - hdr_cpt ** dec l
          ld a,(hl):ld (.ref_tm+1),a
          pop hl
          exx
          xor a         ; reset tm and force trigger
          call profile_jp
.jp   WORD 0
; A' was reset to "remaining time before next event"
; So time passed = next - current - remaining
          exx
          ex af,af
          ld a,l
          cp timer_nop AND &FF:jr z,.ok
          CHECK_EVENT_OFFSET(hdr_code)
.ok
          ex af,af
          neg
          push hl
          hdr_code-hdr_cpt ** dec l
          add (hl)
.ref_tm   sub 0
          pop hl
          exx
          add a
  ;  call c,fail   ; shouldn't happen as max rdv is &80
          add -3        ;-3: final 'ret' not counted by profile
          cp l:call nz,fail
;Too complicated to test. E.G. when at frontier of &80,
; anchor_event is called, increasing nrt_msb_tm.
; it doesn't mean the routine took > &100 nops 
 ;         ld a,(nrt_msb_tm)
 ;         cp h:call nz,fail
          ret
      END

nrt_cur_event WORD 

nrt_init
;-------     
          call init_timer
          jr _nrt_init_com

nrt_init_custom_clock
;--------------------
          call init_timer
; Clock doesn't have to be init explicitly, 
; since remaining in sync with anchor_pnt.
; Only setup for ref checking.
clock0 = &0146
          ld hl,clock0:ld (current_clock),hl
_nrt_init_com
          ld a,&55:call progress_bar
          SYNC_ANCHOR()
          call nrt_init_periods
; Not striclty needed, but ease testing.
          ld hl,events:ld (free_slot),hl
; Kill firmware: needed to setup exx' without interference
                 ; since profile temporarily EI.
               ; And we need to setup HL'
          ld hl,&C9FB:ld (&38),hl
; Must be done early because even preplay_init might trigger JP HL'
          ld hl,timer_nop
          exx
          ret

progress_bar
.progress ld hl,&C000:ld (hl),a:inc hl:ld (.progress+1),hl
          ret

      FILL -$ AND &FF,&F7
evtmarker0 FILL &0100,0
evtmarker1 FILL &0100,0

          LIMIT(ramlimit)

