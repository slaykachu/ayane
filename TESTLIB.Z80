; Common routines for tests 

; 2025
  ;Sep
   ; -- v0aq --
    ;26: psg_nrt: use PER_16_TO_12
   ; -- v0ap --
    ;17: memdisk_write_bloc: more flexible check_no_overrun 
       ; memdisk_read_bloc:  same
  ;Aug
   ; -- v0a? --
    ;24: Add CHECK_HL_EQUAL
    ; 9: memdisk_write_bloc: take BC = size (to match io_write_bloc)
    ; 8: init_for_test: call set_diapason
    ; 1: init_for_test: call setup_keys

tolerance = 4

      IMPORT "const.i"
      IMPORT "memmap.i"
      IMPORT "macro.i"

      IMPORT "memcpc.o" ; set_sp_backup
      IMPORT "chung.o"  ; Init_chung and instr setup
 ;      IMPORT "piano.o"
      IMPORT "timer.o"  ; init_timer/fx_end/sync_buzzer_register
      IMPORT "periods.o" ; init_periods, set_diapason
      SKIP -$ AND &FF
;      IMPORT "ply.o"  
      IMPORT "shortcut.o" ; setup_keys

;--------------------------
      MACRO CHECK_HL_EQUAL x
          push de
          ld de,x:or a:sbc hl,de:add hl,de:call nz,nrtfail
          pop de
      ENDM

;--------------------------

nrtfail = &BE00

compare_sized
          ld a,(de):cp (hl):call nz,&BE00
          inc hl:inc de
          dec bc
          ld a,c:or b
          jr nz,compare_sized
          ret

compare_regs
; Smart comparison of PSG regs:
; e.g. if channel closed, don't check periods
; In: hl = regs 0
   ;  de = regs 1

          push hl:pop ix
          push de:pop iy

      MACRO COMPARE_CHAN ch,chbit

          bit chbit,(ix+7):jr z,.open
          bit chbit,(iy+7):jr nz,.perok ; both closed
          ld a,(iy+ch):or a:jr z,.perok ; de: volume 0
          call nrtfail  ; mismatch

.open
          bit chbit,(iy+7):jr z,.openok
          ld a,(ix+ch):or a:jr z,.perok ; hl: volume 0
          call nrtfail  ; mismatch

.openok
          ld a,(ix+ch):cp (iy+ch):call nz,nrtfail
          ld a,(ix+ch):or a:jr z,.perok

; compare with allowed diff (since vibrato isn't exactly the same)

          push de:push hl
          ld c,(hl):inc hl:ld b,(hl)
          ex de,hl
          ld e,(hl):inc hl:ld a,(hl):and &0F:ld d,a
          ex de,hl
          or a
          sbc hl,bc:jr z,.perok_ ; 0 
          jr nc,.oksign
          ld c,l:ld b,h:ld hl,0:or a:sbc hl,bc ; neg hl
.oksign
;hl (diff) must be <= tolerance
          ex de,hl
          ld hl,tolerance
          or a:sbc hl,de
          call c,nrtfail

.perok_
          pop hl:pop de
.perok
          ld a,(iy+ch):or a:jr z,.noiseok ; de: volume 0

          bit chbit+3,(ix+7):jr z,.noise
          bit chbit+3,(iy+7):jr nz,.noiseok ; both closed
          call nrtfail  ; mismatch

.noise
          bit chbit+3,(iy+7):call nz,nrtfail
          ld a,(ix+6):cp (iy+6):call nz,nrtfail
.noiseok
      ENDM

          COMPARE_CHAN(8,0)

          inc hl:inc de
          inc hl:inc de

          COMPARE_CHAN(9,1)

          inc hl:inc de
          inc hl:inc de

          COMPARE_CHAN(10,2)

          inc hl:inc de
          inc hl:inc de

          ld a,(ix+7):rra
          or (ix+7):rra
          or (ix+7)
          bit 3,a:jr nz,cr_nono

          ld a,(de):cp (hl):call nz,&BE00
cr_nono

      5 ** [inc hl:inc de] ;6 to 11      
          ld a,(de):cp (hl):call nz,&BE00
          inc hl:inc de
          ld a,(de):cp (hl):call nz,&BE00
          inc hl:inc de
          ld a,(de):cp (hl):call nz,&BE00

          ret

psg_nrt
; For tests: send to psg
          di
          ex af,af
          push af
          exx
          push bc
          ld hl,timer_noop
          exx
; Maybe we could call set_timer_and_psg instead
          PER_16_TO_12()
          call psg
          pop bc
          exx
          pop af
          ex af,af
          ret

timer_noop
          exx
          ret


psg_read
; IN: hl: pnt buffer
          ld c,0
.lp
          call psg_read1
          ld (hl),a:inc hl
          inc c
          ld a,c
          cp 14
          jr c,.lp
          ret

psg_read1
;In:  C= register to read
;Out: A= value
    ; C preserved
          push bc
          ld b,&F4
          out (c),c
          ld bc,&F6C0
          out (c),c
          out (c),0
          ld bc,&F792
          out (c),c
          ld bc,&F640
          out (c),c
          ld a,&F4
          in a,(&FF)
          out (c),0
          ld bc,&F782
          out (c),c
          pop bc
          ret

memdisk_write_bloc
;!!! copy-pasted in org/ramdisk.o

;In: hl = source 
   ; bc = size (0 = no-op)
;Out: hl+= size
memdisk_pnt_w ld de,&C000
          call check_no_overrun_w
          push de
          ex de,hl:add hl,bc:ex de,hl:call c,nrtfail
          pop de
          call check_no_overrun_w
          ld a,b:or c
          scf
          ret z
          ldir
;Enchaine
memdisk_seek_write
;"seek" might be a stretch.
          ld (memdisk_pnt_w+1),de
          ret

check_no_overrun_w
          ld a,d
limit_lo_w cp 0:call c,nrtfail
limit_hi_w cp 0:call nc,nrtfail
          ret

check_no_overrun_r
          ld a,h
limit_lo_r cp 0:call c,nrtfail
limit_hi_r cp 0:call nc,nrtfail
          ret


memdisk_init_write
 ; IN: de = destination
     ;  a = max MSB + 1
          ld (limit_hi_w+1),a
          ld a,d:ld (limit_lo_w+1),a
          jr memdisk_seek_write

memdisk_load_bloc
;In: de = dest 
   ; bc = size !! not symetrical for now
;Out: de += size
memdisk_pnt_r ld hl,&C000
          call check_no_overrun_r
          push hl
          add hl,bc:call check_no_overrun_r
          pop hl
          ld a,b:or a:call nz,nrtfail ; not > &ff
          ld a,c:or a:call z,nrtfail ; not 0
          ldir
          scf
;Enchaine
memdisk_seek_read
          ld (memdisk_pnt_r+1),hl
          ret

memdisk_init_read
; IN: hl = source
          ld (limit_hi_r+1),a
          ld a,h:ld (limit_lo_r+1),a
          jr memdisk_seek_read

nrt_init_periods = init_periods ; pull label for timernrt.o

init_for_test
          call set_sp_backup ; root level - 2, nevermind
          call setup_keys
          call Init_chung
          call init_periods
 ;          call init_timer   ; done by piano
          ld hl,diapason_default
          call set_diapason
; replay_period init in Init_track_module
      IF todo
; Call Init_track_module?
; Or use full init at some point?
      END
          ret

dummy_instr
;----------
; !!! Do not change, as instrnrt expect this exact 3-rows instr.
; E.G. do not add loop.
          ld a,1        ; id (0 is reserved)
          ld c,0        ; nb params
          call New_instr_ayane
          xor a
          ld b,3
          ld de,row0
          call helper_setrows
          ret

dummy_instr_ui
;-------------
; For manual test in instrui.o
          ld a,1        ; id (0 is reserved)
dummy_instr_ui_id
; In: A = instr id
          ld c,0        ; nb params
          call New_instr_ayane
          xor a
          ld b,1
.lp
          push bc
          push af
          ld de,row2_sync
          call helper_setrow
          pop af
          inc a
          pop bc
          djnz .lp
          push af
          ld de,row2_sync
          call helper_setrow
          pop af
          ld b,a:dec b:call instr_set_loop
          ret

dummy_instr_sync
;---------------
; 1 row with sync buzeer for plynrt
          ld a,1        ; id (0 is reserved)
          ld c,0        ; nb params
          call New_instr_ayane
          xor a
          ld b,2
          ld de,row0
          call helper_setrows
          ld de,row2_ui
          call helper_setrow
          ret

helper_setrow
;In: a = start row 
   ;de = data row
          ld b,1
helper_setrows
;In: a = start row 
   ; b = rows#
   ;de = data row
;Out:a += b 
          push af
          push bc
          push de
          push de
          push af
          call insert_empty_row
          pop af
          call select_row
          pop de
          call set_row
          pop de
          ld hl,instr_row_size_max
          add hl,de
          ex de,hl
          pop bc
          pop af
          inc a
          djnz helper_setrows
          ret


row0  BYTE 0:WORD 0:BYTE &38,0
          VOL(15)
      FILL fx0_type - [$-row0],0
      WORD fx_null
      FILL instr_fx_size-2,0
      WORD fx_null
      FILL instr_fx_size-2,0
      WORD fx_end
      IF instr_row_size_max - [$-row0]
 !!! incomplete
      END

row1  BYTE 12*2:WORD 0:BYTE &38,0 ; Arpege +12
          VOL(13)
      FILL fx0_type - [$-row1],0
      WORD fx_null
      FILL instr_fx_size-2,0
      WORD fx_null
      FILL instr_fx_size-2,0
      WORD fx_end
      IF instr_row_size_max - [$-row1]
 !!! incomplete
      END


; for nrt: don't touch values
flags = &00             ; noise
hard_env_type = 10
hard_arp = 7
hard_pitch = 20
sync_pitch = 10
sync_env_type = 3       ; same a 0: \_____
sync_arp = 12

; for instrui manual testing
flags_ui = &38          ; no noise
hard_env_type_ui = 10
hard_arp_ui = 0
hard_pitch_ui = 0
sync_pitch_ui = 0
sync_env_type_ui = 4    ; /|______
sync_arp_ui = 0

row2  BYTE 0:WORD 0:BYTE flags,3 ; Noise
          VOL_HARD()    ; Hard env 
      BYTE hard_env_type
      BYTE hard_arp * 2
      WORD hard_pitch
      IF fx0_type - [$-row2]
   !! error align
      END
.syncbuzzer0
      WORD sync_buzzer_register
      BYTE sync_env_type
      BYTE sync_arp*2
      WORD sync_pitch
      IF $-.syncbuzzer0 - instr_fx_size
   !! missing fields
      END
      WORD fx_null
      FILL instr_fx_size-2,0
      WORD fx_end
      IF instr_row_size_max - [$-row2]
 !!! incomplete
      END

row2_ui
      BYTE 0:WORD 0:BYTE flags_ui,3 ; 
          VOL_HARD()    ; Hard env 
      BYTE hard_env_type_ui
      BYTE hard_arp_ui * 2
      WORD hard_pitch_ui
      IF fx0_type - [$-row2_ui]
   !! error align
      END
.syncbuzzer0
      WORD sync_buzzer_register
      BYTE sync_env_type_ui
      BYTE sync_arp_ui*2
      WORD sync_pitch_ui
      IF $-.syncbuzzer0 - instr_fx_size
   !! missing fields
      END
      WORD fx_null
      FILL instr_fx_size-2,0
      WORD fx_end
      IF instr_row_size_max - [$-row2_ui]
 !!! incomplete
      END

row2_sync
; same as row2_ui but we want to be able to change the former
      BYTE 0:WORD 0
;:BYTE flags_ui,3 ; 
      BYTE &3F,3
          VOL_HARD()    ; Hard env 
      BYTE hard_env_type_ui
      BYTE hard_arp_ui * 2
      WORD hard_pitch_ui
      IF fx0_type - [$-row2_sync]
   !! error align
      END
.syncbuzzer0
      WORD sync_buzzer_register
      BYTE sync_env_type_ui
      BYTE 0            ; sync_arp_ui*2
;      WORD sync_pitch_ui
      WORD 0
  ;    WORD 3            ; C3 = &1ddd. +3 = &1de0 -> mustn't dephase
;      WORD &2700 - &1DDD ; exaclty 3 halt
;      WORD &1A00 - &1DDD + &40 ; exaclty 2 halt + 1 line
;      WORD &4E00 - &1DDD + &07 ; 1 frame + 1/2 line
      IF $-.syncbuzzer0 - instr_fx_size
   !! missing fields
      END
      IF 1
      WORD fx_null
      FILL instr_fx_size-2,0
      ELSE
      WORD sync_buzzer_register
      BYTE sync_env_type_ui
      BYTE 0
      WORD 1
      END
      WORD fx_end
      IF instr_row_size_max - [$-row2_sync]
 !!! incomplete
      END



