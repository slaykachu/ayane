; ----- Manual test of phrase editor -----
do_nrt = 0              ; 0: manual test
dev_checks' = 1
use_testlib = 0         ; 1: with instr, but mem full with track
short_phrase = 1 OR do_nrt ; 1: exercise implicit repeat

; 2025
  ; -- Alpha 1 --
  ; Dec
      ;17: Move phrasui in BK_DISP
      ;16: Add test_fuzz
      ;13: Add test_refresh_page 
      ;12: Add test_next_page
         ; Add test_kcdwn
         ; Add test_kcup
         ; Add test_up_to_prev_phrase

nrtfail = &BE00

      IMPORT "memmap.i"
      IMPORT "const.i"  ; kesc
      IMPORT "macro.i"
      IMPORT "import.i"

      ORG code_start
      IF do_nrt
      ENT tests
      ELSE
      ENT start
      END

;to do first    
          IMPORT_PHRASUI_DEPS()
      ORG shortcut
      IMPORT "shortcut.o" ; setup_keys

      IF use_testlib
      IMPORT "testlib.o" ; for dev test
      END
      BANK BK_DISP
    ;      LOAD_FONTS()  ; no need all fonts RN
.save
      ORG fonte_small:LOAD "fntsmall.bin"
      ORG phrasui:IMPORT "phrasui.o"
      ORG .save
          IMPORT_DISP() ; phradisp expect deps to be imported
;      ORG bandaya_end

;---------------------------
      MACRO CALL_DISP_BK adr
; When caller out of bank
          ASSERT($ AND &C000 != &4000)
   ;       ASSERT(adr AND &C000 == &4000) (cannot check: forward ref)
          call call_disp:WORD adr
      ENDM
;---------------------------

start
          ld a,2:call &BC0E
          call dev_setup
.lp
          call km_wait_key
          CALL_DISP_BK(phrase_ui_process)
          jr c,.lp
          cp kesc
          jr nz,.lp
          ret


dev_setup
      IF use_testlib
          call init_for_test
          call dummy_instr_ui
      ELSE
          call setup_keys
          call Init_chunk_module
          call Init_track_module
      END
          call phrase_reset
          xor a:call song_select_new_phrase
note1 = &14             ; G#1
note2 = &26             ; D-2
      IF short_phrase
nrt_phrase0_dur = delai_ui_default*4
nrt_phrase1_dur = delai_ui_default*8
          ld a,nrt_phrase0_dur
      ELSE
          ld a,0
      END
          call phrase_select_new_row:call nc,fail
          ld a,note1:call row_set_note
          ld a,1:call row_set_instr
          ld de,delai_ui_default:call phrase_select_row_at
          ld a,note1+1:call row_set_note
          ld a,&0F:call row_set_vol
      IF short_phrase
          ld de,delai_ui_default*2+2:call phrase_select_row_at
          ld a,note2:call row_set_note
      ELSE
          ld de,delai_ui_default*16+2:call phrase_select_row_at
          ld a,note2:call row_set_note
      END
          ld a,1:call Song_select_new_track
          xor a:ld hl,time0:call Set_phrase_at_t

          ld a,1:call song_select_new_phrase
note3 = &34
          ld a,nrt_phrase1_dur
          call phrase_select_new_row:call nc,fail
          ld a,note3:call row_set_note
          ld a,2:call Song_select_new_track
          ld a,1:ld hl,time0:call Set_phrase_at_t

          ld a,2:call song_select_new_phrase
note4 = &43
          ld a,200      ; no repeat
          call phrase_select_new_row:call nc,fail
          ld a,note4:call row_set_note
          ld a,3:call Song_select_new_track
          ld a,2:ld hl,time0:call Set_phrase_at_t

          ld a,BK_DISP:call connect_a ; for checks against phrasui's var
          CALL_DISP_BK(phrase_cold_refresh)
          ret

      IF do_nrt
; -----------------------------
      MACRO TEST_RUN test_data
; Adapted from gednrt 
;test_data consist in:
  ; input (mocked) key sequence
  ; expected text displayed
  ; (removed!!!) Expected cursor sequence
          ld de,test_data
          call _test_run
      ENDM

      MACRO RESET_NRT_MOCK
  ; For now, simply put cursor in top left of mocked screen
          call _reset_nrt_mock
      ENDM

      MACRO END_OF_NRT_SEQUENCE
 ; We use 0 as a sentinelle, as it is not a valid code.
sentinelle = 0
      BYTE sentinelle
      ENDM

      MACRO NRT_FOCUS x
      BYTE x+&80
      ENDM

      MACRO CHECK_CURSOR x,y
          ld de,x*&0100 + y
          call check_cursor
      ENDM

; -----------------------------

tests
          ld a,&F7:ld (0),a
          call test_refresh_state
          call test_refresh_page
          call test_row_dwn_to_repeated_phrase
          call test_up_at_top
          call test_up_to_prev_phrase
          call test_kcdwn
          call test_kcdwn'
          call test_kcup
          call test_next_page
          call test_prev_page
          call test_fuzz
          ret

test_refresh_state
;Check time_end set-up
          call dev_setup ; will call refresh_state at time 0
          ld hl,(time_at_top):ld a,l:or h:call nz,nrtfail
          ld hl,(time_end)
          ld de,nrt_phrase0_dur
          or a:sbc hl,de:add hl,de:call nz,nrtfail
          ret

test_refresh_page
; Test when time_at_top > 0
          call dev_setup
          ld hl,time6:ld de,time_at_top:call copy_time
; Focus at top, since refresh_page doesn't use nrt hooks for display
          ld hl,time6:ld de,time_cur:call copy_time
          CALL_DISP_BK(refresh_page)
          TEST_RUN(.seq)
          ret

.seq
      BYTE krgt,klft    ; trigger refresh
          END_OF_NRT_SEQUENCE()
 ; hm, no focus? no sure why
    ;      NRT_FOCUS("A")
    ;      NRT_FOCUS("-")
    ;      NRT_FOCUS("1")   
      BYTE "A-1"
      BYTE nrtend

test_row_dwn_to_repeated_phrase
;Go past phrase
;Prerequisite: test_time_at_top_updated
          call dev_setup
          TEST_RUN(.seq)
          CHECK_CURSOR(4,nrt_phrase0_dur + 1)
;goto 2nd row 
          TEST_RUN(.seq')
          CHECK_CURSOR(4,nrt_phrase0_dur + delai_ui_default + 1)
          call row_get_note:call z,nrtfail
          cp note1+1:call nz,nrtfail
;goto 1st row of next repetition
          TEST_RUN(.seq'')
          CHECK_CURSOR(4,nrt_phrase0_dur*2 + 1)
          call row_get_note:call z,nrtfail
          cp note1:call nz,nrtfail
          ret

.seq  FILL 5,kdwn
          END_OF_NRT_SEQUENCE()
      BYTE "G#1"        ; Only note was refreshed
      FILL delai_ui_default,nrt_nl
      BYTE "A-1"
      FILL delai_ui_default,nrt_nl
      BYTE "---"        ; empty row
      FILL 2,nrt_nl     ; non-aligned
      BYTE "D-3"
      FILL delai_ui_default-2,nrt_nl
      BYTE "---"
      FILL delai_ui_default,nrt_nl
          NRT_FOCUS("G")
          NRT_FOCUS("#")
          NRT_FOCUS("1")
      BYTE nrtend

.seq' BYTE kdwn
          END_OF_NRT_SEQUENCE()
      BYTE nrtend       ; don't check display this time

.seq'' FILL 5-1,kdwn
          END_OF_NRT_SEQUENCE()
      BYTE nrtend

test_up_at_top
;If already at top: no-op 
          call dev_setup
          TEST_RUN(.seq)
          CHECK_CURSOR(4,1)
          call row_get_note:call z,nrtfail
          cp note1:call nz,nrtfail
          ret

.seq  BYTE kup
          END_OF_NRT_SEQUENCE()
      BYTE nrtend

test_up_to_prev_phrase
;Go to previous 
;Prerequisite: test_row_dwn_to_repeated_phrase
          call dev_setup
          TEST_RUN(.seq)
          CHECK_CURSOR(4,delai_ui_default*3 + 1)
          ld a,(row_exists):or a:call nz,nrtfail
          ret

.seq  FILL 5,kdwn:BYTE kup
          END_OF_NRT_SEQUENCE()
      BYTE nrtend

test_kcdwn
;DOWN+CONTROL-DOWN: go 17*delai_ui down
          call dev_setup
          TEST_RUN(.seq)
          CHECK_CURSOR(4,delai_ui_default*17 + 1)
          ld a,(row_exists):or a:call z,nrtfail
          ld a,(is_first_iter):or a:call nz,nrtfail
          call row_get_note:call z,nrtfail
          cp note1+1:call nz,nrtfail
          ret

.seq  BYTE kdwn,kcdwn
          END_OF_NRT_SEQUENCE()
      BYTE nrtend

test_kcdwn'
;2 * CONTROL-DOWN
          call dev_setup
          TEST_RUN(.seq)
          CHECK_CURSOR(4,delai_ui_default*32 + 1)
          ld a,(row_exists):or a:call z,nrtfail
          ld a,(is_first_iter):or a:call nz,nrtfail
          call row_get_note:call z,nrtfail
          cp note1:call nz,nrtfail
          ret

.seq  FILL 2,kcdwn
          END_OF_NRT_SEQUENCE()
      BYTE nrtend


test_kcup
;DOWN + CTRL-DOWN + CTRL-UP: go delai_ui down
          call dev_setup
          TEST_RUN(.seq)
          CHECK_CURSOR(4,delai_ui_default + 1)
          ld a,(row_exists):or a:call z,nrtfail
          ld a,(is_first_iter):or a:call z,nrtfail
          call row_get_note:call z,nrtfail
          cp note1+1:call nz,nrtfail
          ret

.seq  BYTE kdwn,kcdwn,kcup
          END_OF_NRT_SEQUENCE()
      BYTE nrtend

test_next_page
; Past view: go to next page
          call dev_setup
          TEST_RUN(.seq)
; View shift: 32 rows. 
          CHECK_CURSOR(4,[3*16 MOD 32]*delai_ui_default + 1)
          ld a,(row_exists):or a:call z,nrtfail
          ld a,(is_first_iter):or a:call nz,nrtfail
          call row_get_note:call z,nrtfail
          cp note1:call nz,nrtfail
          ret

.seq  FILL 3,kcdwn
          END_OF_NRT_SEQUENCE()
;cannot check: focus on line 48 mod 32 = 16
             ; disp doesn't use hooks
      BYTE nrtend

test_prev_page
          call dev_setup
          TEST_RUN(.seq)
          CHECK_CURSOR(4,1)
          ld a,(row_exists):or a:call z,nrtfail
          ld a,(is_first_iter):or a:call z,nrtfail
          call row_get_note:call z,nrtfail
          cp note1:call nz,nrtfail
          ret

.seq  FILL 3,kcdwn
      FILL 3,kcup
          END_OF_NRT_SEQUENCE()
      BYTE nrtend

test_fuzz
          call dev_setup
keys_buffer = tmp_buf
          ld ix,.keys
          ld iyl,15
          call fuzz_keys
; Just check it doesn't assert
          TEST_RUN(keys_buffer)
          ret
.keys
      BYTE klft,krgt,"A",kcdel
      BYTE "0",kcup,kcdwn,kup
      BYTE kcf+0,kcfdot,kdwn,kclr
      BYTE kclft,kcrgt," 1"

; -----------------------------

_test_run
;Adapted from gednrt
          ld (nrt_sequence_pnt),de

          call nrt_cls  ; TODO? Also clean sprite/cursor?

          call gedeihen_set_hooks_nrt
          RESET_NRT_MOCK()
    ;      call setup_widget
    ;      call gedeihen_disp
    ;      pop hl

     ;     call nrt_enter

          call nrt_gedeihen_loop

; Check our fake screen is filled with expected first line.
          ld de,(nrt_sequence_pnt) ; expected display
          call compare_display_focus
          ret

fuzz_keys
;In: ix: keys to test 
   ; iyl: nb keys - 1
          ld b,256-2    ; &8100 overwritten by ged?
          ld hl,0
          ld de,keys_buffer
.prep
          push bc
          push de
          push hl
;pseudo-random
          rlca:add l:xor (hl)
          push af

          and iyl:add ixl:ld l,a
          ld a,ixh:ld h,a
          jr nc,$+3:inc h
          ldi

          pop af
          pop hl
          pop de
          pop bc
          inc hl
          inc de
          djnz .prep

          ld a,sentinelle:ld (de),a:inc de
; don't check screen output
          ld a,nrtend:ld (de),a
          ret

; ==============================
nrt_cls
          push hl
          ld hl,iotest_screen
          ld de,iotest_screen+1
          ld bc,nrt_screen_ - 1
          ld (hl),mockspace
          ldir
          pop hl
          ret

_reset_nrt_mock
          push hl
          ld hl,&0101:ld (iotest_cursor),hl
          pop hl
          ret

gedeihen_set_hooks_nrt
; out: hl preserved
          push hl
          ld hl,nrt_set_cursor
          ld ix,nrt_get_cursor
          ld iy,nrt_place_cursor
          ld de,nrt_write_char
          ld bc,nrt_paint_sprite
          call gedeihen_set_hooks
          pop hl
          ret

nrt_gedeihen_loop
          call nrt_read_key ;Always return a key.
          cp sentinelle:ret z

          CALL_DISP_BK(phrase_ui_process)
          jr nrt_gedeihen_loop


nrt_read_key
          ld hl,(nrt_sequence_pnt)
          ld a,(hl):inc hl
          ld (nrt_sequence_pnt),hl
          scf
          ret

scr_hw_roll
      BRK
;TODO (for now scrolling is not triggered in tests)


nrt_set_cursor
; Cursor is 1-indexed      
          ld a,h:or a:call z,fail
          cp 80:call nc,fail
          ld a,l:or a:call z,fail
          cp nrt_height:call nc,fail
          ld (iotest_cursor),hl
          ld hl,&CACA   ; mimic firmware trashing hl
          scf
          ret

nrt_get_cursor
          ld hl,(iotest_cursor)
          ret

nrt_wrapped_cursor
; We lack room in RAM, so wrap.
; We only check the first few lines anyway
          ld hl,(iotest_cursor)
          push af
          ld a,l
          dec a:and nrt_height' - 1:inc a
          ld l,a
          pop af
          ret

iotest_get_char_pnt
;Mimic a screen nrt_width x nrt_height
;in:  hl:as in txt_set_cursor
;out: hl:pointer in mimiced screen buffer. 
          push de
          dec h:dec l   ; From 1-based to 0 based
          ld e,h:ld d,0 ;col
nrt_width = 16
nrt_height = 200
nrt_height' = 64
nrt_screen_ = nrt_width * nrt_height'
      IF nrt_width - 16
         !! fixme
      END
          ld h,d:4 ** add hl,hl ; row * 16
          add hl,de
          ld de,iotest_screen:add hl,de
          call iotest_check_cursor_pos
          pop de
          ret


iotest_check_cursor_pos
; Sanity checks.
; hl >= iotest_screen
          push de
          ld de,iotest_screen
          or a:sbc hl,de:add hl,de:call c,&BE00
; hl < iotest_screen+&800
          ld de,iotest_screen + nrt_screen_
          or a:sbc hl,de:add hl,de:call nc,&BE00
          pop de
          ret

nrt_place_cursor
          push hl
          call nrt_wrapped_cursor
          call iotest_get_char_pnt
;      BRK
      IF 1
; Dev: see if doublon on focus
          bit 7,(hl):call nz,&BE00
      END
; Switch to mimic firmware
          ld a,(hl):xor &80:ld (hl),a
          pop hl
          ret

nrt_write_char
; API: cf write_char
          push hl
          call nrt_wrapped_cursor
          call iotest_get_char_pnt
      IF 0
;for debug
          push af
          ld a,l
          cp 2:call nc,&BE00
          pop af
      END
          ld (hl),a

          ld hl,iotest_cursor+1
          inc (hl):call z,&BE00 ; TODO: new line
          pop hl
          scf
          ret

nrt_paint_sprite
          call &BE00

compare_display_focus
          ld ixl,&FF
          jr _compare
compare_display
          ld ixl,&7F    ; to remove focus flag
_compare
; Check our fake screen is filled with expected strings.
; (Focus isn't checked)
; In: DE = ref
          ld hl,iotest_screen
; Compare zone at HL and DE until nrt_end met in expected
; Ie don't check the rest
.comp
          ld a,(de)
          cp nrtend:ret z
          cp nrt_nl:jr nz,.no_nl
;go to next line in mock screen
          ld a,l
      IF nrt_width AND [nrt_width-1]
  !! must be power of 2
      END
          and &FF XOR [nrt_width-1] ; go to start of line
          add nrt_width ; next_line
          ld l,a
          jr nc,$+3:inc h
          inc de
          jr .comp

.no_nl
          xor (hl)
          and ixl       ; no-op or remove focus flag
          call nz,fail
          inc de:inc hl
          jr .comp

check_cursor
          ld hl,(iotest_cursor)
          or a:sbc hl,de:add hl,de:call nz,nrtfail
          ret

mockspace = 0           ; Make it easier to analyze iotest_screen
nrtend = &FF
nrt_nl = 13

nrt_sequence_pnt WORD 
iotest_cursor WORD &0101 ; As txt_set_cursor H=column L=line (1-based)

      SKIP -$ AND &FF
iotest_screen SKIP nrt_screen_

      END

time0     TIME(0)
time6     TIME(6)

ho
          LIMIT(ramlimit)

; Ensure sync with ayalib
          ASSERT(memcpc_code == memcpc)
          ASSERT(scankey_code == scankey)
          ASSERT(conv_code == conv)
          ASSERT(chunk_code == chunk_module)
          ASSERT(instr_code == instr_module)
          ASSERT(piano_code == piano)
          ASSERT(phrase_code == phrase)
; Ensure sync with ayane
          ASSERT(field_editor == field_module)
          ASSERT(phrasui_code == phrasui)
; Ensure sync with salo
          ASSERT(track_code == track_module)

      BANK BK_DISP
      SAVE "ayaphras.bin",phrasui,phrasui_end-phrasui

