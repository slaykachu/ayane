; <<< Conv. Conversions >>>
            ; (well, just str->int for now)
                        ; int->str 

fail  = &BE00

; !!TODO!!: remove put_* from disp.o

; TOC:             
   ; From string to integer:
     ; deci_to_int
     ; deci_to_byte

   ; From integer to string:
     ; put_deci_a  
     ; put_deci_hl 
     ; put_hexa_a  
     ; put_hexa_hl

; ========================================
deci_to_byte
; Convert string (in decimal) to byte "12" -> 12
; Carry if ok
          push de
          call deci_to_int
          ld a,d:or a:jr z,.ok
          inc a:jr nz,.ko ; accept negative as well (d=&ff)
.ok
          scf
.ko
          ld a,e
          pop de
          ret

deci_to_int
; Convert string (in decimal) to int "1234" -> 1234
;
; IN  : HL = buffer de la chaine
; OUT : If ok, Carry, DE = d{cimal 16 bit
      ; HL = post str
      ; BC conserved.

          ld a,(hl):or a:ret z ; Buffer vide?
          xor a
          ld e,a:ld d,a
; Check le signe
          ld a,(hl)
          cp "-":jr nz,$+3:inc hl ; skip and set FZ.
          push af
          cp "+":jr nz,$+3:inc hl ; just to skip it
; Conversion
ConvertLP
          ld a,(hl)
          sub "0":ccf:jr nc,.ko ; NC if invalid
          cp 9+1:jr nc,.ko ; NC if invalid
; Valeur = valeur fois 10
          push hl
          ex de,hl
          add hl,hl
          ld e,l
          ld d,h
          add hl,hl
          add hl,hl
          add hl,de
; Ajoute le prochain nombre
          ld e,a
          ld d,0
          add hl,de
          ex de,hl
          pop hl
          inc hl
          ld a,(hl):or a
          jr nz,ConvertLP

; Conversion compl}te
          pop af
          scf
          ret nz

;minus sign: de := -de
          push hl
          xor a         ; for nc
          ld l,a:ld h,a
          sbc hl,de
          ex de,hl
          pop hl
          scf
          ret

.ko
          pop de        ; discard AF flag sign
          ld de,0       ; prevents assert in deci_to_byte
          ret

put_hexa_hl
          push af
          ld a,h:call put_hexa_a
          ld a,l:call put_hexa_a
          pop af
          ret

put_hexa_a
          push af
          call put_hexa_qh
          pop af
          push af
          call put_hexa_ql
          xor a
          ld (de),a
          pop af
          ret


put_hexa_qh
          rrca
          rrca
          rrca
          rrca
put_hexa_ql
          and &0F
          or a
          daa
          add &F0
          adc &40
          ld (de),a
          inc de
          ret

;
put_deci_hl_signed
          ld a,l:or h   ; zero: no sign
          jr z,put_deci_hl
          ld a,"+"
          bit 7,h
          jr z,.ok
          ld a,"-"
; "neg hl"
          push de
          ex de,hl:ld hl,0:sbc hl,de ; nc from above
          pop de
.ok
          ld (de),a
          inc de
put_deci_hl
;Convert "hl" en decimal
;No justification.

;In: hl = value
   ; de = buffer to write string.        
          push hl
          push bc
          ld bc,10000
          call pwfigno0
          ld bc,1000
          jr nz,pwdec4
          call pwfigno0
          ld bc,100
          jr nz,pwdec3
          call pwfigno0
          ld a,l
          ld b,10
          jr nz,ddec100
          jr put_dec_
pwdec4
;>=10000 il faut afficher nombre des 1000
;
          call pwfig
          ld bc,100
pwdec3
          call pwfig
          ld a,l
          ld b,10
          jr ddec100
;
pwfig
          xor a
pwfigwf
          inc a
          or a
          sbc hl,bc
          jr nc,pwfigwf
;
          add hl,bc
          dec a
          or &30
          ld (de),a
          inc de
          ret
;
pwfigno0
          xor a
pwfn0wf
          inc a
          or a
          sbc hl,bc
          jr nc,pwfn0wf
          add hl,bc
          dec a
          ret z
;
          or &30
          ld (de),a
          inc de
          or &30        ;force nz
          ret
;
put_deci_a_signed
          or a          ; zero : no sign
          jr z,put_deci_a
          ex de,hl
          ld (hl),"+"
          or a
          jp p,.ok
          ld (hl),"-"
          neg
.ok
          inc hl
          ex de,hl
; enchaine
put_deci_a
          push hl       ;not modified, but must mimic put_deci_hl
          push bc
          ld b,100
          call dpfigno0
          ld b,10
          jr nz,ddec100
put_dec_
          call dpfigno0
          jr ddecunit
ddec100
;>=100 il faut afficher nombre des dizaines
;
          call dpfig
ddecunit
          or &30
          ld (de),a
          inc de
          xor a
          ld (de),a
          pop bc
          pop hl
          ret
dpfig
          ld c,-1
dpfigwf
          inc c
          sub b
          jr nc,dpfigwf
          add b
          ld b,a
          ld a,c
          or &30
          ld (de),a
          inc de
          ld a,b
          ret
;
dpfigno0
          ld c,-1
dpfn0wf
          inc c
          sub b
          jr nc,dpfn0wf
          add b
          ld b,a
          ld a,c
          and a
          jr z,dpfn0ret
;
          or &30
          ld (de),a
          inc de
          or &30        ;force nz
dpfn0ret
          ld a,b
          ret

      IF 0
; not used right now
put_bin_l
          ld h,0
put_bin_hl
          ld a,"%"
          call put_a
          ld a,l
          or h
          ld a,"0"
          jp z,put_a
          ld b,17
eat_0s
          dec b
          add hl,hl
          jr nc,eat_0s
pb_lp     ld a,0
          adc "0"
          call put_a
          add hl,hl
          djnz pb_lp
          ret
      END
