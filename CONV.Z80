; <<< Conv. Conversions >>>

fail  = &BE00

; !!TODO!!: remove put_* from disp.o

; //// 2025 ////
; -- alpha 1--
;Nov
  ; 27: Add put_deci_a_pad_space
  ; 17: put_note: save hl
; -- v0am --
;Aug      
  ; 24: Add convert_note, put_note, put_double_space


; TOC:             
   ; From string to integer:
     ; deci_to_int
     ; deci_to_byte

   ; From integer to string:
     ; put_deci_a  
     ; put_deci_hl 
     ; put_hexa_a  
     ; put_hexa_hl

   ; Misc
     ; convert_note

conv_code
; ========================================
deci_to_byte
; Convert string (in decimal) to byte "12" -> 12
; Carry if ok
          push de
          call deci_to_int
          ld a,d:or a:jr z,.ok
          inc a:jr nz,.ko ; accept negative as well (d=&ff)
.ok
          scf
.ko
          ld a,e
          pop de
          ret

deci_to_int
; Convert string (in decimal) to int "1234" -> 1234
;
; IN  : HL = buffer de la chaine
; OUT : If ok, Carry, DE = d{cimal 16 bit
      ; HL = post str
      ; BC conserved.

          ld a,(hl):or a:ret z ; Buffer vide?
          xor a
          ld e,a:ld d,a
; Check le signe
          ld a,(hl)
          cp "-":jr nz,$+3:inc hl ; skip and set FZ.
          push af
          cp "+":jr nz,$+3:inc hl ; just to skip it
; Conversion
ConvertLP
          ld a,(hl)
          sub "0":ccf:jr nc,.ko ; NC if invalid
          cp 9+1:jr nc,.ko ; NC if invalid
; Valeur = valeur fois 10
          push hl
          ex de,hl
          add hl,hl
          ld e,l
          ld d,h
          add hl,hl
          add hl,hl
          add hl,de
; Ajoute le prochain nombre
          ld e,a
          ld d,0
          add hl,de
          ex de,hl
          pop hl
          inc hl
          ld a,(hl):or a
          jr nz,ConvertLP

; Conversion compl}te
          pop af
          scf
          ret nz

;minus sign: de := -de
          push hl
          xor a         ; for nc
          ld l,a:ld h,a
          sbc hl,de
          ex de,hl
          pop hl
          scf
          ret

.ko
          pop de        ; discard AF flag sign
          ld de,0       ; prevents assert in deci_to_byte
          ret

put_hexa_hl
          push af
          ld a,h:call put_hexa_a
          ld a,l:call put_hexa_a
          pop af
          ret

put_hexa_a
          push af
          call put_hexa_qh
          pop af
          push af
          call put_hexa_ql
          xor a
          ld (de),a
          pop af
          ret


put_hexa_qh
          rrca
          rrca
          rrca
          rrca
put_hexa_ql
          and &0F
          or a
          daa
          add &F0
          adc &40
          ld (de),a
          inc de
          ret

;
put_deci_hl_signed
          ld a,l:or h   ; zero: no sign
          jr z,put_deci_hl
          ld a,"+"
          bit 7,h
          jr z,.ok
          ld a,"-"
; "neg hl"
          push de
          ex de,hl:ld hl,0:sbc hl,de ; nc from above
          pop de
.ok
          ld (de),a
          inc de
put_deci_hl
;Convert "hl" en decimal
;No justification.

;In: hl = value
   ; de = buffer to write string.        
          push hl
          push bc
          ld bc,10000
          call pwfigno0
          ld bc,1000
          jr nz,pwdec4
          call pwfigno0
          ld bc,100
          jr nz,pwdec3
          call pwfigno0
          ld a,l
          ld b,10
          jr nz,ddec100
          jr put_dec_
pwdec4
;>=10000 il faut afficher nombre des 1000
;
          call pwfig
          ld bc,100
pwdec3
          call pwfig
          ld a,l
          ld b,10
          jr ddec100
;
pwfig
          xor a
pwfigwf
          inc a
          or a
          sbc hl,bc
          jr nc,pwfigwf
;
          add hl,bc
          dec a
          or &30
          ld (de),a
          inc de
          ret
;
pwfigno0
          xor a
pwfn0wf
          inc a
          or a
          sbc hl,bc
          jr nc,pwfn0wf
          add hl,bc
          dec a
          ret z
;
          or &30
          ld (de),a
          inc de
          or &30        ;force nz
          ret

put_deci_a_pad0
; for 00-99 deci: add 0 if < 10
          ex de,hl:ld (hl),"0"
          jr put_deci_a_pad_

put_deci_a_pad_space
; for 00-99 deci: add space if < 10
          ex de,hl:ld (hl)," "
put_deci_a_pad_
          ex de,hl
          cp 10:jr nc,put_deci_a
          inc de
          jr put_deci_a

put_deci_a_signed
          or a          ; zero : no sign
          jr z,put_deci_a
          ex de,hl
          ld (hl),"+"
          or a
          jp p,.ok
          ld (hl),"-"
          neg
.ok
          inc hl
          ex de,hl
; enchaine
put_deci_a
          push hl       ;not modified, but must mimic put_deci_hl
          push bc
          ld b,100
          call dpfigno0
          ld b,10
          jr nz,ddec100
put_dec_
          call dpfigno0
          jr ddecunit
ddec100
;>=100 il faut afficher nombre des dizaines
;
          call dpfig
ddecunit
          or &30
          ld (de),a
          inc de
          xor a
          ld (de),a
          pop bc
          pop hl
          ret
dpfig
          ld c,-1
dpfigwf
          inc c
          sub b
          jr nc,dpfigwf
          add b
          ld b,a
          ld a,c
          or &30
          ld (de),a
          inc de
          ld a,b
          ret
;
dpfigno0
          ld c,-1
dpfn0wf
          inc c
          sub b
          jr nc,dpfn0wf
          add b
          ld b,a
          ld a,c
          and a
          jr z,dpfn0ret
;
put_a_deci_digit
          or &30
          ld (de),a
          inc de
          or &30        ;force nz
dpfn0ret
          ld a,b
          ret

put_double_space
          ex de,hl
          ld (hl)," ":inc hl
          ld (hl)," ":inc hl
          ex de,hl
          ret

put_note
;-------
;in a: Encoded note
  ;de: Buffer
;out: de past written note
    ;  a preserved
    ; bc thrashed
          push af:push hl
          call convert_note
          ld l,a
          add a:add l
          add notes_text AND &FF:ld l,a
          ld h,notes_text/&0100
          ldi:inc bc
          ldi:inc bc
          ld a,c
          call put_a_deci_digit
          pop hl:pop af
          ret

convert_note
;in a: Encoded note
;out c: Octave (note/12)
   ; a: note % 12 
          ld c,-1
.lp
          inc c
          sub 12
          jr nc,.lp
          add 12
          ret


notes_text
      BYTE "C-",0
      BYTE "C#",0
      BYTE "D-",0
      BYTE "D#",0
      BYTE "E-",0
      BYTE "F-",0
      BYTE "F#",0
      BYTE "G-",0
      BYTE "G#",0
      BYTE "A-",0
      BYTE "A#",0
      BYTE "B-",0
      IF $/&0100 - notes_text/&0100
 !! error align
      END


