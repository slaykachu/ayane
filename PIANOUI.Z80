; <<<<< Display piano (shading and stuff) >>>>>
; 2025 Aug 24 Add disp_note

hei   = 15
wid   = 95
wid_2_octaves = 2*7*6 / 4 ; 7 keys, 6 pixels per key
r1    = 48
r2    = 50

piano_dest = &4000 + r1*8

      IF $ AND &C000 != &C000
  !! will be used bank C1. 
      END

      IMPORT "const.i"  ; x_pos_octave
      IMPORT "memmap.i"
      IMPORT "macro.i"
      IMPORT "import.i"

          ASSERT($ AND &C000 == &C000) ; used in bank c1
          ASSERT($$ AND &C000 == &4000) ; in bank c7 (as we import disp)

.pccheck
      IMPORT "conv.o"   ; put_note put_double_space
      IMPORT "periods.o"
; must have been imported out of bank by client
          ASSERT($ == .pccheck)

; We import disp since we share the bank
;  -> Allow direct call to routines (faster and smaller)
 ; Otherwise disp-jp.call_status would reconnected original bank (c5)
   ; -> crash   
savepc = $
saveobj = $$
          IMPORT_DISP()
      ORG savepc,saveobj ; IMPORT_DISP doesn't save $$ (needs local equ)

tmpbuf = workzone+&0100

;--------------------------------------
      MACRO CALL_DS adr
 ; ds="disp status" status_* in disp.o
    ; -> direct call
          call adr
          ei            ; after DI from disp
      ENDM
;--------------------------------------


octave_rgt
;Out: A = octave
          ld hl,octave
          ld a,(hl):cp 7
          ret nc
          inc a
          jr octave_com

octave_lft
;Out: A = octave
          ld hl,octave
          ld a,(hl):or a
          ret z
          dec a
octave_com
          ld (hl),a
;Enchaine
disp_piano
          ld a,(octave)
; Display piano (shaded expect octave A and A+1)
; In: A = octave
;Out: A = octave

          push af
          push af
          LOCATION(x_pos_octave,y_pos_octave)
          CALL_DS(status_deci_a_at)

          ld hl,sprite
          ld de,piano_dest
          ld bc,hei*&0100 + wid
          call disp_shaded
          pop af
          srl a
          jr c,.odd
          ld b,a
          ld a,0
          jr z,.evenok
.mul      add wid_2_octaves:djnz .mul
.evenok
          ld c,a:ld b,0
          ld hl,piano_dest:add hl,bc
          ex de,hl
          ld hl,sprite:add hl,bc
          ld bc,hei*&0100 + wid_2_octaves
          ld ix,wid
          call disp_sprite
          pop af
          ret

.odd
          ld b,a
          ld a,wid_2_octaves/2
          jr z,.oddok
.mul'     add wid_2_octaves:djnz .mul'
.oddok
          ld c,a:ld b,0
          ld hl,piano_dest:add hl,bc
          ex de,hl
          ld hl,sprite:add hl,bc
          ld bc,hei*&0100 + wid_2_octaves-1
          ld ix,wid
;adhoc with masking lft right
.ylp
          push bc
          push de
          push hl
          ld a,(de):and &CC:ld b,a ; save 2 pix lft
          ld a,(hl):and &33:or b:inc hl
          ld (de),a:inc de
          ld b,0
          ldir
          ld a,(de):and &33:ld b,a ; save 2 pix rgt
          ld a,(hl):and &CC:or b
          ld (de),a:inc de
          pop hl
          ld a,ixl:add l:ld l,a
          ld a,ixh:adc h:ld h,a
          pop de
          call bc26_de
          pop bc
          djnz .ylp
          pop af
          ret

disp_sprite
;in: hl:source
   ; de:dest
   ;  b:hei
   ;  c:wid display
   ; ix:wid in memory
.ylp
          push bc
          push de
          push hl
          ld b,0
          ldir
          pop hl
          ld a,ixl:add l:ld l,a
          ld a,ixh:adc h:ld h,a
          pop de
          call bc26_de
          pop bc
          djnz .ylp
          ret

disp_shaded
;Apply mask so pen 3 -> pen 1
;in: hl:source
   ; de:dest
   ;  b:hei
   ;  c:wid
          ld b,hei
.ylp
          push bc
          push de
          ld b,0
mask3to1 = &F0
.xlp
          ld a,(hl):inc hl
          and mask3to1
          ld (de),a:inc de
          dec c
          jr nz,.xlp
          pop de
          call bc26_de
          pop bc
          djnz .ylp
          ret

bc26_de
; Page agnostic
          ld a,d:and &38:cp &38:jr z,.nxtline
          ld a,d:add 8:ld d,a
          ret
.nxtline
          ld a,e:add r1*2:ld e,a
          ld a,d:adc &C8:ld d,a
          ret

disp_note
;Display Note, 16bits period, 12bits period (psg) 
 ; E.g. "B-7  &00fd  16"   
;In: A: note (0=c0)
          ld de,tmpbuf
          push de
          call put_note
          call put_double_space
          add a
          add c0 AND &FF
          ld l,a:ld h,periods/&0100
          ld a,(hl):inc l
          ld h,(hl):ld l,a
          ld a,"&":ld (de),a:inc e
          CALL_DS(put_hexa_hl)
          call put_double_space
;div/16 with rounding closest
      3 ** [srl h:rr l]
          inc hl
          srl h:rr l
          CALL_DS(put_deci_hl)
          call put_double_space ; for erasing
          xor a:ld (de),a
          pop bc
          LOCATION(x_pos_note,y_pos_note)
          CALL_DS(status_str_at)
          ret

;------------------------------------------

octave BYTE 3

sprite
      LOAD "touches.win"
pianoui_end


