tmp_dbg = 0
nrt_marker = 0          ; for timernrt
todo  = 1
need_speed = 1
border_col = &54
border_col' = &44

MAX_FX_CHANGE_PARAMS = 5 ; type, evtpnt. Syncbuzz: env, period 
MAX_TIMER_FXS = 15      ; used here only -> no ui check.

; //////// Timer emulation  //////////////
; For special fx (sync buzzer, Square Ring Modulation, minisamples...)

; Timer with landmarks / every 4 lines (256 nops):
 ; - Simpler
 ; - Allow 2 nops resolution (we use signed, max = 128 -> 256 nops).
 ; - Perfect for 300Hz (as 78 entries is divisible by 6)
 ; - Still fit in 256 tables (78 * 3 = 218)
 ; - CON: more interruptions (27 nops each time without rasters). 

; Main routines
; - init_timer
; - set_timer_and_psg  ; cut fx, change periods, program psg
; - anchor      ; Header event + routine called every 4 lines

; Routines plugged in instr row:
; - fx_null                    
; - sync_buzzer_register

; /// 2025 //////
  ; ---- alpha1 ----
     ; Cannot use PSG_L_HL_FAST for periods MSB
  ; ---- v0at ---- 
   ; Nov
     ; 6: sync_buzzer_register: reset r13 so no spurious trigger 
        ; set_timer_and_psg: more ints + PSG_L_HL_FAST
                           ; to alleviate artefacts (hmm, pas flagrant)
   ; Oct
     ;16: Reorder tables for wasteless align
        ; Move fx_by_track at 8100  
  ; ---- v0as ---- 
     ; 8: cutlp: fix race condition    
     ; 4: cutlp: remove event instead of replacing it by cut_fx

      IMPORT "const.i"
      IMPORT "plyconf.i"
      IMPORT "memmap.i" ; psg_regs
      IMPORT "macro.i"
check_pc = $
      IMPORT "assert.o"
      IMPORT "periods.o"
          ASSERT($ == check_pc) ; Must have been imported first (via ply)
;Otherwise, $ = c1, and Init_periods would trash the code!

TM_MAX = &80
RDV_SENTINELLE = TM_MAX ; Max RDV
;Note: Timer counter is signed, but we can use &80 = 128, since
     ; it will be decremented before any sign test.

; Size Header+code for each event.
; 16 is more than necessary 
EVENT_MAX_SIZE = 16
          ASSERT_NOT(EVENT_MAX_SIZE AND EVENT_MAX_SIZE-1)
; -> if not power of 2, replace AND by modulo 

track_fx_size = &10     ; 2 bytes by fx. Now &10 for easier debug
; Strict < (see fxcutend) 
          ASSERT(MAX_FX_BY_INSTR*2 < track_fx_size)

; ---- header event ----- 
hdr_link_free = 0       ; next free slot
hdr_cpt = 1             ; <--- we point here
hdr_link_next = 2       ; next event 
hdr_clock = 3           ; clock (MSB then LSB)
hdr_clock_msb = 3
hdr_code = 5            ; execution

;---------------------------------------
      MACRO INIT_LISTS  ; also for timernrt
init_lists_tm = 24
; IN/OUT: A = TM (when applicable)
          ld hl,fx_by_track:ld (fx_by_track_pnt),hl
          ld hl,change_list:ld (change_pnt),hl
          ld hl,cut_list:ld (cut_pnt),hl
      ENDM

      MACRO CLOSE_LISTS ; also for timernrt
close_lists_tm = 15
; Mark end of lists, which were built by e.g sync_buzzer_register
; via instr.o      
          xor a
          ld hl,(change_pnt):ld (hl),a
          ld hl,(cut_pnt):ld (hl),a
      ENDM

      MACRO SYNC_ANCHOR ; used by piano.o
; Sync incoming anchor to the clock.
; It's needed at the first iteration, as current_anchor was 
    ; purposefully lagging to avoid race condition (see init_timer)
; It's not needed afterward, since it remains in sync naturally.
; Note only it's not needed, but trying to do that in set_timer_and_psg
; may lead to race conditions, especially if the call to the routine
; itself hasn't guarenteed stability
          ld a,(current_clock+1):ld (current_anchor),a
      ENDM


      MACRO SUB_TM_CALL n
; Update and call HL' when CPT < 0 
          SUB_TM(n+9)
; Cannot use call m,jp_hl', as it must take the same time in both case
          call jp_m_hl'
      ENDM

      MACRO CPT_TO_CODE
          ASSERT([hdr_code AND 4]==4 AND EVENT_MAX_SIZE==16)
          ASSERT(hdr_code == hdr_cpt+4)
          set 2,l       ; +4 without having to ex af,af' twice
      ENDM

correct_tm = 6          ; don't count last ex af to compensate djnz
      IF correct_tm MOD 3
 !! must report residue at the end 
      END

      MACRO PER_16_TO_12
          nop           ; for correct_tm to be multiple of 3
          ld hl,psg_regs
          ld b,3
.cor_lp
          ld e,(hl):inc l
          ld d,(hl)
      3 ** [srl d:rr e]
          inc de        ; round to closest
          srl d:rr e
          ld (hl),d:dec l
          ld (hl),e
          inc l
          inc l
          SUB_TM_CALL(34 + correct_tm/3)
          djnz .cor_lp  ; tm compensated by ex af,af
      ENDM

      MACRO FIND_EVENT_PRELUDE
; Find where to insert event (copy-pasted for speed)
; Here: HL = header_events + gross position 
      ; A  = fine position
      ; D  = events
      ;  C = event to insert
          ld e,(hl)
          ex de,hl
          srl a         ; A = fine pos < 128 in double-nops
      ENDM

      MACRO GOTO_NEXT_EVENT tm
          inc l
      IF dev_checks
          ld e,a
          ld a,(hl)
          CHECK_EVENT_OFFSET(hdr_cpt)
          ld a,e
          SUB_TM''(11)
      END
          ld e,(hl)
          ex de,hl
          SUB_TM''(tm+4)
      ENDM

      MACRO FIND_EVENT_LOOP
;Invariant loop:
  ;  a= fine pos in double nops < &180
  ; hl= event (at hdr_cpt field)
  ; de= link field from **previous** event.  We have l = (de)
      IF todo
; timer interupt (SUB_TM_CALL), since  7+ fx -> 65+ nops (imprecise)
; worse: for 14+ fx, we might miss event -> out of sync bug
; No race condition, as events are keep ordered, but **must save A**
      END
.lp
          GOTO_NEXT_EVENT(5) ; 5: cp (hl):jp
          cp (hl)
          jp nc,.lp     ; jp: stable tm
.found
      ENDM

compensate_rdv_tm = 2

      MACRO COMPENSATE_RDV
; We want A' += next_rdv - cur_rdv  (add delai before next RDV)
          sub (hl)      ; - cur_rdv
      ENDM

insert_event_tm = 34 + 13
      MACRO COMPENSATE_AND_INSERT_EVENT
; Hl-1 points to clock. We add period to next RDV.
          ASSERT(hdr_clock == hdr_code -1)
          dec l
          ld a,(hl):add e:ld (hl),a:dec l:ld b,a
          ld a,(hl):adc d:ld (hl),a:dec l
          dec l         ; start of event (hdr_cpt)

; Must do that now, as rdv might be overwriten in insertion below
; (when event repeated after itself) 
          ex af,af
          COMPENSATE_RDV()
          ex af,af
; We don't know yet which event will be next, 
; so we'll do +next_rdv after insertion

; --- Insert event ----
          ld c,l        ; C = this very event to insert
          ld d,h        ; events
          dec h         ; header_events
          ld l,a        ; Gross pos
          ld a,b
          FIND_EVENT_PRELUDE()
;First iter unrolled:
  ; - optimisation
  ; - more importantly, detection "self" would be slighty bugged
    ; when DE still points to header_events.
          cp (hl)
          jr c,.found0
          ld d,h        ; stable tm (jr not taken)
          FIND_EVENT_LOOP()
; !!Note: We don't handle "insert after itself", which would 
        ; require a different code path (no link update, just cpt)
; Well, it cannot happen, as period >= &100
; We check that to be more future-robust, and detect programming error
      IF dev_checks
          ld b,a
          ld a,c:inc a:cp e:call z,mess
          ld a,b
          SUB_TM''(8)
      END
.found0
          ex de,hl
          ld (hl),c     ; link to this event
          ld l,c
          ld h,d        ; needed when coming from first iteration
          ld (hl),a     ; new cpt
          inc l
          ld a,(hl)     ; Current next event
      IF dev_checks
          CHECK_EVENT_OFFSET(hdr_cpt)
          ld a,e
          CHECK_EVENT_OFFSET(hdr_cpt)
          ld a,(hl)
          SUB_TM''(17)
      END
          ld (hl),e     ; Plug next event for next instance
          ld l,a
      ENDM

      IF nrt_marker
program_next_event_tm = 11 + 8
      ELSE
program_next_event_tm = 11
      END

      MACRO PROGRAM_NEXT_EVENT
; And jump to it if it's time
; In: HL= nxt event (at hdr_cpt)
    ; Carry flag after A=TM updated (SUB_TM)
      IF nrt_marker
          ld c,a
          ld a,(hl):ld (dbg_tm_marker),a
          ld a,c
      END
          jr c,.toomuch
          add (hl)
          CPT_TO_CODE()
          exx
; We don't use RET_ROUT:
  ; events are fired only when tm<0, so we test Carry rather than M/P
  ; this allow to fire events when e.g. A goes from -76 to -129=127
  ; (simultaneous events) 
          ret c
          exx
          jp hl

.toomuch
; consecutive events took more than 512 nops -> must fire next one
      IF todo
; ??? it happens even with just anchor + 2 evt
    ; (even with dev_checks=0, when nrt_marker=1) 
    ; It shouldn't! 50 + 108 + 108 nops bigger than 256, but not 512
; !!!? infinite loop if more events than can be handled
    ; -> precheck this condition first?
      END
; This code path is 4-1 nops shorter.
          ld a,a        ; compensate 1 nop
          adc (hl)      ; compensate 2 nops
          CPT_TO_CODE()
          jp hl
      ENDM

      MACRO CHECK_EVENT_OFFSET offset
      IF dev_checks
          ASSERT_NOT(EVENT_MAX_SIZE AND EVENT_MAX_SIZE-1)
; -> if not power of 2, replace 'and' by modulo 
          and EVENT_MAX_SIZE-1
          cp offset:call nz,mess
      END
      ENDM

      MACRO PSG_L_HL
; Sent (hl) to reg l without touching A
; In: HL = &8000 + reg 
    ; DE = &f6c0
    ; PPI in select mode (F6C0)
;Out: HL +=1
psg_l_hl_tm = 26
      IF tmp_dbg
      IF 0
;dump regs
          push de:push hl
          ld b,l
          ld d,(hl)
          ld hl,(dbg1)
          ld (hl),b:inc l
          ld (hl),d:inc l
          ld (dbg1),hl
          pop hl:pop de
      ELSE
          ld a,l:cp 8:jr nz,.ok8
          ld a,(hl):or a:call nz,&BE00
.ok8
          ld a,l:cp 9:jr nz,.ok9
          ld a,(hl):cp &10:call nz,&BE00
.ok9
          ld a,l:cp 10:jr nz,.ok10
          ld a,(hl):or a:call nz,&BE00
.ok10
          ld a,l:cp 13:call z,&BE00
      END
      END
          ASSERT(psg_regs AND &FF == 0) ; to use lsb=reg
          ASSERT(psg_regs / &0100 == &80) ; out (c),h
          ld b,&F4:out (c),l ; assume PPI:F6 already in select mode
          ld b,d:out (c),0
          dec b
          outi
          ld b,d:out (c),h:out (c),e
      ENDM

      MACRO PSG_L_HL_FAST
; Direct from C0 to 80 (temporarily send reg to itself: ok for
; all regs but periods LSB. See psgtst1.o)
; !!! oh actually won't work for periods MSB either for low notes:
    ; e.g g-1 (&1fc) -> reg 1 or 3 would trigger tone switch since 3<4 
; 
psg_l_hl_fast_tm = 22
          ld b,&F4:out (c),l ; assume PPI:F6 already in select mode
          ld b,d:out (c),h
          dec b
          outi
          ld b,d:out (c),e
      ENDM

;---------------------------------------
          ASSERT($ AND &FF == 0)

;!! tables must remain inlined as we inject anchor below
header_events FILL &0100,0
events FILL MAX_TIMER_FXS * EVENT_MAX_SIZE,0
          ASSERT(events == header_events+&0100) ; must be contiguous
anchor
;-----
anchor_event = anchor + hdr_cpt AND &FF
;hardcoded in /events/ table
      BYTE &DB          ; N/A: no link used for free slot (DB=debug)
      BYTE RDV_SENTINELLE
      FILL hdr_code-2,0 ; period: N/A

          ASSERT($/&0100 == events/&0100) ; confined

anchor_tm = 17 + 16
      IF need_speed
; Use one common pointer for raster and anchor
; !!! Requires to fill rasters table each time
      END
anchor_code
raster_pnt = $+1
          ld hl,rasters
          ld b,&80:outi
; Loop after 2 iters
          res 1,l
          ld (raster_pnt),hl
; =====  program_next_event   ====
current_anchor = $+1
          ld hl,header_events
          ld c,(hl)
          ld (hl),anchor_event ;Clear for rolling buffer
          inc l
          ld (current_anchor),hl
      IF dev_checks AND 0 ; !! for uilooptt 
          ld b,l
.dbgpnt   ld hl,&3C00
          ld (hl),b
          inc l
          ld (.dbgpnt+1),hl
          ld h,header_events/&0100
          SUB_TM(14)
      END
          ld l,c
          inc h
      IF nrt_marker
          ex af,af
          ld a,(nrt_msb_tm)
          inc a
          ld (nrt_msb_tm),a
          ex af,af
          SUB_TM(11)
      END
          SUB_TM(anchor_tm + program_next_event_tm)
          PROGRAM_NEXT_EVENT()

      IF events - header_events - &0100
  !!! must be contiguous
      END

init_timer
;---------     
; Call before playing start. No need to mesure TM.

; ---- Init linked list free slots 
          ld hl,events
          ld a,l
          ld b,MAX_TIMER_FXS
.rst_links ld l,a
          add EVENT_MAX_SIZE ; point to next
          ld (hl),a
          djnz .rst_links
;Last event: loop to first
;So, if we accidently use too much fx, will overwrite first one
;rather than crashing.
          ld (hl),0
 ;         xor a:ld (dbg3+1),a
          ld hl,0:ld (current_clock),hl
; We need it to lag behind, otherwise, race condition:
; event set by first play/play_instr could be triggered too soon.
; Alternative: set hl'=timer_nop for first play
          ld a,&80      ; Any < -312/4 so we don't reach 0 in 1 frame)
          ld (current_anchor),a

; Not needed, as rolling link.
; Set it nevertheless for easier dbg.
          ld hl,events:ld (free_slot),hl

; ---- Reset table with anchor sentinelle.
          ld hl,header_events
.fill     ld (hl),anchor_event:inc l:jr nz,.fill

; ---- No current fx (0 used as sentinelle)
; Sentinelle invariant is kept in fx_end (cut fx are cleared)
          ASSERT_NOT(fx_type_none) ;expect 0
          ld hl,fx_by_track
          ld b,MAX_TRACKS*track_fx_size AND &FF ; &100 -> 0
          xor a
.raz
; fx type = none
; evt pnt = 0 : nevermind as no fx
          ld (hl),a:inc l
          djnz .raz

          INIT_LISTS()
          ret

timer_code              ; for dev checks in instr.o

sync_buzzer_register
;-------------------
; Manage fx scheduling (start vs change vs stop)
; That is, update /fx_by_track/change_list/cut_list/
; When /.start/, directly encode an event (so no list needed for that)
  ; -> Changes/cuts are "bufferized" and processed in set_timer_and_psg
     ; Event start is triggered at the expected time

; Called by via instr's column fx.
; - Faster and simpler than storing virtual regs to read 
    ; and dispatch afterwards.
; - We know which track we are in.
; - More optimised: No handling (E.g. cut scan) for non-active tracks  

;----------

 ; In: (sp) = instr fx params   !! CANNOT use SUB_TM_CALL
     ; ixl = note
     ;   A = TM

sbr_tm_start = 14       ; Until jr start (taken)
sbr_tm_switch = 18
          ex af,af
; Reset "normal" r13 so no spurious trigger at /psg/ setting.
          xor a:ld (psg_regs+13),a
fx_by_track_pnt = $+1
          ld hl,fx_by_track
          or (hl)       ; use xor a above
          jr z,.start
          cp fx_type_sync_buzzer
          jr nz,.switch_fx
;-----
; Same fx, with different params.
; Cannot change params of currently running evt,
; Much like we cannot program PSG right now. 
sbr_params_tm = sbr_tm_switch-1 + 58 ; -1: jr not taken
          inc l
          ld a,(hl):inc l
          ld (fx_by_track_pnt),hl

change_pnt = $+1
          ld hl,change_list
; future-proof: poke type so we can dispatch poking routine.
; for now only one kind.
          ld (hl),fx_type_sync_buzzer:inc l
;- evt pnt
          add hdr_code + skip_prelude
          ld (hl),a:inc l
;- env type           
          pop de        ; in instr param
          ld (hl),e:inc l
;- period    
          ld a,d        ; arp
          add ixl       ; base note
          ld c,a
          ld b,periods/&0100
          pop de        ; pitch
          ld a,(bc):add e:ld e,a
          inc c
          ld a,(bc):adc d
; We don't allow periods < &100 (from B-7 = &fd)
  ; - auto-plug ("same event" is not implemented -> assert)
  ; - more importantly, sync_buzzer_register (the shortes timer fx)
    ; takes 97 nops. If we allow period 128, not enough TM left.
          jr nz,.okper
;period = 0 can be reached (when playing with pitch)
;if so, pick period &ff00 (stable and short code, no indesirable pitch)
          SUB_TM''(7-1) ; -1: jr not taken
;e = 0 -> A:=-1 NC
;e > 0 -> A:=1   C
          sub e:adc e:adc -1:jr nc,.okper ; jr needed to avoid inf loop
; While < &100, double it  
          ex af,af
.test_threshold
          SUB_TM(5)
          sla e
          jr nc,.test_threshold
          ex af,af
.okper
          ld (hl),e:inc l
          ld (hl),a:inc l
;- no extra param
      IF fx_extra_size
 !!! todo (...or not if fx are packed)
      END
          ld (change_pnt),hl
          RET_ROUT'(sbr_params_tm)

.switch_fx
; <> fx: must cut the old ("bufferized stop") and start the a new one.
; Only one kind for now so we shouldn't reach that
      IF todo
; Use exception mecanism, as we don't want to crash in user mode
; (exec without orgams)
      END
          call mess

.start
; Setup code as new event
setup_tm = 48 + 20      ; until sbr_setup_tm 
          ld (hl),fx_type_sync_buzzer
          inc l
; --- Allocate slot in /events/
          ld de,(free_slot) ; e= cur free slot
          ld a,(de)     ; next free slot
          ld (free_slot),a
;Note: we store hdr_link_free field, but that's arbritrary.
; Pointer is curated (differently) to populate change_list/cut_list
      IF dev_checks
          CHECK_EVENT_OFFSET(hdr_link_free)
          ld a,e
          CHECK_EVENT_OFFSET(hdr_link_free)
          SUB_TM''(15)
      END
          ld (hl),e:inc l
; For next fx on same track
          ld (fx_by_track_pnt),hl

; --- Insert event in event table
          ASSERT(hdr_cpt == hdr_link_free+1)
          ld c,e:inc c  ; hdr_cpt
          ld hl,current_clock
          ld a,(hl):inc l ; fine pos
          ld l,(hl)     ; gross pos in LSB
          ld h,header_events/&0100
          ld d,events/&0100
;      BRK
          FIND_EVENT_PRELUDE()
;First iter unrolled:
  ; - optimisation
  ; - mimic what is done in set_psg_insert_and_program
          cp (hl)
          jr c,.found0
          ld d,h        ; ! yeah 
          FIND_EVENT_LOOP()
; No Special case here as fresh event
      IF todo
 ; what?!! not necessarily fresh event if multi sync?
      END
.found0
          ex de,hl
          ld (hl),c     ; link to this event
          ld l,c
          ld h,d        ; needed when coming from first iteration
          ASSERT(hdr_cpt == hdr_link_free+1)
          ld (hl),a:inc l
          ASSERT(hdr_link_next == hdr_cpt+1)
          ld (hl),e:inc l ; Link to next event

; --- Fx common setup ---- 
      IF hdr_clock-hdr_link_next-1
   !! review
      END

current_clock = $+1
          ld bc,0       ; in 16bits for easy get/update
          ASSERT(current_clock+1 /&0100 == current_clock/&0100) ; confine
          ld (hl),b:inc l ; !!! write MSB first (since read backward)
          ld (hl),c:inc l

; --- Fx specific setup -----
; -- Install routine, and poke params direclty:
   ; - Faster
   ; - We couldn't reuse "poke params" 
sbr_setup_tm = 52       ; until RET_ROUT'
; Routine to poke:
; Note: TM is counted at end of set_psg_insert_and_program,
base_fx_tm = 9
;          ex af,af      
skip_prelude = 1 +1     ; +1 also skip "ld a," opcode
;          ld a,0        ; env_type   ;&3e
;          ld de,0       ; period     ;&11
; We reselect reg 13
  ;- to handle mix with other fxs (and key scan)
  ;- for generic handling by /set_psg_insert_and_program/
;          jp set_reg13_insert_and_program

      IF hdr_code-hdr_clock-2
   !! review
      END
          ld (hl),&08:inc l ; ex af,af
;- env type
          pop de        ; in instr param
          ld (hl),&3E:inc l
          ld (hl),e:inc l
;- period    
          ld (hl),&11:inc l
          ld a,d        ; arp
          add ixl       ; base note
          ld c,a
          ld b,periods/&0100
          pop de        ; pitch
          ld a,(bc):add e:ld (hl),a:inc l
          inc c
          ld a,(bc):adc d:ld (hl),a:inc l
;- no extra param
      IF fx_extra_size
 !!! todo (...or not if fx are packed)
      END
;- postlude 
          ld (hl),&C3:inc l ; jp set_psg_insert_and_program
          ld (hl),set_reg13_insert_and_program AND &FF:inc l
          ld (hl),set_reg13_insert_and_program / &0100:inc l

; Jump to other sync_buzzer_register or fx_end
          RET_ROUT'(sbr_tm_start + setup_tm + sbr_setup_tm)

fx_null
; No FX. Allows to cut one fx while the latter is going on
; Well from an ui perspective (e.g. first column cut)
; Internally, we would see the 2nd fx as the first one (we stack
; active fxs only, for optimisation sake), so it will act as the 2nd
; effect is cut and reactivated.

; Fx not packed for now (KISS), so skip parameters
          pop hl
          pop hl
      IF fx_extra_size
     !! todo
      END
          RET_ROUT(6)

fx_end
; End of instr handling
; Each supernumerous fx must be cut.
ret_sp = $+1
          ld sp,0
fx_end_                 ; called from instr._instr_end
          ex af,af
          ld hl,(fx_by_track_pnt)
cut_pnt = $+1
          ld de,cut_list
.lp
          ld a,(hl):or a
          jr z,.fxcutend

          ld (hl),0:inc l ; mustn't cut next time, and reinstall fx
          ld a,(hl):inc l
; We pre-add dest offset (ready to use by cutlp)
          add hdr_code - hdr_link_free
          ld (de),a:inc e
      IF dev_checks
          CHECK_EVENT_OFFSET(hdr_code)
          SUB_TM''(7)
      END
          SUB_TM''(20)  ; whole iter
          jr .lp
.fxcutend
; Update pnt for next track
          ld (cut_pnt),de
      IF MAX_FX_BY_INSTR AND &F8 OR [track_fx_size - &10]
   !!! review that 
   ;  we expect pnt still in &10 slice 
   ; even after final inc l. If 8 fx -> kaboum
      END
          ld a,l:and &F0:add track_fx_size
          ld (fx_by_track_pnt),a
          RET_ROUT'(33)

set_timer_and_psg
;----------------
; Cut fx, change params, and **set PSG**
; (start is handled in e.g. sync_buzzer_register)

; Rationale: cut must be done before sending psg regs
; -> E.g if sync buzzer is cut and replaced
; by classic hard_env, the fx must be stopped before psg update.

; It must be done **just** before, as its effect is immediate
; (well, after current period anyway)

; Must be called at constant pos in the frame (think of it as
; PSG + virtual regs programming).
; NB: /psg/ start time might fluctutate, that's ok.
    ; That's what happen with regular players.
; The possible glitchs due to lag between timer and psg programming
; will be mitigated in the future when we play each instrument
; independently. 

; IN: A = TM  
    ;HL'= nxt event 
;OUT: A = TM     

; Convert 16 bits -> 12 bits
; Note: Hard env period already converted (it was /256)
; Done now because we change to keep timer and psg settings close
; (to avoid artefacts).
correct_tm = 6          ; don't count last ex af to compensate djnz
      IF correct_tm MOD 3
 !! must report residue at the end 
      END

      IF periods_in_16bits
          PER_16_TO_12()
      END
          ex af,af

          CLOSE_LISTS()

cut_tm = close_lists_tm + 11 ; Until .cutend (taken)
          ld bc,cut_list
          ld h,events/&0100
.cutlp
cut_tm_lp = 17
          ld a,(bc)
          or a
          jr z,.cutend

          call _do_cut
          ex af,af

          ld b,cut_list/&0100
          inc c
          jr .cutlp
.cutend
; --- enchaine
;change_params
; Change params of running fx.
; Can be called before or after psg
change_params_tm = 10   ; until chgend taken

          ex de,hl      ; d=events/&100
          ld hl,change_list
.chglp
          ld a,(hl)
          or a
          jr z,.chgend

      IF dev_checks
; For now, only 1 type of fx so we know what/where to poke
          cp fx_type_sync_buzzer:call nz,mess
          SUB_TM''(5)
      END
          inc l
      IF dev_checks
          ld a,(hl)
          CHECK_EVENT_OFFSET(hdr_code+skip_prelude)
          SUB_TM''(9)
      END
          ld e,(hl)
          inc l
          ldi           ; env type
          inc e         ; skip 'ld de' opcode
          ldi           ; new period
          ldi
          ex af,af
          SUB_TM_CALL(30)
          ex af,af
          jr .chglp
.chgend

          ex af,af
          SUB_TM_CALL(cut_tm + change_params_tm)

          INIT_LISTS()  ; Reset pnts for next time

; Now update clock for next time (can be done anytime).
          ld hl,(current_clock)
      IF ayane
update_clock_tm = 19
          ld bc,(replay_period_in_nops)
      ELSE
update_clock_tm = 16
          ld bc,replay_default ; = 312*64  cf const.i
      END
      IF dev_checks
; Todo [persitence] make sure it is repopulated
          ex af,af
          ld a,c:cp replay_default AND &FF:call nz,programming_error
          ld a,b:cp replay_default / &0100:call nz,programming_error
          ex af,af
          SUB_TM(14)
      END
          add hl,bc
          ld (current_clock),hl

          SUB_TM_CALL(init_lists_tm + update_clock_tm)

; Enchaine
psg
psg_tm = 27             ; ld and calls until SUB_TM_CALL
          ld hl,psg_regs
          ld de,&F6C0
;          ld b,d:out (c),0:out (c),c ;try  (+9)
          call psg_channel ; regs 0,1,8
          ld l,2
          call psg_channel ; regs 2,3,9
          ld l,4
          call psg_channel ; regs 4,5,10
          ld l,6
          PSG_L_HL_FAST()
;todo for sid: and with sid_mask
; (or skip r7 setting if current sid. More complicated?)
          PSG_L_HL_FAST()
          SUB_TM_CALL(2*psg_l_hl_fast_tm + [psg_tm MOD 3])
          ld l,11
          PSG_L_HL()
          PSG_L_HL_FAST()
          SUB_TM_CALL(psg_l_hl_tm + psg_l_hl_fast_tm + 2)
          ex af,af
          ld a,(hl)
;If bit 4 set or different val: force trigger
oldr13 = $+1
          cp 0
          res 4,a
          ld (oldr13),a
          jr nz,$+3:inc l ; reg 14: dev/null
          PSG_L_HL()
          RET_ROUT'(14+psg_l_hl_tm)

psg_channel
; Program period and volume
; IN: hl: points to periods
    ;  A: tm
          PSG_L_HL()
          PSG_L_HL()
          SUB_TM_CALL(psg_l_hl_tm*2)
; period to volume without using A
          dec l         ; compensate 2nd OUTI
          srl l:set 3,l
          PSG_L_HL_FAST()
          RET_ROUT(psg_l_hl_fast_tm + psg_tm/3 + 5)


_do_cut
; In a: evt pnt
      IF dev_checks
          CHECK_EVENT_OFFSET(hdr_code)
          ld a,(bc)     ; restore
          SUB_TM''(9)
      END
cut_tm1 = 29            ; until jr race1 (taken)

; -- release event (free_slot)
; (1) event.hdr_link_next = free
; (2) free_slot.pnt = event
          add hdr_link_free - hdr_code
          ld l,a
          ld a,(free_slot) ;  
          ld (hl),a     ; (1)
          ld a,l
      IF dev_checks
          CHECK_EVENT_OFFSET(hdr_link_free)
          ld a,l
          SUB_TM''(8)
      END
          ld (free_slot),a ;(2)

; -- Remove event from timer list
          hdr_cpt - hdr_link_free ** inc l
          ld b,l        ; link pnt to this event
          hdr_clock_msb - hdr_cpt ** inc l
          ld e,(hl)
          ld d,header_events/&0100
          ld a,(de)
          cp anchor_event
          jr z,.race1
cut_tm2 = 6 - 1         ; until jr .removefound (taken) -1: not .race1
          ld l,a
          hdr_link_next - hdr_cpt ** inc l
          cp b
          jr z,.removefound
.removelp_
          ld d,h
.removelp
          ex de,hl
          ld a,(de)     ; link to nxt event
          ld l,a
          hdr_link_next - hdr_cpt ** inc l
;shouldn't happen! exit to avoid infinite loop or corruption
          cp anchor_event
      IF dev_checks
removelp_tm = 14
          call z,mess
      ELSE
removelp_tm = 13
          jr z,.mess
      END
      IF todo
;Use SUB_TM_CALL. But then check how to avoid race condition
;as the event we are searching for might have moved
;Solution: restart to get actual pos after call (which trashes A BTW)
      END
          SUB_TM''(removelp_tm)
          cp b
          jp nz,.removelp ; jp: stable tm
.removefound
          ld a,(hl)
          ld (de),a
.mess
          RET_ROUT'(cut_tm1 + cut_tm2 + 4 + cut_tm_lp)

.race1
; No hook in header_events: already cleared, hook in hl'
cut_tm3 = 8             ; until jr .skip_hl' (taken)
          ld a,b
          add hdr_code - hdr_cpt
          exx
          cp l
          jr z,.skip_hl'
;           
          ld a,l
          add hdr_link_next - hdr_code
          exx
          ld l,a
          SUB_TM''(cut_tm3-1 - cut_tm2 + 8 + 1) ;+1: ld d,h
          jr .removelp_

.skip_hl'
;Replace evt we want to cut by next one
          add hdr_cpt - hdr_code
          ld l,a
          ex af,af
          sub (hl)
          hdr_link_next - hdr_cpt ** inc l
          ld l,(hl)
          add (hl)
          CPT_TO_CODE()
          exx
          RET_ROUT(cut_tm1 + cut_tm3 + 14 + cut_tm_lp) ;(68) 

;-------------------------------------

;--------------------------------------

set_reg13_insert_and_program
;---------------------------
          ld bc,&F40D
; We reselect reg 13
  ;- to handle mix with other fxs (and key scan)
  ;- for generic handling by /set_psg_insert_and_program/
set_psg_insert_and_program
;-------------------------
; Called as event (set in sync_buzzer_register)
; The prelude (setting DE, A) is done by the code inside the event.

; In: hl = jump address of current event (in /events/)
    ; bc = &f400+reg
    ; de = period
    ;  a = val psg
    ;  a'= cpt TM
;Out: HL' = jump address of next event
    ;  A  = cpt TM

; timing psg, raster, insert, program (93 nops + 8 with nrt markers) 
spiap_tm = 29 + 11 + insert_event_tm + 1
sr13iap_tm = spiap_tm + 3

; We select reg each time 
  ;- to handle interleaving with other fxs, psg setting, key scan.
  ;- more generic 
          out (c),c     ; Register
          ld b,&F6:out (c),0
          ld b,&F4:out (c),a ; Value
          ld bc,&F680:out (c),c ; Write   
;Note: no out (n),a optimisation here.
; Bit 4 of VAL must be 0 to keep motor off, 
; If used as PORT MSB -> latch printer, which would cause issue
; with soundplayer!
          ld c,&C0:out (c),c ; Select (for next time or /psg/ rout)

;dbg3      ld a,0:inc a:ld (dbg3+1),a
; ---  raster for visu -----
          ld b,&7F:ld a,d:and &1F:or &40:out (c),a

          COMPENSATE_AND_INSERT_EVENT()
          ex af,af

          SUB_TM(base_fx_tm + sr13iap_tm + program_next_event_tm)
          PROGRAM_NEXT_EVENT()
; ----------------------------------------------


timer_nop
;--------
;For NRTs (timernrt, instrnrt)
          add &80       ; reload
          ex af,af
          ld a,(nrt_msb_tm)
          inc a
          ld (nrt_msb_tm),a
          ex af,af
          exx
          RET_ROUT(14)

jp_m_hl'  ret p         ; 4 nops in any case
;enchaine
jp_hl'    exx
;enchaine
jp_hl     jp hl

;-----------------------------
vsync_timed
;In/OUT: A = TM
          SUB_TM(2-1+3) ;-1 last jr not taken +3 for ret
          ld b,&F5
.lp
vsync_timed_lp_tm = 9
          SUB_TM_CALL(vsync_timed_lp_tm)
          in c,(c)
          rr c
          jr nc,.lp
          ret

      IF 0
waitlines_tm
; !!! Bugged !!! Fluctuate depending on events!!!
  ; Sub-bug -> return earlier when more events!?!
; Wait B lines + 3 NOPs (final RET_ROUT)
; IN: B = nb lines
    ; A = TM
;OUT: A = TM
          push bc
          ld b,3
; Rely on fact SUB_TM_CALL takes 12 nops
; 3*16 - 1 nops
.inner
          SUB_TM_CALL(4)
          djnz .inner
          2 ** ld a,a
; Rely on fact SUB_TM(even) takes 2 nops. Whole loop takes 64 nops
          SUB_TM(13-1+2) ; -1 last djnz, +2: padding 
          pop bc
          djnz waitlines_tm
          RET_ROUT(-1)  ;-1 last djnz
      END
;-----------------------------
      IF tmp_dbg
      SKIP -$ AND &FF
dbg   SKIP &0100
      END

      SKIP -$ AND 3     ; use res 1,l
rasters BYTE border_col,border_col'

          ASSERT(fx_by_track AND &FF == 0) ; aligned

change_list SKIP MAX_TIMER_FXS*MAX_FX_CHANGE_PARAMS +1 ; +sentinelle
          CHECK_CONFINE(change_list)

cut_list SKIP MAX_TIMER_FXS +1
          CHECK_CONFINE(cut_list)

free_slot WORD events
replay_period_in_nops WORD replay_default

nrt_msb_tm BYTE 
dbg_tm_marker BYTE      ; tm of next event
      IF tmp_dbg
dbg1  WORD dbg
dbg2  WORD 
      END
