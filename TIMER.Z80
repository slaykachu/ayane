dev_checks = 1
nrt_marker = 1          ; for timernrt
todo  = 1
need_speed = 1
border_col = &54
border_col' = &44

; //////// Timer emulation  //////////////
; For special fx (sync buzzer, Square Ring Modulation, minisamples...)

; Timer with landmarks / every 4 lines (256 nops):
 ; - Simpler
 ; - Allow 2 nops resolution (we use signed, max = 128 -> 256 nops).
 ; - Perfect for 300Hz (as 78 entries is divisible by 6)
 ; - Still fit in 256 tables (78 * 3 = 218)
 ; - CON: more interruptions (50 nops each time without rasters). 

; Main routines
; - init_timer
; - set_timer_and_psg  ; cut fx, change periods, program psg
; - anchor      ; Header event + routine called every 4 lines

; Routines plugged in instr row:
; - fx_null                    
; - sync_buzzer_register

; /// 2025 //////
  ; ---- v0ao ---- 
   ; Sep
    ; 16: PROGRAM_NEXT_EVENT: better tm check
        ; Anchor: 1 nop faster!
   ; Aug  
    ; 28: INSERT_EVENT: Fix A trashed for self-insert check
                      ; -> fix double sync timer.
    ; 27: Add nrt_marker for analysis 
  ; ---- v0an ----
    ; 26: Turn period 0 to &fe00 (instead of assert)
    ; 25: Fix anchor_tm
        ; Clean-up, comment
        ; vsync_timed: take A=TM
  ; ---- v0am ----
    ; 23: Double period while < &100. See rational at /
        ; Move common macros in macro.i

      IMPORT "const.i"
      IMPORT "plyconf.i"
      IMPORT "memmap.i" ; psg_regs
      IMPORT "macro.i"
check_pc = $
      IMPORT "periods.o"
          ASSERT($ == check_pc) ; Must have been imported first (via ply)
;Otherwise, $ = c1, and Init_periods would trash the code!

TM_MAX = &80
RDV_SENTINELLE = TM_MAX ; Max RDV
;Note: Timer counter is signed, but we can use &80 = 128, since
     ; it will be decremented before any sign test.

;ENTRIES_FOR_50HZ = 78   ; 312/4
;ENTRIES_FOR_100HZ = 39  ; 156/4

; Size Header+code for each event.
; 16 is more than necessary (see for sample+volume if it's true).
EVENT_MAX_SIZE = 16
          ASSERT_NOT(EVENT_MAX_SIZE AND EVENT_MAX_SIZE-1)
; -> if not power of 2, replace AND by modulo 

track_fx_size = &10     ; 2 bytes by fx. Now &10 for easier debug

; ---- header event ----- 
hdr_link_free = 0       ; next free slot
hdr_cpt = 1             ; <--- we point here
hdr_link_next = 2       ; next event 
hdr_clock = 3           ; clock (MSB then LSB)
hdr_code = 5            ; execution

fail  = &BE00

;---------------------------------------
      MACRO INIT_LISTS
init_lists_tm = 24
; IN/OUT: A = TM (when applicable)
          ld hl,fx_by_track:ld (fx_by_track_pnt),hl
          ld hl,change_list:ld (change_pnt),hl
          ld hl,cut_list:ld (cut_pnt),hl
      ENDM

      MACRO CLOSE_LISTS ; for timer.nrt
close_lists_tm = 15
; Mark end of lists, which were built by e.g sync_buzzer_register
; via instr.o      
          xor a
          ld hl,(change_pnt):ld (hl),a
          ld hl,(cut_pnt):ld (hl),a
      ENDM

      MACRO SYNC_ANCHOR ; used by piano.o
; Sync incoming anchor to the clock.
; It's needed at the first iteration, as current_anchor was 
    ; purposefully lagging to avoid race condition (see init_timer)
; It's not needed afterward, since it remains in sync naturally.
; Note only it's not needed, but trying to do that in set_timer_and_psg
; may lead to race conditions, especially if the call to the routine
; itself hasn't guarenteed stability
          ld a,(current_clock+1):ld (current_anchor),a
      ENDM


      MACRO SUB_TM_CALL n
; Update and call HL' when CPT < 0 
          SUB_TM(n+9)
; Cannot use call m,jp_hl', as it must take the same time in both case
          call jp_m_hl'
      ENDM

      MACRO FIND_EVENT_PRELUDE
; Find where to insert event (copy-pasted for speed)
; Here: HL = header_events + gross position 
      ; A  = fine position
      ; D  = events
      ;  C = event to insert
          ld e,(hl)
          ex de,hl
          srl a         ; A = fine pos < 128 in double-nops
      ENDM

      MACRO GOTO_NEXT_EVENT tm
          inc l
      IF dev_checks
          ld e,a
          ASSERT(EVENT_MAX_SIZE == &10) ; if fail, update check itself
          ld a,(hl):and &0F:cp hdr_cpt:call nz,fail
          ld a,e
          SUB_TM''(11)
      END
          ld e,(hl)
          ex de,hl
          SUB_TM''(tm+4)
      ENDM

      MACRO FIND_EVENT_LOOP
;Invariant loop:
  ;  a= fine pos in double nops < &180
  ; hl= event (at hdr_cpt field)
  ; de= link field from **previous** event.  We have l = (de)
.lp
          GOTO_NEXT_EVENT(5) ; 5: cp (hl):jp
          cp (hl)
          jp nc,.lp     ; jp: stable tm
.found
      ENDM

insert_event_tm = 34 + 13
      MACRO INSERT_EVENT
; Hl-1 points to clock. We add period to next RDV.
          ASSERT(hdr_clock == hdr_code -1)
          dec l
          ld a,(hl):add e:ld (hl),a:dec l:ld b,a
          ld a,(hl):adc d:ld (hl),a:dec l
; --- Insert event ----
          dec l         ; start of event (hdr_cpt)
; We want A' += next_rdv - cur_rdv  (add delai before next RDV)
          ex af,af
; Must do that now, as rdv might be overwriten in insertion below
; (when event repeated after itself) 
          sub (hl)      ; - cur_rdv
; We don't know yet which event will be next, 
; so we'll do +next_rdv after insertion
          ex af,af
          ld c,l        ; C = this very event to insert
          ld d,h        ; events
          dec h         ; header_events
          ld l,a        ; Gross pos
          ld a,b
          FIND_EVENT_PRELUDE()
;First iter unrolled:
  ; - optimisation
  ; - more importantly, detection "self" would be slighty bugged
    ; when DE still points to header_events.
          cp (hl)
          jr c,.found0
          ld d,h        ; stable tm (jr not taken)
          FIND_EVENT_LOOP()
; !!Note: We don't handle "instert after itself", which would 
        ; require a different code path (no link update, just cpt)
; Well, it cannot happen, as period >= &100
; We check that to be more future-robust, and detect programming error
      IF dev_checks
          ld b,a
          ld a,c:inc a:cp e:call z,&BE00
          ld a,b
          SUB_TM''(8)
      END
.found0
          ex de,hl
          ld (hl),c     ; link to this event
          ld l,c
          ld h,d        ; needed when coming from first iteration
          ld (hl),a     ; new cpt
          inc l
          ld a,(hl)     ; Current next event
          ld (hl),e     ; Plug next event for next instance
          ld l,a
      ENDM

      IF nrt_marker
program_next_event_tm = 11 + 8
      ELSE
program_next_event_tm = 11
      END

      MACRO PROGRAM_NEXT_EVENT tm
; And jump to it if it's time
      IF nrt_marker
          ld c,a
          ld a,(hl):ld (dbg_tm_marker),a
          ld a,c
      END
          SUB_TM(tm + program_next_event_tm)
          jr c,.toomuch
          add (hl)
          ASSERT([hdr_code AND 4]==4 AND EVENT_MAX_SIZE==16)
          ASSERT(hdr_code == hdr_cpt+4)
          set 2,l       ; +4 without having to ex af,af' twice
          exx
; We don't use RET_ROUT:
  ; events are fired only when tm<0, so we test Carry rather than M/P
  ; this allow to fire events when e.g. A goes from -76 to -129=127
  ; (simultaneous events) 
          ret c
          exx
          jp hl

.toomuch
; consecutive events took more than 512 nops -> must fire next one
      IF todo
; ??? it happens even with just anchor + 2 evt
    ; (even with dev_checks=0, when nrt_marker=1) 
    ; It shouldn't! 50 + 108 + 108 nops bigger than 256, but not 512
; !!!? infinite loop if more events than can be handled
    ; -> precheck this condition first?
      END
; This code path is 4-1 nops shorter.
          ld a,a        ; compensate 1 nop
          adc (hl)      ; compensate 2 nops
          set 2,l
          jp hl
      ENDM

      MACRO CHECK_EVENT_OFFSET offset
      IF dev_checks
          ASSERT_NOT(EVENT_MAX_SIZE AND EVENT_MAX_SIZE-1)
; -> if not power of 2, replace 'and' by modulo 
          and EVENT_MAX_SIZE-1
          cp offset:call nz,fail
      END
      ENDM

      MACRO PSG_L_HL
; Sent (hl) to reg l without touching A
; In: HL = &8000 + reg 
    ; DE = &f6c0
    ; PPI in select mode (F6C0)
;Out: HL +=1
psg_l_hl_tm = 26
          ASSERT(psg_regs AND &FF == 0) ; to use lsb=reg
          ASSERT(psg_regs / &0100 == &80) ; out (c),h
          ld b,&F4:out (c),l ; assume PPI:F6 already in select mode
          ld b,d:out (c),0
          dec b
          outi
          ld b,d:out (c),h:out (c),e
      ENDM

;---------------------------------------

init_timer
;---------     
; Call before playing start. No need to mesure TM.

; ---- Init linked list free slots 
          ld hl,events
          ld a,l
          ld b,MAX_TIMER_FXS
.rst_links ld l,a
          add EVENT_MAX_SIZE ; point to next
          ld (hl),a
          djnz .rst_links
;Last event: loop to first
;So, if we accidently use too much fx, will overwrite first one
;rather than crashing.
          ld (hl),0
 ;         xor a:ld (dbg3+1),a
          ld hl,0:ld (current_clock),hl
; We need it to lag behind, otherwise, race condition:
; event set by first play/play_instr could be triggered too soon.
          ld a,&80      ; Any < -312/4 so we don't reach 0 in 1 frame)
          ld (current_anchor),a

; Not needed, as rolling link.
; Set it nevertheless for easier dbg.
          ld hl,events:ld (free_slot),hl

; ---- Reset table with anchor sentinelle.
          ld hl,header_events
.fill     ld (hl),anchor_event:inc l:jr nz,.fill

; ---- No current fx (0 use as sentinelle, must be present at
; every level)
          ASSERT_NOT(fx_type_none) ;expect 0
          ld hl,fx_by_track
          ld b,MAX_TRACKS*track_fx_size AND &FF ; &100 -> 0
          xor a
.raz
; We want to set fx_type = none
; evt pnt at 0: nevermind as no fx
          ld (hl),a:inc l
          djnz .raz

          INIT_LISTS()
          ret

timer_code              ; for dev checks in instr.o

sync_buzzer_register
;-------------------
; Manage fx scheduling (start vs change vs stop)
; That is, update /fx_by_track/change_list/cut_list/
; When /.start/, directly encode an event (so no list needed for that)
  ; -> Updates are "bufferized" and processed in set_timer_and_psg
     ; (or when event is triggered for /.start/) 

; Called by via instr's column fx.
; - Faster and simpler than storing virtual regs to read 
    ; and dispatch afterwards.
; - We know which track we are in.
; - More optimised: No handling (E.g. cut scan) for non-active tracks  

      IF todo
; !!! When fx0 is cut in instr, fx1 will be seen as new fx0.
; !!! -> Will introduce an artefact, since starting clock of fx0
       ; will be used.
      END
;----------

 ; In: (sp) = instr fx params 
     ; ixl = note
     ;   A = TM

; --- First me must install routine (when fx starting)
  ; before we can even setup params

sbr_tm_start = 10       ; Until jr start (taken)
sbr_tm_switch = 14

          ex af,af
fx_by_track_pnt = $+1
          ld hl,fx_by_track
          ld a,(hl)
          or a
          jr z,.start
          cp fx_type_sync_buzzer
          jr nz,.switch_fx
;-----
; Same fx, with different params.
; Cannot change params of currently running fx,
; Much like we cannot program PSG right now. 
sbr_params_tm = sbr_tm_switch-1 + 58 ; -1: jr not taken
          inc l
          ld a,(hl):inc l
          ld (fx_by_track_pnt),hl

change_pnt = $+1
          ld hl,change_list
; future-proof: poke type so we can dispatch poking routine.
; for now only one kind.
          ld (hl),fx_type_sync_buzzer:inc l
;- evt pnt
          add hdr_code + skip_prelude
          ld (hl),a:inc l
;- env type           
          pop de        ; in instr param
          ld (hl),e:inc l
;- period    
          ld a,d        ; arp
          add ixl       ; base note
          ld c,a
          ld b,periods/&0100
          pop de        ; pitch
          ld a,(bc):add e:ld e,a
          inc c
          ld a,(bc):adc d
; We don't allow periods < &100 (from B-7 = &fd)
  ; - auto-plug ("same event" is not implemented -> assert)
  ; - more importantly, sync_buzzer_register (the shortes timer fx)
    ; takes 97 nops. If we allow period 128, not enough TM left.
          jr nz,.okper
;period = 0 can be reached (when playing with pitch)
;if so, pick period &ff00 (stable and short code, no indesirable pitch)
          SUB_TM''(7-1) ; -1: jr not taken
;e = 0 -> A:=-1 NC
;e > 0 -> A:=1   C
          sub e:adc e:adc -1:jr nc,.okper ; jr needed to avoid inf loop
; While < &100, double it  
          ex af,af
.test_threshold
          SUB_TM(5)
          sla e
          jr nc,.test_threshold
          ex af,af
.okper
          ld (hl),e:inc l
          ld (hl),a:inc l
;- no extra param
      IF fx_extra_size
 !!! todo (...or not if fx are packed)
      END
          ld (change_pnt),hl
          RET_ROUT'(sbr_params_tm)

.switch_fx
; <> fx: must cut the old ("bufferized stop") and start the a new one.
; Only one kind for now so we shouldn't reach that
      IF todo
; Use exception mecanism, as we don't want to crash in user mode
; (exec without orgams)
      END
          call fail

.start
; Setup code as new event
setup_tm = 48 + 20      ; until sbr_setup_tm 
          ld (hl),fx_type_sync_buzzer
          inc l
; --- Allocate slot in /events/
          ld de,(free_slot)
          ld a,(de)     ; next free slot
          ld (free_slot),a
;Note: we store hdr_link_free field, but that's arbritrary.
; Pointer is curated (differently) to populate change_list/cut_list
          ld (hl),e:inc l
; For next fx on same track
          ld (fx_by_track_pnt),hl

; --- Insert event in event table
          ASSERT(hdr_cpt == hdr_link_free+1)
          ld c,e:inc c  ; hdr_cpt
          ld hl,current_clock
          ld a,(hl):inc l ; fine pos
          ld l,(hl)     ; gross pos in LSB
          ld h,header_events/&0100
          ld d,events/&0100
;      BRK
          FIND_EVENT_PRELUDE()
;First iter unrolled:
  ; - optimisation
  ; - mimic what is done in set_psg_insert_and_program
          cp (hl)
          jr c,.found0
          ld d,h        ; ! yeah 
          FIND_EVENT_LOOP()
; No Special case here as fresh event
      IF todo
 ; what?!! not necessarily fresh event if multi sync?
      END
.found0
          ex de,hl
          ld (hl),c     ; link to this event
          ld l,c
          ld h,d        ; needed when coming from first iteration
          ASSERT(hdr_cpt == hdr_link_free+1)
          ld (hl),a:inc l
          ASSERT(hdr_link_next == hdr_cpt+1)
          ld (hl),e:inc l ; Link to next event

; --- Fx common setup ---- 
      IF hdr_clock-hdr_link_next-1
   !! review
      END

current_clock = $+1
          ld bc,0       ; in 16bits for easy get/update
          ASSERT(current_clock+1 /&0100 == current_clock/&0100) ; confine
          ld (hl),b:inc l ; !!! write MSB first (since read backward)
          ld (hl),c:inc l

; --- Fx specific setup -----
; -- Install routine, and poke params direclty:
   ; - Faster
   ; - We couldn't reuse "poke params" 
sbr_setup_tm = 52       ; until RET_ROUT'
      IF hdr_code-hdr_clock-2
   !! review
      END

; Routine to poke:
; Note: TM is counted at end of set_psg_insert_and_program,
;          ex af,af      ; &08
skip_prelude = 1 +1     ; +1 also skip "ld a," opcode
;          ld a,0        ; env_type   ;&3e
;          ld de,0       ; period     ;&11
; We reselect reg 13
  ;- to handle mix with other fxs (and key scan)
  ;- for generic handling by /set_psg_insert_and_program/
;          jp set_reg13_insert_and_program

base_fx_tm = 9
          ld (hl),&08:inc l ; ex af,af
;- env type
          pop de        ; in instr param
          ld (hl),&3E:inc l
          ld (hl),e:inc l
;- period    
          ld (hl),&11:inc l
          ld a,d        ; arp
          add ixl       ; base note
          ld c,a
          ld b,periods/&0100
          pop de        ; pitch
          ld a,(bc):add e:ld (hl),a:inc l
          inc c
          ld a,(bc):adc d:ld (hl),a:inc l
;- no extra param
      IF fx_extra_size
 !!! todo (...or not if fx are packed)
      END
;- postlude 
          ld (hl),&C3:inc l ; jp set_psg_insert_and_program
          ld (hl),set_reg13_insert_and_program AND &FF:inc l
          ld (hl),set_reg13_insert_and_program / &0100:inc l

; Jump to other sync_buzzer_register or fx_end
          RET_ROUT'(sbr_tm_start + setup_tm + sbr_setup_tm)

fx_null
; No FX. Allows to cut one fx while the latter is going on
; Well from an ui perspective (e.g. first column cut)
; Internally, we would see the 2nd fx as the first one (we stack
; active fxs only, for optimisation sake), so it will act as the 2nd
; effect is cut and reactivated.

; Fx are packed for now (KISS), so skip parameters
          pop hl
          pop hl
      IF fx_extra_size
     !! todo
      END
          RET_ROUT(6)

fx_end
; End of instr handling
; Each supernumerous fx must be cut.
          ex af,af
ret_sp = $+1
          ld sp,0

          ld hl,(fx_by_track_pnt)
cut_pnt = $+1
          ld de,cut_list
.lp
          ld a,(hl):or a
          jr z,.fxcutend

          ld (hl),0:inc l ; mustn't cut next time
          ld a,(hl):inc l
; We pre-add dest offset:
  ; - ready to use
  ; - more importantly, we never get 0, which is used as a sentinelle
    ; (poked in ply.track_end)
          add hdr_code
          ld (de),a:inc e
          SUB_TM''(20)  ; one whole iter
          jr .lp
.fxcutend
; Update pnt for next track
          ld (cut_pnt),de
      IF MAX_FX_BY_INSTR AND &F8 OR [track_fx_size - &10]
   !!! review that 
   ;  we expect pnt still in &10 slice 
   ; even after final inc l. If 8 fx -> kaboum
      END
          ld a,l:and &F0:add track_fx_size
          ld (fx_by_track_pnt),a
          RET_ROUT'(33)

set_timer_and_psg
;----------------
; Cut fx, change params, and **set PSG**
; (start is handled in e.g. sync_buzzer_register)

; Rationale: cut must be done before sending psg regs
; -> E.g if sync buzzer is cut and replaced
; by classic hard_env, the fx must be stopped before psg update.

; It must be done **just** before, as its effect is immediate
; (well, after current period anyway)

; Must be called at constant pos in the frame (think of it as
; PSG + virtual regs programming).
; NB: /psg/ start time might fluctutate, that's ok.
    ; That's what happen with regular players.
; The possible glitchs due to lag between timer and psg programming
; will be mitigated in the future when we play each instrument
; independently. 

; IN: A = TM  
    ;HL'= nxt event 
;OUT: A = TM     

; Convert 16 bits -> 12 bits
; Note: Hard env period already converted (it was /256)
; Done now because we change to keep timer and psg settings close
; (to avoid artefacts).
correct_tm = 6          ; don't count last ex af to compensate djnz
      IF correct_tm MOD 3
 !! must report residue at the end 
      END
          nop           ; for correct_tm to be multiple of 3
          ld hl,psg_regs
          ld b,3
.cor_lp
          ld e,(hl):inc l
          ld d,(hl)
      3 ** [srl d:rr e]
          inc de        ; round to closest
          srl d:rr e
          ld (hl),d:dec l
          ld (hl),e
          inc l
          inc l
          SUB_TM_CALL(34 + correct_tm/3)
          djnz .cor_lp
          ex af,af


          CLOSE_LISTS()

cut_tm = close_lists_tm + 11 ; Until .cutend (taken)
          ld de,cut_list
          ld h,events/&0100
.cutlp
          ld a,(de)
          or a
          jr z,.cutend

; -- poke EXX:RET (no fx executed, no event re-programmed) 
; Note: event is released below, so it could also be overwritten
      ; by new fx, which is fine as well.
      IF dev_checks
          CHECK_EVENT_OFFSET(hdr_code)
          ld a,(de)     ; restore
          SUB_TM''(9)
      END
          ld l,a
          ld (hl),&D6:inc l ; sub
          ld (hl),3:inc l ; sub 3 (6 nops including sub itself)
          ld (hl),&D9:inc l ; EXX
          ld (hl),&C9   ; RET

; -- release event (free_slot)
; (1) event.hdr_link_next = tmp
; (2) free_slot.pnt = event
          ld a,l
          add hdr_link_free - hdr_code - 3
          ld l,a
          ld a,(free_slot) ;  
          ld (hl),a     ; (1)
          ld a,l
          ld (free_slot),a ;(2)

          ex af,af
          SUB_TM_CALL(42)
          ex af,af
          inc e
          jr .cutlp
.cutend
; --- enchaine
;change_params
; Change params of running fx.
; Can be called before or after psg
change_params_tm = 10   ; until chgend taken

          ex de,hl      ; d=events/&100
          ld hl,change_list
.chglp
          ld a,(hl)
          or a
          jr z,.chgend

      IF dev_checks
; For now, only 1 type of fx so we know what/where to poke
          cp fx_type_sync_buzzer:call nz,fail
          SUB_TM''(5)
      END
          inc l
      IF dev_checks
          ld a,(hl)
          CHECK_EVENT_OFFSET(hdr_code+skip_prelude)
          SUB_TM''(9)
      END
          ld e,(hl)
          inc l
          ldi           ; env type
          inc e         ; skip 'ld de' opcode
          ldi           ; new period
          ldi
          ex af,af
          SUB_TM_CALL(30)
          ex af,af
          jr .chglp
.chgend

          INIT_LISTS()  ; Reset pnts for next time

; Now update clock for next time (can be done anytime).
          ld hl,(current_clock)
      IF ayane
update_clock_tm = 19
          ld bc,(replay_period_in_nops)
      ELSE
update_clock_tm = 16
          ld bc,replay_default ; = 312*64  cf const.i
      END
      IF dev_checks
; Todo [persitence] make sure it is repopulated
          ld a,c:cp replay_default AND &FF:call nz,programming_error
          ld a,b:cp replay_default / &0100:call nz,programming_error
          SUB_TM''(12)
      END
          add hl,bc
          ld (current_clock),hl

          ex af,af      ; A = tm
          SUB_TM(init_lists_tm + update_clock_tm + 1)

; Enchaine
psg
psg_tm = 53             ; ld and calls
          ld hl,psg_regs
          ld de,&F6C0
          call psg_channel ; regs 0,1,8
          ld l,2
          call psg_channel ; regs 2,3,9
          ld l,4
          call psg_channel ; regs 4,5,10
          ld l,6
;todo for sid: and with sid_mask
; (or skip r7 setting if current sid. More complicated?)
          call psg_2regs ; regs 6,7
          ld l,11
          call psg_2regs ; regs 11,12
          ex af,af
          ld a,(hl)
;If bit 4 set or different val: force trigger
oldr13 = $+1
          cp 0
          res 4,a
          ld (oldr13),a
          jr nz,$+3:inc l ; reg 14: dev/null
          PSG_L_HL()
          RET_ROUT'(cut_tm + change_params_tm + psg_tm + psg_l_hl_tm)

psg_channel
; Program period and volume
; IN: hl: points to periods
    ;  A: tm
          PSG_L_HL()
          PSG_L_HL()
; period to volume without using A
          dec l         ; compensate 2nd OUTI
          srl l:set 3,l
          PSG_L_HL()
          RET_ROUT(3*psg_l_hl_tm + 5)

psg_2regs
          PSG_L_HL()
          PSG_L_HL()
          RET_ROUT(2*psg_l_hl_tm)


      SKIP -$ AND &FF

;!! cannot move these tables as we inject anchor below
header_events FILL &0100,0
events
      FILL MAX_TIMER_FXS * EVENT_MAX_SIZE,0

          ASSERT(events == header_events+&0100) ; must be contiguous

anchor
;-----
anchor_event = anchor + hdr_cpt AND &FF
;hardcoded in /events/ table
      BYTE &DB          ; N/A: no link used for free slot (DB=debug)
      BYTE RDV_SENTINELLE
      FILL hdr_code-2,0 ; period: N/A

          ASSERT($/&0100 == events/&0100) ; confined

anchor_tm = 17 + 16
      IF need_speed
; Use one common pointer for raster and anchor
; !!! Requires to fill rasters table each time
      END
raster_pnt = $+1
          ld hl,rasters
          ld b,&80:outi
; Loop after 4 iter
          res 2,l
          ld (raster_pnt),hl
; =====  program_next_event   ====
current_anchor = $+1
          ld hl,header_events
          ld c,(hl)
          ld (hl),anchor_event ;Clear for rolling buffer
          inc l
          ld (current_anchor),hl
          ld l,c
          inc h
          PROGRAM_NEXT_EVENT(anchor_tm)

      IF header_events AND &FF
  !!! error align
      END

      IF events - header_events - &0100
  !!! must be contiguous
      END

;--------------------------------------

set_reg13_insert_and_program
;---------------------------
          ld bc,&F40D
; We reselect reg 13
  ;- to handle mix with other fxs (and key scan)
  ;- for generic handling by /set_psg_insert_and_program/
set_psg_insert_and_program
;-------------------------
; Called as event (set in sync_buzzer_register)
; The prelude (setting DE, A) is done by the code inside the event.

; In: hl = jump address of current event (in /events/)
    ; bc = &f400+reg
    ; de = period
    ;  a = val psg
    ;  a'= cpt TM
;Out: HL' = jump address of next event
    ;  A  = cpt TM

; timing psg, raster, insert, program (93 nops + 8 with nrt markers) 
spiap_tm = 29 + 11 + insert_event_tm + 1
set_reg13_insert_and_program_tm = spiap_tm + 3

; We select reg each time 
  ;- to handle interleaving with other fxs, psg setting, key scan.
  ;- more generic 
          out (c),c     ; Register
          ld b,&F6:out (c),0
          ld b,&F4:out (c),a ; Value
          ld bc,&F680:out (c),c ; Write   
;Note: no out (n),a optimisation here.
; Bit 4 of VAL must be 0 to keep motor off, 
; If used as PORT MSB -> latch printer, which would cause issue
; with soundplayer!
          ld c,&C0:out (c),c ; Select (for next time or /psg/ rout)

;dbg3      ld a,0:inc a:ld (dbg3+1),a
; ---  raster for visu -----
          ld b,&7F:ld a,d:and &1F:or &40:out (c),a

          INSERT_EVENT()
          ex af,af

;!!! TM wrong in the future if coming from another FX
          PROGRAM_NEXT_EVENT(base_fx_tm+set_reg13_insert_and_program_tm)
; ----------------------------------------------

timer_nop
;--------
;For NRTs (timernrt, instrnrt)
          add &80       ; reload
          SUB_TM(7)
          inc d         ; MSB TM
          exx
          ret


jp_m_hl'  ret p         ; 4 nops in any case
;enchaine
jp_hl'    exx
;enchaine
jp_hl     jp hl

jp_bc     push bc:ret

;-----------------------------
vsync_timed
;In/OUT: A = TM
          SUB_TM(2-1+3) ;-1 last jr not taken +3 for ret
          ld b,&F5
.lp
vsync_timed_lp_tm = 9
          SUB_TM_CALL(vsync_timed_lp_tm)
          in c,(c)
          rr c
          jr nc,.lp
          ret

waitlines_tm
; !!! Bugged !!! Fluctuate depending on events!!!
  ; Sub-bug -> return earlier when more events!?!
; Wait B lines + 3 NOPs (final RET_ROUT)
; IN: B = nb lines
    ; A = TM
;OUT: A = TM
          push bc
          ld b,3
; Rely on fact SUB_TM_CALL takes 12 nops
; 3*16 - 1 nops
.inner
          SUB_TM_CALL(4)
          djnz .inner
          2 ** ld a,a
; Rely on fact SUB_TM(even) takes 2 nops. Whole loop takes 64 nops
          SUB_TM(13-1+2) ; -1 last djnz, +2: padding 
          pop bc
          djnz waitlines_tm
          RET_ROUT(-1)  ;-1 last djnz
;-----------------------------

      SKIP -$ AND &FF
rasters
;  78 ** BYTE # AND &1F OR &40
;          39 ** BYTE &5C,&4C
          39 ** BYTE border_col,border_col'
;          20 ** BYTE &54,&44,&58,&5D
      FILL -$ AND &FF,&4C ; safety
      IF rasters AND 3
 !! for now use RES 2,L for wrapping
      END

fx_by_track SKIP MAX_TRACKS*track_fx_size ; n**(type, event pnt)
          ASSERT_NOT(fx_by_track AND &FF) ; aligned
          CHECK_CONFINE(fx_by_track)


MAX_FX_PARAMS = 4       ; pos, env, period (sync buzzer)

change_list SKIP MAX_TIMER_FXS*MAX_FX_PARAMS +1 ; +1 for sentinelle
          CHECK_CONFINE(change_list)

cut_list SKIP MAX_TIMER_FXS +1
          CHECK_CONFINE(cut_list)

free_slot WORD events
replay_period_in_nops WORD replay_default

dbg_tm_marker BYTE      ; tm of next event
dbg1  WORD 
dbg2  WORD 
