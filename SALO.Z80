;   <<<<< SAVE/LOAD module >>>>>
;--- Alpha 1 ---
; 2026
 ; Jan:      
  ;17: Use new track_set_loop_at
  ;14: load/save instr name
;--- Alpha 1 ---
; 2025      
 ; Dec:                           
  ;26: Use assert, remove dead code
  ;17: WTF? Line 1510 we had ld b,3 instead of ld c,3 to save track loop
;--- v0au ---
 ; Nov           
  ;25: load_file/save_file: connect_bk_io  
  ;14: save: reselect instrument
  ;13: progress_bar
  ; 7: song_track_lp: fix saving of song map
;--- v0at ---
  ; 6: phrases_lp: reorder to instr note vol (match bit and mem order)
;--- v0ar ---
 ; Oct 
  ;14: set_diapason: 16 bits now 

;--- v0aq ---   
 ; Aug
  ;28: instr_lp: load/save hard env columns separately
               ; load/save syncbuzzer 
     ; salo_code: jump block (again?)
;--- v0ap ---   
  ;17: Use connect_bk_io in save_bloc (rather than feu .write_bloc)
               ; -> serve both io_write_bloc and ramdisk 
     ; save_bloc: copy bloc from bank (since buf io in c0:4000)
     ; load_bloc: same

;--- v0ao ---
  ;16: Use IMPORT_SALO_SHARED_DEPS

;--- v0ak ---
  ; 9: save_bloc: must handle 0 = 256
     ;  Remove global track_param#:
         ; - instead # of meta params saved for each track
     ; Connect BK_IO before disc_out_close!
;--- v0aj ---
  ; 8: write_bloc/read_bloc: connect bk io as buffer is in &c0:&4000
                 ; See there for slowness concern
  ; 7: Adapt code for new track.o
     ; Fix load_col / SAVE_COL
     ; Each phrase defines its metadata size (0 for now)
 ; Mar 6 v0.0ac WIP

dev_checks = 1
need_room = 1
todo  = 1

memmap
      IMPORT "const.i"
      IMPORT "macro.i"
      IMPORT "memmap.i"
      IMPORT "import.i"
          IMPORT_SALO_DEPS()

      ORG io
      IMPORT "io.o"

buffer = salo_buf1
buffer' = salo_buf2

;--------------
disc_in_open = &BC77
disc_in_close = &BC7A
disc_in_abandon = &BC7D
disc_test_eof = &BC89   ; NC if eof
disc_out_open = &BC8C
disc_out_close = &BC8F
disc_out_abandon = &BC92

txt_get_cursor = &BB78
src_char_position = &BC1A

; Follow same ids than orgams.

fail_opening = 255
fail_doserror = 254
fail_unknownfiletype = 253
fail_unexpectedeof = 252
fail_memoryfull = 251
fail_unexpectedmess = 247
fail_bufferoverflow = 246
fail_invalidlinenumber = 244

fail_badversion = 242
fail_noblocdefined = 241
fail_cannotcopyhere = 240

fail_labelfull = 238

fail_checksum = 237

; reuse for now
fail_toomanyfilesopen = fail_memoryfull
fail_nametoolong = fail_bufferoverflow

;--------------

table_empty = 0
table_byte = 1
table_word = 2
table_ = 2

;===================================

SENTINELLE = -1
SENTINELLE_16 = &FFFF   ; -1 too, but must save 16 bits! 

      MACRO SAVE_ALT#
; For now: no alternative. 
; Must flag nevertheless (future proof).
          ld a,1:call save_a
      ENDM

      MACRO LOAD_ALT#
; For now: no alternative. 
; Must flag nevertheless (future proof).
          call load_a:cp 1:call nz,unexpected
      ENDM

      MACRO SAVE_ALT_SELECTED
; Since only one: it is necessarily the first! 
          xor a:call save_a
      ENDM

      MACRO LOAD_ALT_SELECTED
; Since only one: it is necessarily the first! 
          call load_a:or a:call nz,unexpected
      ENDM

      MACRO SAVE_SELECTED
          call save_a
      ENDM

      MACRO SAVE_SELECTED_INT
          call save_a_as_int
      ENDM

      MACRO LOAD_SELECTED
          call load_a
      ENDM

      MACRO LOAD_SELECTED_INT
          call load_a_as_int
      ENDM

      MACRO SAVE_END_OF_LIST
          ld a,SENTINELLE:call save_a
      ENDM

      MACRO IS_END_OF_LIST
;Return Z if yes
          cp SENTINELLE
      ENDM

      MACRO SAVE_END_OF_LIST_INT
; When expect an "int", cannot just poke &ff.
; It would be interpreted as a prefix.  
          call save_int_sentinelle
      ENDM

      MACRO IS_END_OF_LIST_INT
;BC = MAX_INT?  Return Z if yes
          ld hl,MAX_INT:or a:sbc hl,bc
      ENDM

      MACRO SAVE_TEXT
;For now: no text. Must but null sentinelle.
          xor a:call save_a
      ENDM

      MACRO LOAD_TEXT
;For now: text not handled
          call load_a:or a:call nz,unexpected
      ENDM

      MACRO CHECK_EQUAL x,y
      IF x-y
  !! review
      END
      ENDM

unexpected = mess
; later: dedicated error message (e.g. wrong version)

;-------------------------------
; Maybe useful code snippets when we reactive tables and/or fx.
      MACRO LOAD_TABLE
; Deserialize tables:
      ; register tables
      ; replace fx id by proper fx. 
; In: File open for read.  

          ld hl,tag_table:call check_tag

lt_lp
          call load_a
          IS_END_OF_LIST():jr z,lt_end

          ALT_TOBE()
          call load_a:or a:call z,unexpected ; Type. Actually 0: empty
          cp table_+1:call nc,unexpected
          ld de,buf_tmp
          push de
          ld (de),a:inc e
          call load_a:or a:call z,unexpected ; Data size in bytes
          ld (de),a:inc e
          ld c,a:ld b,0
          inc bc        ; +1 for loop len
          call _load_bloc

          pop hl
          call register_table
      IF 0
; register_table doesn't return carry yet
; todo: exception system instead? -> less code.
          call nc,unexpected ; error (e.g. memory full)
      END

 ; Slot for info. For now, empty
          call load_a:or a:call nz,unexpected
 ; Slot for additional field. For now, empty
          call load_a:or a:call nz,unexpected

          ALT_TOBE2()
          jr lt_lp

lt_end

      ENDM

;-----------------------------------
      ORG salo
salo_code
          jr load_file
;--------------------------------------------------
save_file
; See /save_tag/ for some design choices on format.

;in : hl pointe sur nt name
;     de sur data custom                     
;     bc longueur data custom
;--------------------------------------------------

; NB: We use exception mecanism to simplify error handling.
    ; If any error in helper's helper routine, we just exit.
          ASSERT($ == salo_code+2) ; ayane direct call

          ld (v_savesp),sp

          push bc
          push de
          push hl
          call disc_out_abandon
          call connect_bk_io

          pop hl
          call get_text_len
          ld de,disc_buffer
          call disc_out_open
          ld a,fail_opening:jp nc,os_error

          pop de
          pop bc
          ld hl,io_write_bloc
          call save
          call connect_bk_io
          jp c,disc_out_close ; exit ok

          call disc_out_abandon
          or a
          ret

;-------
load_file
;in hl: adr filename (nt)
;   de: dest meta_data
;   bc: longueur max meta_data
;out bc: longueur really copied

          ld (v_savesp),sp

          push de
          push bc
          push hl
          call disc_in_abandon
          call connect_bk_io
          pop hl
          call get_text_len
          ld de,disc_buffer
          call disc_in_open
          ld a,fail_opening
          jp nc,ol_error

          pop bc
          pop de
          ld hl,io_read_bloc
          call load
;!!! cannot jump ol_error or ol_dos_error:
;!!! (v_savesp) has been updated to load level: dangling sp.
          push af
          call disc_in_close
          pop af
          ret

      IF 0
lcp_setphrase
          call load_a
          jp row_set_phrase
      END
lcp_setins
          call load_a
          jp row_set_instr
lcp_setvol
          call load_a
          jp row_set_vol_encoded
lcp_setnote
          call load_a
          jp row_set_note

load_bloc_c_if_not_null
;Here C=0 means 0
          inc c:dec c
          ret z
          jr load_bloc_c

load_bloc_with_size
;in: N/A
;out: hl = buffer'
    ;  c = size of bloc 
          call load_c
load_bloc_c
;Like load_bloc, but size in C > 0
          ld b,0
load_bloc
;in:  bc = size. 0 means 0 (e.g. for empty field text)
;out: hl = buffer'
          ld de,buffer'
          push de
          call _load_bloc
          pop hl
          ret

_load_bloc
;in: de = dest
   ; bc = size. 0 means 0 (e.g. for empty field text)
;out: de+=bc   
          ld a,c:or b
          scf
          ret z         ; shortcut since we might ldir

          push bc       ; needed?
          call _do_load
          pop bc
          ret c
;ol_dos_err
          ld a,fail_doserror
ol_error
          push af       ; Just for A. NC & Z will be set anyway
          call disc_in_abandon
          pop af
;enchaine
exit_err
;TODO: how to report error (to user & to calling routine).
          ld sp,(v_savesp)
      IF dev_checks
          ld a,(v_savesp+1):and &FE:cp &BE:call nz,mess
      END
          or a
          ret

_do_load
      IF dev_checks
;We don't load more than 255 bytes at a time
          inc b:dec b:call nz,mess
      END
          ld a,d:cp &80:jr nc,.load_to_de
;must use tmp buf    
          push bc
          push de
          ld de,buffer'
          push de
          call .load_to_de
          pop hl
          pop de
          pop bc
          ldir          ; even if error. Nevermind
          ret

.load_to_de
          call get_bk_connected
          push af
          call connect_bk_io
jp_io_load call &BE00
          pop bc        ; preserve carry
          jp connect_b

version = 0


;----------------------------
load
;IN: BC: meta data to read
   ; DE: dest meta data
   ; HL: Actual io_load_bloc routine (file or mem)
;----------------------------

          ld (v_savesp),sp
          ld (jp_io_load+1),hl

          push bc
          push de
          ld hl,tag_ayane:call check_tag
          call Reset_tracks_and_subsongs
          call phrase_reset

; ----- Description -----
          LOAD_TEXT()   ; author
          LOAD_TEXT()   ; album/title/description
; ----- General Delai_ui --------
      IF need_room
; Group values by module and bloc load
      END
          call load_a:call set_delai_ui
; ----- Diapason ---
          call load_hl:call set_diapason
; ----- Custom -----
          call load_bc
          pop de        ;dest
          pop hl        ;len
          or a
          sbc hl,bc
          add hl,bc
          jr nc,.ol_wantge

;copy len indicated by caller (hl here), skip the rest.
          push bc
          ld c,l
          ld b,h
          push bc
          call _load_bloc

          pop bc
          pop hl

          or a
          sbc hl,bc
          ld c,l
          ld b,h
          call skip_bloc
          jr .ol_com

.ol_wantge
;copy len indicated by file (bc) <= wanted len
          call _load_bloc

.ol_com
;From now : every error is fatal.

; ----- Tables/assets -----
.tables
          ld hl,tag_table:call check_tag
;TODO: For now expect empty list
          call load_a
          IS_END_OF_LIST()
          call nz,unexpected

          call load_a
      IF todo
 ; call Asset_selected 
 ; for now, assume 0
      END
          or a:call nz,unexpected

; ----- Instruments -----
          ld hl,tag_instr:call check_tag
.instr_lp
; -- Id    
          call load_a
          IS_END_OF_LIST():jp z,instr_end
          ld (cur_instr),a ; for dbg
          push af
; -- Alternative # 
          LOAD_ALT#()
; --- instr replay freq.
          call load_hl
          ld bc,replay_50_08Hz
          or a:sbc hl,bc:call nz,unexpected
; -- Type
          call load_a   ; Type (default, chip_down_arp ...)
          push af
; -- Meta flags 
  ; Bit 0: built-in instr?
         ;  For now, not such thing -> 0
      ;21: 12bits vs 16bits
          call load_a:or a:call nz,unexpected
; -- Params        
          call load_bloc_with_size ; get c=size
          pop af
          ld b,a
          pop af        ; id
          call New_instr
; -- Name       
          call load_bloc_with_size
; must push NT
          add hl,bc
          xor a         ; also for NC
          ld (hl),a
          sbc hl,bc
          inc c:dec c
          call nz,instr_set_name
; -- Table (by columns)
  ; ---- rows#       
          call load_b
;for some reason 0 rows is accepted
;(note: instr_set_rows# currently set 256 rows for b=0)
          ld a,b:or a
          jr z,.col_end ; no col if no rows
          call instr_set_rows#
; -- work by column (not necessarily same order than in-memory)
; Some column might be missing, so we rely on type. Plus, future-proof
.col_lp
col_end_mark = 0
col_flag = 1
col_vol = 2
col_arp = 3
col_pitch = 4
col_noise = 5
col_hard_type = 6       ; +trigger flag
col_hard_arp = 7
col_hard_pitch = 8
col_fx0_type = 9
col_fx0_param = 10
col_fx0_arp = 11
col_fx0_pitch = 12
col_fx1_type = 13
col_fx1_param = 14
col_fx1_arp = 15
col_fx1_pitch = 16

          call load_a
          ASSERT(col_end_mark == 0)
          or a
          jr z,.col_end
          call load_col
          jr .col_lp
.col_end
  ; ---- row loop (even if no rows)
          call load_b
no_loop_tag = -1
          ASSERT(no_loop_tag == -1)
          ld a,b:inc a
          call nz,instr_set_loop
;.ok_table

;enchaine     
.instr_finalize
          LOAD_ALT_SELECTED()
          jp .instr_lp
.instr_end
;--Select
          LOAD_SELECTED()
          call Song_select_instr

; -------------------
; ----- Phrases -----
; -------------------
          ld hl,tag_phras:call check_tag

phrases_lp
; -- Id (or sentinelle end)
          call load_int
          IS_END_OF_LIST_INT()
          jr z,.phrases_end

; -- Alternative #
          LOAD_ALT#()
; -- Type . For now, just one type
   ; In the future: group (nested phrase)
          call load_a:cp type_phrase:call nz,unexpected

          ld a,b:or a:call nz,to_be_implemented ; no id > &100 for now
          ld a,c
          call song_select_new_phrase

; -- delai_ui  
; !! not yet plugged in phrase header (need some room?)
; 0 for now
          call load_a:or a:call nz,unexpected
; -- Name
          LOAD_TEXT()
; -- Color and meta infos 
          call load_bloc_with_size
          call phrase_set_params
  ; ---- rows# 
          call load_b
          inc b:dec b:jr z,.finalize_phrase
  ; ---- rows
.rowlp
          push bc
          xor a:call phrase_select_new_row
; -- duration
          call load_a
; Explicit duration rather than using phrase_select_row_at:
;   simpler and handle case duration=0
; Can use 'add' since duration was init with 0
          call row_add_duration
; -- Phrase flag
          call load_c
; -- FX
;fx load
          ld b,4
.lcp_fxlp
; !! copypasted from compile 
          rr c:jr nc,lcp_fxok ; flag FX 0, 1, 2, 3

      BRK
; must check / reactivate APIs for fx
          push bc
          ld a,4:sub b:ld c,a ; Fx #
          call load_a   ; Fx id
      IF 0
          call row_set_fx

          ld c,a
.lcpfixlp
; 000000-> no more param
; ????01-> byte
; ????10-> word
; ????11-> word (table)

          ld a,c:or a:jr z,lcpfixend

          srl c:jr c,lcpfix_x1
; necessarily 10 here
          srl c
      IF dev_checks
          call nc,&BE00
      END
          call load_bc
          call fx_append_param_word
          jr lcpfixlp

.lcpfix_x1
          srl c:jr nc,lcpfix_01
; 11: table
          call load_a
          call fx_append_param_table
          jr lcpfixlp

.lcpfix_01
          call load_a
          call fx_append_param_byte
          jr lcpfixlp

.lcpfixend
          pop bc
      END

.lcp_fxok
          djnz lcp_fxlp

      IF 0
          rr c:call c,lcp_setphrase
      ELSE
          rr c:call c,unexpected ; eoc link should have been followed
      END
          rr c:call c,lcp_setins
          rr c:call c,lcp_setnote
          rr c:call c,lcp_setvol

          pop bc
          djnz .rowlp
.finalize_phrase
; Needed to populate phrase.va_row_pnt
; Otherwise, phrase.connect_current_row would create a ghost row.
      IF todo
; should it be done at phrase creation instead?
      END
 ;         ld de,0
  ;        call phrase_select_row_at   ; actually creates an empty row?
          LOAD_ALT_SELECTED()
          jp phrases_lp

.phrases_end
          LOAD_SELECTED_INT()
          call song_select_phrase
; "saving position" Discarded:
    ; - not that useful
    ; - would need to be done on a phrase-by-phrase basic
        ; otherwise, problem when no phrase exists.
  ;        call load_hl
  ;        ex de,hl
  ;        call phrase_select_row_at


; ------------------
; ----- Tracks -----
; ------------------
          ld hl,tag_track:call check_tag
          call txt_get_cursor
          dec l         ; compensate NL
          dec l         ; logical to physical row
          ld h,5
          call src_char_position
          ld (progress_adr),hl

track_lp
          call progress_bar
          call load_a   ; id
          IS_END_OF_LIST():jp z,track_end
;--alt            
          ld (dbg_current_track),a
          push af
          LOAD_ALT#()
;--Params 
;None for now                        
      IF track_param#
          call load_bloc_with_size
          ld a,c:cp track_param#:call nz,unexpected
          pop af
!! todo: pass params
      ELSE
          call load_a:or a:call nz,unexpected
          pop af
      END
          call Song_select_new_track
;-- Not: no name associated, annotations will be more versatile

;--Get all events
          ld hl,timestamp
          xor a
          ld (hl),a:inc hl
          ld (hl),a:inc hl
          ld (hl),a
          call get_current_track_header
.hooklp
.evtlp
          ld hl,timestamp ; current timestamp before update
; -- Type
          call load_a
          ASSERT(type_evt_null == SENTINELLE) ; we don't discriminate
; Evt null = intermediate hook, just to handle duration > &10000
; No actual event to encode, just update timestamp,
; subsequent setters (e.g. Set_phrase_at_t) will create hook as needed.
          IS_END_OF_LIST():jr z,.evtend
          cp type_evt_stop:jr z,.track_stop
          cp type_evt_loop:jr z,.track_loop
          ASSERT(type_evt_change_phrase == 1)
          dec a:jr z,.set_phrase
          ASSERT(type_evt_transpose == 2)
          dec a:jr z,.set_transpose
          call unexpected

.set_phrase
          call load_a_as_int
          call Set_phrase_at_t
          jr .evtlp

.set_transpose
          call load_a
          call Set_transpose_at_t
          jr .evtlp

.track_loop
          ld c,3
          call load_bloc_c
          ex de,hl
          ld hl,timestamp
          call track_set_loop_at
; End of track: no other event or duration
          jr .track_next

.evtend
          call load_bc  ; duration
          ld hl,timestamp
          ld a,c:add (hl):ld (hl),a:inc hl
          ld a,b:adc (hl):ld (hl),a:inc hl
          jr nc,$+3:inc (hl)
          jr .hooklp

.track_stop
; here bc= last duration met
      IF todo
; review that. should use track_set_stop_at (todo)
      END
          ld e,c:ld d,b
          call Set_last_hook_duration ; see there for rationale
.track_next
          LOAD_ALT_SELECTED()
          jp track_lp

track_end
          LOAD_SELECTED()
          call Song_select_track

; -------------------
; ----- Songs -------
; -------------------
.songs
          ld hl,tag_song:call check_tag

;Use ids for subsong
; - more generic / future-proof (for import of tracker that allows that)
; - consistent with other assets (hence same UI and factor opportunity)

.song_lp
          call load_a
          IS_END_OF_LIST():jr z,.song_end

          call Subsong_add
; -- Alternative #
          LOAD_ALT#()
; -- Name 
          LOAD_TEXT()
; -- Tracks used
.song_track_lp
          call load_a
          IS_END_OF_LIST():jr z,.song_track_end
          ld c,a
          call load_bloc_c_if_not_null
          call Subsong_add_track
          jr .song_track_lp
.song_track_end

          LOAD_ALT_SELECTED()
          jr .song_lp
.song_end
; --
          LOAD_SELECTED()
          call Song_select_subsong

; ----------------
; sample
; ----------------
; No samples for now
          ld hl,tag_smpl:call _tag_and_sentinelle

; ----------------
; Bookmarks
; ----------------
; 0 items for now
          ld hl,tag_book:call _tag_and_sentinelle

; ----------------
; Extra data
; ----------------
; 0 items for now
          ld hl,tag_xtra:call _tag_and_sentinelle

; ----------------
; History
; ----------------
; 0 items for now
          ld hl,tag_hist:call _tag_and_sentinelle

; ----------------
; Finito
; ----------------
          ld hl,tag_end
;enchaine
check_tag
;In: hl = tag
;Exit in case of error
          call check_tag4
          scf           ; For final success exit
          ret z
          jp ol_error

check_tag4
;check 4-bytes tag 
; Return Z if ok, NZ otherwise (A=error)
          call print_tag

          call check_tag_
          call z,check_tag_
          ld a,fail_badversion
          ret           ; Z if ok

check_tag_
          push bc
          call load_bc
          ld a,c
          cp (hl)
          jr nz,_ct_
          inc hl
          ld a,b
          cp (hl)
_ct_
          ld a,fail_unknownfiletype
          inc hl
          pop bc
          ret           ; Z if ok

_tag_and_sentinelle
          call check_tag
          call load_a:cp SENTINELLE:call nz,unexpected
          ret

load_col
; In: A= col id
    ; C= rows#
          push af
          call load_a
; How each instr column (flags, arp, ...) is encoded
; Will allow:
   ; - indirection (table) like in 
   ; - mix-in special handling (like chipnsfx's 
; For now all cols have the same type (saved: future-proof) 
column_type_default = 0 ; reserved
column_type_const = 1   ; not used
column_type_table = 2   ; not used
column_type_table' = 3  ; table with special modulo
column_type_custom = 4  ; only type used (for serialization)
column_type_ramp = 5    ; not used (future: mimick chipnsfx)
          cp column_type_custom:call nz,unexpected ;custom = row data

          call load_bloc_with_size

          pop af
          ASSERT(col_flag == 1)
          dec a:jp z,set_flags
          dec a:jp z,set_vols
          dec a:jp z,set_arps
          dec a:jp z,set_pitchs
          dec a:jp z,set_noises
          dec a:jp z,set_hard_types
          dec a:jp z,set_hard_arps
          dec a:jp z,set_hard_pitchs
          dec a:jp z,set_fx0_types
          dec a:jp z,set_fx0_params
          dec a:jp z,set_fx0_arps
          dec a:jp z,set_fx0_pitchs
          dec a:jp z,set_fx1_types
          dec a:jp z,set_fx1_params
          dec a:jp z,set_fx1_arps
          dec a:jp z,set_fx1_pitchs
          call unexpected

load_b
          call load_a
          ld b,a
          ret

load_c
          call load_a
          ld c,a
          ret
load_a
          push hl
          push de
          push bc
          ld de,v_temp_word
          ld bc,1
          call _load_bloc
          dec de
          ld a,(de)
          pop bc
          pop de
          pop hl
          ret c
ol_err_eof
          ld a,fail_unexpectedeof
          jp ol_error

load_a'
          ld a,(de):inc e
          ret nz
          push af:push bc:push de:push hl
          ld bc,&0100
          call _load_bloc
                        ; for some reason DE<>buffer+&100
          pop hl:pop de:pop bc:pop af
          ret

load_hl
          push bc
          call load_bc
          ld l,c
          ld h,b
          pop bc
          ret

load_bc
          push hl
          push de
          ld de,v_temp_word
          ld bc,2
          call _load_bloc
          ld bc,(v_temp_word)
          pop de
          pop hl
          ret c
          jr ol_err_eof


skip_bloc
;bc = size
          ld a,b
          or c
          ret z
          call load_a
          dec bc
          jr skip_bloc


tag_ayane BYTE "AYA!",0
tag_table BYTE "Tabl",0
tag_instr BYTE "Inst",0
tag_phras BYTE "Phrs",0
tag_track BYTE "Trck",0
tag_song BYTE "Song",0
tag_smpl BYTE "Smpl",0
tag_book BYTE "Book",0  ; bookmarks
tag_xtra BYTE "Xtra",0
tag_hist BYTE "Hist",0
tag_end BYTE "End!",0
faketag_ok BYTE "Ok!",0


;--------------------------------------------------
save
; See /save_tag/ for some design choices on format.

;in : de sur data custom                     
;     bc longueur data custom
;--------------------------------------------------
          ld (v_savesp),sp
          ld (jp_io_save+1),hl

          call init_buffer_w

; -- Save state 
      IF todo
; for table as well
      END
          call Song_get_instr:push af
;           call phrase_get_row_position:push hl
          call song_get_current_phrase:push af
          call get_current_track_header:push af ; also gives ID
          call Song_get_current_subsong:push af

; ----- Signature
          ld hl,tag_ayane:call save_tag
; ----- Description -----
          SAVE_TEXT()   ; author
          SAVE_TEXT()   ; album/title/description
; ----- General Delai_ui --------
      IF need_room
; Group values by module and bloc save
      END
          call get_delai_ui:call save_a
; ----- Diapason ---
          call get_diapason:call save_hl
; ----- Custom -----
; Aka metadata (peut etre de longueur 0)
;-> Info relative to editor itself, but not to the song.
; (<>0 for nrt)
          call save_bc
          ex de,hl
          inc b:dec b:call nz,to_be_implemented ; save_bloc: 256 max
          inc c:dec c:call nz,save_bloc
; ----- Tables -----
.tables
          ld hl,tag_table:call save_tag
 ;TODO. For now: 0 tables: sentinelle.
          SAVE_END_OF_LIST()
          xor a:SAVE_SELECTED()

; -----------------------
; ----- Instruments -----
; -----------------------
          ld hl,tag_instr:call save_tag

; Selected instr:
  ; - save before changed in loop
  ; - written at the end
          call Song_get_instr
          push af

          ld a,1        ; skip instr 0 (null)
.instr_lp
          push af
          call Song_select_instr
          jp z,.instr_next
; -- Id    
;Here: A= type instr (default, chip_down_arp ...)
     ; H= params#
     ; L= row size 
          inc l:call nz,unexpected ; Only variable rows 
          dec l
          pop bc:push bc ; b = ID (was a)
          push hl
          push af       ; type
          call save_b
; -- Alternative #        
          SAVE_ALT#()
; -- Instr replay frequence
; Futur: faster than player (e.g. 300 hz) or slower
; Note: "same as player" wouldn't make much sense, we want those
      ; decoupled.     
; call instr_get_replay_period
          ld hl,replay_50_08Hz:call save_hl
; -- Type
          pop af
          ld (cur_instr_type),a
; For now, only type 2 "default"
          cp 2:call nz,unexpected
          call save_a
; -- Flags 
  ; Bit 0: built-in instr?
         ;  For now, not such thing -> 0
  ; Bit 1: (todo): 12bits vs 16bits vs ????  (issue #1)
          xor a:call save_a
; -- Params   
; Storing number of params allows future extension.
; Number of params only depends on type (and version!),
; yet for simplicity, we store it for each instrument.
; As a benefit, we'll be able to omit
; storage of trailing default params.
          call get_instr_pnt
          instr_head_rows ** inc hl
          pop bc:push bc ; get B=params#
          push hl
          instr_head_ext - instr_head_rows ** inc hl
          ld c,b
          call save_bloc_with_size0
; -- Name    
          call instr_get_name
          call save_str
; -- "Table"
          pop hl
          pop bc        ; c = row size (was L)
          ld a,c
          inc a:call nz,unexpected ; only dynamic (needed and suffisient)

          call instr_get_rows#
          call save_c
 ; 0 rows allowed (for chipnsfx? more generic?)
 ; if 0 rows, no col
          inc c:dec c:jp z,.finalize_instr
; -- work by column (not necessarily same order than in-memory)
; Each column has a header (its type)
   ; -> future proof for table indirection
   ; custom= raw data (discriminate 8 vs 16 bits
      MACRO SAVE_COL type,get_field
          ld a,type:call save_a
          ld a,column_type_custom:call save_a
          ld hl,buffer'
          call get_field
          ld c,a
          call save_bloc_with_size0
      ENDM
  ; --- flag        
          SAVE_COL(col_flag,get_flags)
  ; --- vol / env type
          SAVE_COL(col_vol,get_vols)
  ; --- arp
          SAVE_COL(col_arp,get_arps)
  ; --- pitch
          SAVE_COL(col_pitch,get_pitchs)
  ; --- noise
          SAVE_COL(col_noise,get_noises)
  ; --- hard env
          SAVE_COL(col_hard_type,get_hard_types)
          SAVE_COL(col_hard_arp,get_hard_arps)
          SAVE_COL(col_hard_pitch,get_hard_pitchs)
  ; --- special fx0.
          SAVE_COL(col_fx0_type,get_fx0_types)
          SAVE_COL(col_fx0_param,get_fx0_params)
          SAVE_COL(col_fx0_arp,get_fx0_arps)
          SAVE_COL(col_fx0_pitch,get_fx0_pitchs)
  ; --- special fx1.
          SAVE_COL(col_fx1_type,get_fx1_types)
          SAVE_COL(col_fx1_param,get_fx1_params)
          SAVE_COL(col_fx1_arp,get_fx1_arps)
          SAVE_COL(col_fx1_pitch,get_fx1_pitchs)

          ld a,col_end_mark:call save_a

.finalize_instr
  ; ---- row loop (even if no rows. nevermind, KISS)
          call instr_get_loop
          jr c,$+4:ld b,no_loop_tag
          call save_b
;enchaine                         
          SAVE_ALT_SELECTED()
.instr_next
          pop af
          inc a
          cp 254        ; 254: reserved for mute. 255 for sentinelle
          jp nz,.instr_lp

          SAVE_END_OF_LIST() ; no more instrs

          pop af
; selected instr
          SAVE_SELECTED()
          call Song_select_instr

; -------------------
; ----- Phrases -----
; -------------------
          ld hl,tag_phras:call save_tag

          call song_get_current_phrase
          push af

phrase_param# = clip_header_size-fc_color

; --- Each phrase
          xor a         ; a = phrase #
.phrases_lp
          push af
          call song_select_phrase
          jp z,phrases_next

; -- Id
          pop af
          push af
          call save_a_as_int
; -- Alternative #
          SAVE_ALT#()
; -- Type. For now, just one type
          call connect_phrase_header
          CHECK_EQUAL(fc_type,1)
          fc_type ** inc hl
          ld a,(hl):inc hl
          cp type_phrase:call nz,unexpected
          call save_a
; -- delai_ui  
; !! not yet plugged in phrase header (need some room?)
          xor a:call save_a ; 0 means: use global setting
; -- Name 
          CHECK_EQUAL(fc_name,2)
          call save_str_pnt
; -- Color and meta infos
          CHECK_EQUAL(fc_color,4)
          ld c,phrase_param#
          ASSERT(phrase_param# > 0) ; At least color
          ASSERT(phrase_param# < 256)
          call save_bloc_with_size
; -- rows# 
; We save number of row, sentinelle would be cumbersome
          call phrase_get_rows#
          call save_a
          or a:jr z,.row_end
; -- rows
          call connect_phrase_begin
.row_lp
      IF dev_checks
; Check pnt 
          ld a,h:cp &40:call c,mess
          cp phrases_/&0100:call nc,mess
      END

          ld a,(hl):inc hl ; duration
          ld b,(hl)     ; flags (needed for test eoc)
      IF todo
;!!! a bit brittle.
; To accelerate a bit, we assume encoding of 'set phrase' pseudo-fx.
      END
      IF need_room
; factorize with compile
; (factorize more: loop+ flattenization ?)
  ; Flattenization: not worth it?
          ; - Probleme: instr id vs LSB. (instead, pass flag?)
          ; - Different code: e.g. flag instrument not stored
   ; (no, this is not a problem, as must be piloted by dynamic switchs)
          ; - First: must clean hack minimala
      END
          bit bit_fx0,b:jr z,.okrow
; End of phrase or link to next chunk 
          dec hl        ; rewind    
          call is_end_of_phrase
          jr z,.row_end
          call follow_link_if_eoc
          jr .row_lp    ; read 1st row of new chunk
.okrow
          inc hl
; -- duration
          call save_a
; -- Phrase flag
          call save_b
; -- FX
; No fx used for now. We verify that
          ld a,b
          and mask_fx0 AND mask_fx1 AND mask_fx2 AND mask_fx3
          call nz,unexpected

; -- Instr
  ; - empty phrase (actually contains one empty row)
          bit bit_instr,b:jr z,.ok_instr
          call save_ldi
.ok_instr
; -- Note
          bit bit_note,b:jr z,.ok_note
          ld a,(hl):inc l
          NOTE_DECODE()
          call save_a
.ok_note
; -- Vol
          bit bit_vol,b:jr z,.ok_vol
          call save_ldi
.ok_vol
; Note: we don't store "reserved byte",
      ; as it is meant to be housekeeping 
          inc hl
          jp .row_lp

.row_end
          SAVE_ALT_SELECTED()

.phrases_next
          pop af
          inc a
          jp nz,.phrases_lp

          SAVE_END_OF_LIST_INT()
          pop af
          SAVE_SELECTED_INT()
; DISCARDED !
     ;     call phrase_get_row_position
     ;     call save_hl


; ------------------
; ----- Tracks -----
; ------------------

          ld hl,tag_track:call save_tag

          call get_current_track_header ; also gives ID
          push af

; --- Each track
          xor a         ; track id
.track_lp
          push af
          ld (dbg_current_track),a
          call Song_select_track ; needed to get loop
          call get_current_track_header
          ld e,(hl):inc hl
          ld d,(hl):inc hl
          ld a,e:or d:jp z,.track_next ; don't store empty track!
;-- Id
          pop af
          push af
          call save_a
; -- Alternative #
          SAVE_ALT#()

;-- Params (none for no)
      IF track_param#
          ASSERT(track_param# < 256)
          call save_bloc_with_size0
      ELSE
          xor a:call save_a
      END

;-- Events (flatten them)
          ex de,hl      ; head of list of hooks
          call connect_bk_track
.hooklp
      IF dev_checks
          ld a,h:cp track_events/&0100:call c,mess
          cp track_events_/&0100:call nc,mess
      END
          push hl
          ld (current_hook),hl
          idsz ** inc hl
; -- Duration 
;will be stored after events,
;since we don't need it for fake events loop/stop
;and /load/ wouldn't know beforehand the kind of event.
          ld c,(hl):inc hl
          ld b,(hl):inc hl
          push bc
; -- Follow list of event 
          call Next_node
; Might be empty (intermediate hook or empty track)
          jr z,.evtend
.evtlp
          push hl
          ld (dbg_current_evt),hl
          idsz ** inc hl
          ld e,(hl):inc hl
          ld d,events / &0100
          dec de
          ld a,(de)     ; type
          call save_a
          ASSERT(type_evt_comment == 0)
          or a:call z,to_be_implemented ; 0: comment
          cp type_evt_change_phrase:jr z,.set_phrase
          cp type_evt_transpose:jr z,.set_transpose
          cp type_evt_loop:jr z,.set_loop
;Note: event null is for serialization 
;but doesn't exist in ram (null link used instead)
      IF todo
; evt_stop (<> than letting the track run of last phrase)
      END
          call unexpected

.set_phrase
          call Next_node ; phrase start in chunk
          call connect_bk_phrase
          ld l,chunk_start+fc_index
          ld a,(hl)
          call save_a_as_int
          call connect_bk_track
;Note: internally phrase is always last event,
     ; but in .aya we store sentinelle anyway (future-proof)
          jr .evtnxt

.set_transpose
          ld a,(hl)
;remove encoding x2
          sra a:call c,unexpected
          call save_a
          jr .evtnxt

.set_loop
          ld hl,(current_hook)
; pnt to loop
          ld a,(hl):inc hl
          ld h,(hl):ld l,a
          res 7,h
          call get_timestamp_from_hook
      IF dev_checks
          call nc,mess
      END
          ld l,c:ld h,b
          ld c,3
          call save_bloc

; Necessary last event, and marker end of track, like "stop"
; Don't store sentinelle then, or duration.
          pop hl
          pop bc
          pop hl
          jr .track_finalize

.evtnxt
          pop hl
          call Next_node
          jr nz,.evtlp
.evtend
; -- marker end of list   
          SAVE_END_OF_LIST()
; -- store duration
          pop bc
          call save_bc
; -- end of track?
          pop hl
          call connect_bk_track
          ld e,(hl):inc hl
          ld d,(hl)
          ex de,hl
;shouldn't happen: .set_loop stopped iteratiorn 
          bit 7,h
          jr nz,.track_finalize
          ld a,l:or h
          jp nz,.hooklp

          ld a,type_evt_stop:call save_a
;enchaine
.track_finalize
          SAVE_ALT_SELECTED()
.track_next
          pop af
          inc a
          cp MAX_TRACKS
          jp nz,.track_lp

          SAVE_END_OF_LIST()
          pop af
          SAVE_SELECTED()

; -------------------
; ----- Songs -------
; -------------------
          ld hl,tag_song:call save_tag
          call Song_get_current_subsong
          push af

; -- For now, just one subsong 
; Id 
          xor a:call save_a
; -- Alternative #
          SAVE_ALT#()
; Name/comment 
          SAVE_TEXT()
; Tracks used 
          call Song_get_first_track
          jr z,.song_track_end
.song_track_lp
          push hl
          ss_trackid ** inc l
          ASSERT(ss_size > 0)
          ld c,ss_size:call save_bloc_with_size
          pop hl
          call Song_get_next_track
          jr nz,.song_track_lp
.song_track_end
          SAVE_END_OF_LIST() ; no more 
; -- Selected alt
          SAVE_ALT_SELECTED()
;
          SAVE_END_OF_LIST() ; no more subsongs
; -- Selected subsong
          pop af
          SAVE_SELECTED()

; ----------------
; sample
; ----------------
          ld hl,tag_smpl:call save_tag
; No samples for now
          SAVE_END_OF_LIST()

; ----------------
; Bookmarks
; ----------------
          ld hl,tag_book:call save_tag
; 0 items for now
          SAVE_END_OF_LIST()

; ----------------
; Extra data
; ----------------
          ld hl,tag_xtra:call save_tag
; 0 items for now
          SAVE_END_OF_LIST()

; ----------------
; History
; ----------------
          ld hl,tag_hist:call save_tag
; 0 items for now
          SAVE_END_OF_LIST()

; ----------------
; FINITO
; ----------------
          ld hl,tag_end:call save_tag
          call flush

; -- Restore state
          pop af:call Song_select_subsong
          pop af:call Song_select_track
          pop af:call song_select_phrase
;          pop de:call phrase_select_row_at
          pop af:call Song_select_instr

;enchaine
print_ok
          ld hl,faketag_ok
;enchaine
print_tag
          push af:push bc:push hl
          ld b,4
          call print_sized_str
          call print_nl
          pop hl:pop bc:pop af
          scf           ; For final exit (success)
          ret

print_sized_str
          ld a,(hl):inc hl
          call &BB5A
          djnz print_sized_str
          ret

print_nl
          ld a,10:call &BB5A
          ld a,13:jp &BB5A
          ret
      IF 0
          push ix:push iy
          push af:push bc:push de

; -- reset progress bar --
          ld hl,(vdisp_scrpos)
          inc hl:ld (progress_adr),hl
          xor a:ld (progress_pix),a
          pop hl:pop de:pop bc:pop af
          pop iy:pop ix
          ret
      END


save_tag
;in: HL: NT string tag

; NB: We don't save version #:      
     ; - Instead we could use new tags (e.g. Instr2)
     ; - We try to be retrocompatible by using 
; NB2: We don't systematically save length of associated chunk:
     ; - For fixed-size chunk that's useless.
     ; - Sometimes it's just a pain to collect total size.
     ; - We don't plan for an "IFF" generic reader anyway.
     ; - YAGNI

          call print_tag
;enchaine
.lp
; Save str (without including 0)
          ld a,(hl):inc hl:or a:ret z
          call save_a
          jr .lp

save_str_pnt
; If null pnt, save null str (0)
; In: hl: pnt to str pnt!
;Out: hl+= 2
          ld a,(hl):inc hl
          or (hl):inc hl:jp z,save_a
          call to_be_implemented ; read pointer
save_str
;in: Hl: str
          call get_len
          ld c,a
          jp save_bloc_with_size0

save_int_sentinelle
; save max value possible
          ld bc,SENTINELLE_16:call save_bc
          ret

save_a_as_int
          push bc
          ld c,a:ld b,0
          call save_int
          pop bc
          ret

save_int
; 'Variable length int' (well, only up to 13 bits!)
; Save on 8 bits for < &e0,
       ; 16 bits for &e0 .. &1fff
; Rationale: most phrase/instr idx will be < 256.
           ; Yet we want to allow to go beyond that 
; &e0 is kind of an arbirary cut:
     ; - most value while stay on 8 bits, while authorising crazy big
       ; indices (I don't think one will need 8192 phrases)
; IN: bc = value
MAX_INT = &1FFF
          ld a,b:or a:jr nz,.big
          ld a,c:cp &E0:jr nc,.big
          jr save_a
.big
; don't bother compute "bc - &e0". Privilegiate simple code
          ld a,b:cp &20:call nc,unexpected
          or &E0:call save_a
          jr save_c

load_a_as_int
;Enfore this might be a value > &100
;But for now not supported.
;If assert, caller must use load_int instead
; (require new api to pass id then)
          call load_int
          inc b:dec b:call nz,to_be_implemented
          ld a,c
          ret

load_int
          call load_a
          ld c,a:ld b,0
          cp &E0
          ret c
;.big
          and &1F:ld b,a
          jp load_c


save_hl   ld a,l:call save_a
save_h    ld a,h:jr save_a
save_ldi  ld a,(hl):inc hl:jr save_a ; not really "ldi", same spirit
save_c    ld a,c:jr save_a
save_bc   ld a,c:call save_a
save_b    ld a,b
;enchaine
save_a
      IF need_room
; Factorize with compile.poke_* 
      END
; debug
      IF 0
          push af
          call get_bk_connected
          push af
          call connect_bk_track
          ld a,(&466B):cp &4C:call nz,&BE00
          pop af
          call connect_a
          pop af
      END
          push hl
buf_pnt_w ld hl,buffer
          ld (hl),a
break     nop
          inc l
          ld (buf_pnt_w+1),hl
          pop hl
          ret nz
;flush full buffer          
          push hl
          push bc
          push af
          ld c,0
          call _flush
          pop bc:ld a,b ; POP A without touching F
          pop bc
          pop hl
          ret


flush
; Flush part of buffer that is filled (no-op if empty)
          ld a,(buf_pnt_w+1)
          or a
          ret z
          push bc
          ld c,a
          call _flush
          pop bc
          ret

_flush
;c=0 means 256
          push hl
          ld hl,buffer
          call _save_bloc
          pop hl
;enchaine
init_buffer_w
          push hl
          ld hl,buffer
          ld (buf_pnt_w+1),hl
          pop hl
          ret

save_bloc_with_size0
; In :hl = source
     ; c = size (0 for 0)
          call save_c
          inc c:dec c
          ret z
          jr save_bloc
save_bloc_with_size
; In :hl = source
     ; c = size (0 for 256)
;Out :hl += size
     ;bc preserved
          call save_c
;enchaine
save_bloc
; Don't put in buffer. 
; Instead, flush buffer and call io_save_block directly

; In :hl = source
     ; c = size (0 for 256)
;Out :hl += size
     ;bc preserved
          call flush    ; must flush data already there
; Enchaine
_save_bloc
;In: hl = source
   ;  c = size. 0 means 256 (for flush)
          push bc:push de
          ld b,0:dec c:inc bc
          call _do_save
          pop de:pop bc
          ret c
; Enchaine
os_err_dos
;TODO: how to report error (to user, and to calling routine).
          ld a,fail_doserror
os_error
          jp exit_err

_do_save
          ld a,h:cp &80:jr nc,.save_from_hl
;Must copy out of bank
          ld de,buffer
          push de
          push bc
          ldir
          pop bc
          ex (sp),hl    ; hl=buffer
          call .save_from_hl
          pop hl        ; source+size
          ret

.save_from_hl
          call get_bk_connected
          push af
          call connect_bk_io
jp_io_save call &BE00
          pop bc        ; preserve carry
          jp connect_b


get_text_len
          push hl
          ld b,255
gtl_lp    inc b
          ld a,(hl)
          inc hl
          or a
          jr nz,gtl_lp
          pop hl
          ret

progress_bar
; NB: progress_adr set by org.
          push hl
          ld hl,(progress_adr)
          ld a,h:or &E0:ld h,a ; +4 lines + sanity
          ld a,(progress_pix)
          scf:rra:jr nc,pbar_ok
          inc hl:ld a,&80
pbar_ok
          ld (progress_adr),hl
          ld (progress_pix),a
          and &77:ld (hl),a
          pop hl
          ret


; Stable next import for small changes
; Also easier debugging, as vars locations are stable.
      FILL -$ AND &0F,&F7

; -------- Local vars -----------------

v_savesp WORD 0         ; Ease error handling / exit
v_temp_word WORD 0
cur_instr BYTE 0        ; for dbg
cur_instr_type BYTE 0   ; idem
dbg_current_track BYTE 0 ; idem
dbg_current_evt WORD 0
current_hook WORD 0
timestamp TIME(0)
timeloop  TIME(0)
progress_adr WORD 0
progress_pix BYTE 0

salo_end
          LIMIT(ged)


