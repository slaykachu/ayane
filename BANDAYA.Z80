; Screen: Raster / Rupt under int for status bar.
        ; Transitions.

; 2025 June 8
   ; Special ayane: no need r9=0, bandeau 7*8 lignes
                  ; !!! Not Nop-synchro (so )

raster = 1              ; debug rasters in border
todo  = 1

      IMPORT "memmap.i"
      IMPORT "memcpc.o" ; for connect_bk_io

      IF BK_IO - &C0
 !!! review that
      END
connect_bk_screen = connect_bk_io

mc_set_mode = &BD1C
;kl_rom_select = &B90F
;kl_rom_deselect = &B918

ink1  = &46             ; in status bar
r1    = 40
r1'   = 48              ; bandeau and sequencer
r2    = 46              ; default
r2'   = 50              ; value for bandeau
r3    = &FC
r4    = 38
r4'   = 31
r4''  = 6               ; status (56 line total)
r6    = 25
r6_sequencer = 21
r7    = 30
r7'   = 27
r7t   = 34
r12'  = &10             ; Main r12 in /offset/

      MACRO ASSERT p
      IF p:ELSE
 !! error
      END
      ENDM

      MACRO CHECK_MSB
; For optim purpose, we assume all routines share same msb
      IF $/&0100 - int0/&0100
 !! error distinct msb
; if it happens, assemble routine at another place
      END
      ENDM

; -------------------------------

      MACRO INT_RET col,nxt
          CHECK_MSB()
; !! call reused for dispatch (cf int4)
; Must leave the call
          call _int_ret
      IF raster
      BYTE col
      END
; Hack: we cannot use 'if $-nxt' since nxt isn't known yet.
      ; So we rely on multi-definition allowed if same value.
zero  = $-nxt
      ENDM

      IF $ AND &C000:ELSE
!!! Cannot be in page 0000, since called while rom connected
      END

int0
          CHECK_MSB()
; Expect VSYNC. if not: don't change int#
          ld b,&F5:in a,(c):rra
          jp nc,_int_ret_dbg
;          jr nc,_int_ret_

; Just in time rupture. Sweet!
      IF todo
; Proper r2 transition for OSSC
      END
          ld b,8:djnz $
          ld de,r2*&0100 + r2'
r2trans0 = $ + 1
          call r2_transition
          call set_crtc:BYTE 12,r12',13,0,1,r1',4,r4',-1

     ;     ld b,34:call waitlines
     ;     ld b,8:djnz $
     ;     ld bc,&7F45:out (c),0:out (c),c

; Set mode via firmware
; otherwise, bc' not update -> flicker at each firmware access 
mode_top  ld a,1:call mc_set_mode ; af corrupt, all others preserved

; Int firm while vbl for keyboard handling
          call call_int_firm

; Set palette, overide firmware colors
          call set_palette:BYTE &54,&40,&4F,&4B,-1

; Black so we are not pertubed by flickering (speed ink)
          INT_RET(&54,int1)

int1
          CHECK_MSB()

          call set_crtc:BYTE 4,r4'',-1

;hook_int1 call no_op

          ld hl,(offset)
;15 bytes
          ld bc,&BC0C:out (c),c
          inc b:out (c),h
          dec b:inc c:out (c),c
          inc b:out (c),l

; -- Go to last char line of bandeau to switch to mode 2
          ld b,31
          call waitlines
          call set_palette:BYTE &54,&4B,-1
; mc_set_mode take an unspecified time, so we change mode ourselves
; for proper timing.
          ld a,&8E:out (c),a
          ld b,5:call waitlines
          ld b,9:djnz $
          ld de,r2'*&0100 + r2
r2trans1 = $ + 1
          call r2_transition
          call set_crtc
r1trans = $+1
      BYTE 1,r1,-1
; Needed for c'
          ld a,2:call mc_set_mode

          INT_RET(&44,int2)

int2
; Note: Int2 can be 8 lignes late (even with JR $)
      ; Firmware handling?
hook_int2 call no_op
          call set_crtc
      BYTE 4,r4,-1      ; by default: r4=38. Changed JIT in int0
          ;INT_RET(&4E,int3)
; Black so we are not pertubed by flickering (see note above)
          INT_RET(&54,int3)
int3
hook_int3 call no_op
          INT_RET(&5C,int4)
int4
hook_int4 call no_op
          INT_RET(&58,int5)
int5
hook_int5 call no_op
          INT_RET(&5D,int0_)

int0_     jp int0       ; Just to be able to reuse INT_RET for int5

_int_ret
          pop hl
      IF raster
          ld a,(hl):inc hl
          ld bc,&7F10:out (c),c:out (c),a
          dec c:jr nz,$-1
          ld c,&54:out (c),c
      END
          ld (int_dispatch+1),hl
;enchaine
_int_ret_
          pop af
          pop bc
          pop hl
;enchaine
call_int_firm
          ex af,af
          jp c,int_firm_carry
          jp int_firm_nc

_int_ret_dbg
          ld a,r:and &3F:or &40
          ld b,&7F:out (c),0:out (c),a
          jr _int_ret_


firm2status
; If already installed: no-op.
; !!! NOT TRUE regarding crtc transition. Todo? fix that? !!!
          call clearstatus ; screen itself
          call firm2shift
          jp status_on

status2firm
; Replace firm ints (for cat, ed, ...)
          call status_off
;enchaine
shift2firm
; Shift screen back.
          call flyback
          call set_crtc:BYTE 4,r7'+r4-r7,-1
          3 ** halt
          call set_crtc:BYTE 4,r4,7,r7,-1
          ret

firm2shift
; shift screen (r7 to r7')
; Setup r3

          call flyback
; We have temp r4 (41) > r7' (27)
          call set_crtc:BYTE 3,r3,4,r7+r4-r7',-1
          3 ** halt
          call set_crtc:BYTE 4,r4,7,r7',-1
no_op     ret           ; Any RET would do!

int_firm = &B941
int_firm_nc = &B945
int_firm_carry = &B978

screen_sequencer
;---------------     
; Specific to sequencer: R1 = 48 (same as bandeau)
          ld hl,no_op
          ld a,r1'
          ld c,r6_sequencer
          jr _screen_setup

screen_instrument
;----------------     
; Specific to instrument edit: R1 = 40 (same as bandeau)
          ld hl,r2_transition
          ld a,r1
          ld c,r6
;enchaine
_screen_setup
          ld (r2trans0),hl
          ld (r2trans1),hl
          ld (r1trans),a
          ld a,6
          ld b,&BC:out (c),a
          inc b:out (c),c
          ret

status_on
;--------
; Enable status (from shifted pos screen)

; Common for everyone
          call set_crtc:BYTE 3,r3,-1

          di
          ld a,&C3:ld (int_firm),a
          ld hl,int_prelude:ld (int_firm+1),hl
          ld hl,int0:ld (int_dispatch+1),hl
          ei
          ret

status_off
;---------
; Disable status (but keep same shifted pos for main screen)
; Must preserve BC DE IX IY (was only true of orgams?)

; Restore firmware int
          di
          ld a,&F3:ld (int_firm),a
          ld hl,&3808:ld (int_firm+1),hl
          ei
          ret

; -------------------------------
clearstatus
          call connect_bk_screen
          ld hl,&4000
          ld de,&4001
          ld bc,&3FFF
          ld (hl),l
          ldir
          ret

; --------------------------------
;   Different graphic modes
; !!! Only AF BC HL saved !!!
; Save DE if you need it
; --------------------------------
mode_sequencer
          ld hl,&44
          jr _mode_com
mode_help
          ld hl,&024B
;Enchaine
_mode_com
;H= mode, L= ink 1
          ld bc,&7F01:out (c),c:out (c),l
          ld a,h
          jp mc_set_mode

; --------------------------------
;   Helpers
; --------------------------------
flyback
; Ensure start of flyback.
          call &BD19
          ld b,0:djnz $
          jp &BD19

r2_transition
; Proper change of r2 without HSYNC desynchronisation
; OSSC safe! 
; Extracted from sd:40y/lib4.o
; In: Client must ensure C0 in "start/middle" of line
    ; D = old r2
    ; E = new r2
; Out: AF, B trashed

; r0 = 63 + (old_r2 - new_r2) for compensation
          ld bc,&BC3F:out (c),0
          ld a,c:add d:sub e
          inc b:out (c),a
;Temporisation, a bit more than one line as r0 might be > 63 
;Note: might be wrong for extreme change, 
     ; but here we aim at simplicity (size-coding)
          ld b,13:djnz $
; restore r0
          ld b,&BD:out (c),c
; now we can set r2
          ld bc,&BC02:out (c),c
          inc b:out (c),e
          ret


set_crtc
; !!! Must be in int_ram2 (cf CALL_ROM)
;Stop at &ff
;out: b=&bd
          pop hl
.crtclp
;20us /iter
          ld b,&BD:outi
          ld b,&BE:outi
          ld a,(hl)
          inc a
          jr nz,.crtclp
          inc hl
jp_hl     jp hl

set_palette
;Stop at >= &80 (e.g. -1)
          pop hl
          ld bc,&7F00
.vgalp
          out (c),c:inc c
          ld a,(hl):inc hl
          or a
          jp m,jp_hl
          out (c),a
          jr .vgalp

waitlines
; Wait B lines + a bit more
; TODO: use timer's version for FX.
          push bc
          ld b,13:djnz $
          pop bc
          djnz waitlines
          ret

int_prelude
          push hl
          push bc
          push af
int_dispatch jp int0

offset WORD &3000

      SKIP psg_regs - $ ; poor's man LIMIT


