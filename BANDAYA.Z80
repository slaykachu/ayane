; Screen: Raster / Rupt under int for status bar.
        ; Transitions.

; 2025 
 ;Aug              
   ;24 Black for piano         
   ;21 Restore r4 at the end of int1 instead of int2
         ; -> needed to prevent wrong state when DI or status_off
   ;20 More robust status_on
   ; 3 Stabilize int1 (like in orgams)
         ; - Needed to mitigate DI in disp
         ; - Will also split rasters/mode
     ; firm2status: don't call clearstatus, for debugging purpose
     ; status_on: wait for vsync for int0

   ; 2 Mode 2 before piano

 ;Jun 
   ;25 Remove memmap.o dep, caller must connect C0 before clearstatus
     ; Fix r2 transition (again?)
   ;22 Save DE!
   ; 8 Special ayane: no need r9=0, bandeau 7*8 lignes
                  ; !!! Not Nop-synchro (so )

raster = 1              ; debug rasters in border
change_r2 = 1           ; 0 for debug timing
todo  = 1
needroom = 1

      IMPORT "macro.i"

bandaya_code
          jp status_on
          jp status_off
          jp firm2status

      IF $ AND &8000:ELSE
!!! Code must be out of page 0 and bank (since under int)
; -> could be mitigated: int hook saving and connecting bank.
      END

mc_set_mode = &BD1C
;kl_rom_select = &B90F
;kl_rom_deselect = &B918

ink1  = &46             ; in status bar
r1    = 40
r1'   = 48              ; bandeau and sequencer
r2    = 46              ; default
r2'   = 50              ; value for bandeau
r3    = &FC
r4    = 38
r4'   = 31
r4''  = 6               ; status (56 line total)
r6    = 25
r6_sequencer = 21
r7    = 30
r7'   = 27
r7t   = 34
r12'  = &10             ; Main r12 in /offset/

      MACRO CHECK_MSB
; For optim purpose, we assume all routines share same msb
      IF $/&0100 - int0/&0100
 !! error distinct msb
; if it happens, assemble routine at another place
      END
      ENDM

; -------------------------------

      MACRO INT_RET col,nxt
          CHECK_MSB()
; !! call reused for dispatch (cf int4)
; Must leave the call
          call _int_ret
      IF raster
      BYTE col
      END
; Hack: we cannot use 'if $-nxt' since nxt isn't known yet.
      ; So we rely on multi-definition allowed if same value.
zero  = $-nxt
      ENDM

      IF $ AND &C000:ELSE
!!! Cannot be in page 0000, since called while rom connected
      END

int0
          CHECK_MSB()
; Expect VSYNC. if not: don't change int#
          ld b,&F5:in a,(c):rra
          jp nc,_int_ret_dbg
;          jr nc,_int_ret_

; Just in time rupture. Sweet!
      IF todo
; Proper r2 transition for OSSC
      END
          push de
          ld b,7:djnz $
      IF change_r2
          ld de,r2*&0100 + r2'
      ELSE
; Same value, but still call the routine for timing purpose.
          ld de,r2'*&0100 + r2'
      END
r2trans0 = $ + 1
          call r2_transition
;r4' JIT only when band on
          call set_crtc:BYTE 12,r12',13,0,1,r1',4,r4',-1

; Set mode via firmware
; otherwise, bc' not update -> flicker at each firmware access 
mode_top  ld a,2:call mc_set_mode ; af corrupt, all others preserved

;Set first since /call_int_firm/ restablish EI
          ld hl,int1
          ld (int_dispatch+1),hl

; Int firm while vbl for keyboard handling
          call call_int_firm

; Set palette, overide firmware colors
          call set_palette:BYTE &58,&43,&4F,&4B,-1

          halt
          pop de

          INT_RET(&45,int2)
int2
hook_int2 call no_op
          ;INT_RET(&4E,int3)
; Black so we are not pertubed by flickering (see note above)
          INT_RET(&54,int3)
int3
hook_int3 call no_op
          INT_RET(&5C,int4)
int4
hook_int4 call no_op
          INT_RET(&58,int5)
int5
hook_int5 call no_op
          INT_RET(&5D,int0_)

int0_     jp int0       ; Just to be able to reuse INT_RET for int5


int1
; Called from int0
          CHECK_MSB()
          call set_crtc:BYTE 4,r4'',-1
          ld bc,&7F56:out (c),c

;hook_int1 call no_op

          ld hl,(offset)
;15 bytes
          ld bc,&BC0C:out (c),c
          inc b:out (c),h
          dec b:inc c:out (c),c
          inc b:out (c),l

; -- Go to last char line of bandeau to switch to mode 2
          ld b,16:call waitlines
          ld bc,&7F8D:out (c),c
          ld c,&54:out (c),0:out (c),c
          ld de,&0140:out (c),d:out (c),e
          ld b,15:call waitlines
          ld bc,&7F8E:out (c),c
          ld b,4:djnz $
background_line = &44
; set_palette would be too slow for both ink
; (plus, it's better to change ink 1 first)
;          call set_palette:BYTE background_line,&4B,-1
          ld bc,&7F00+background_line
          ld de,&014B
          out (c),d:out (c),e
          out (c),0:out (c),c
; mc_set_mode take an unspecified time, so we change mode ourselves
; for proper timing.
          ld b,6:call waitlines
          ld b,13:djnz $
      IF change_r2
r2trans1 = $ + 1
          ld de,r2'*&0100 + r2
      ELSE
          ld bc,&7F45:out (c),0:out (c),c
          ld b,3:djnz $
          ld bc,&7F54:out (c),c
          ld de,r2'*&0100 + r2'
      END
          call r2_transition
          call set_crtc
r1trans = $+1
      BYTE 1,r1,4,r4,-1
;r4 default value, so no prob when int0 not called

; correct stack from int_prelude
          pop af:pop bc:pop hl

; Needed for c'
          ld a,2:jp mc_set_mode ; Normal ret, back to /int0/


_int_ret
          pop hl
      IF raster
          ld a,(hl):inc hl
          ld bc,&7F10:out (c),c:out (c),a
          dec c:jr nz,$-1
          ld c,&54:out (c),c
      END
          ld (int_dispatch+1),hl
;enchaine
_int_ret_
          pop af
          pop bc
          pop hl
;enchaine
call_int_firm
          ex af,af
          jp c,int_firm_carry
          jp int_firm_nc

_int_ret_dbg
          ld a,r:and &3F:or &40
          ld b,&7F:out (c),0:out (c),a
          jr _int_ret_


firm2status
; If already installed: no-op.
; !!! NOT TRUE regarding crtc transition. Todo? fix that? !!!
     ;     call clearstatus ; screen itself
          call firm2shift
          jp status_on

status2firm
; Replace firm ints (for cat, ed, ...)
          call status_off
;enchaine
shift2firm
; Shift screen back.
          call flyback
          call set_crtc:BYTE 4,r7'+r4-r7,-1
          3 ** halt
          call set_crtc:BYTE 4,r4,7,r7,-1
          ret

firm2shift
; shift screen (r7 to r7')
; Setup r3

          call flyback
; We have temp r4 (41) > r7' (27)
          call set_crtc:BYTE 3,r3,4,r7+r4-r7',-1
          3 ** halt
          call set_crtc:BYTE 4,r4,7,r7',-1
no_op     ret           ; Any RET would do!

int_firm = &B941
int_firm_nc = &B945
int_firm_carry = &B978

screen_sequencer
;---------------     
; Specific to sequencer: R1 = 48 (same as bandeau)
          ld hl,no_op
          ld a,r1'
          ld c,r6_sequencer
          jr _screen_setup

screen_instrument
;----------------     
; Specific to instrument edit: R1 = 40 (same as bandeau)
          ld hl,r2_transition
          ld a,r1
          ld c,r6
;enchaine
_screen_setup
          ld (r2trans0),hl
          ld (r2trans1),hl
          ld (r1trans),a
          ld a,6
          ld b,&BC:out (c),a
          inc b:out (c),c
          ret

status_on
;--------
; Enable status (from shifted pos screen)

; Common for everyone
          call set_crtc:BYTE 3,r3,-1

          ld b,&F5
.wait_vsync in a,(c):rra:jr nc,.wait_vsync
          djnz $        ; skip int0 (might not be generated)
          halt          ; skip int1 (must be called from int0)

          ld a,&C3:ld (int_firm),a
          ld hl,int_prelude:ld (int_firm+1),hl
          ld hl,int2:ld (int_dispatch+1),hl
          ret

status_off
;---------
; Disable status (but keep same shifted pos for main screen)
; Must preserve BC DE IX IY (was only true of orgams?)

; Restore firmware int
          di
          ld a,&F3:ld (int_firm),a
          ld hl,&3808:ld (int_firm+1),hl
          ei
          ret

; -------------------------------
clearstatus
          ld bc,&7FC0:out (c),c
          ld hl,&4000
          ld de,&4001
          ld bc,&3FFF
          ld (hl),l
          ldir
          ret

; --------------------------------
;   Different graphic modes
; !!! Only AF BC HL saved !!!
; Save DE if you need it
; --------------------------------
mode_sequencer
          ld hl,&44
          jr _mode_com
mode_help
          ld hl,&024B
;Enchaine
_mode_com
;H= mode, L= ink 1
          ld bc,&7F01:out (c),c:out (c),l
          ld a,h
          jp mc_set_mode

; --------------------------------
;   Helpers
; --------------------------------
flyback
; Ensure start of flyback.
          call &BD19
          ld b,0:djnz $
          jp &BD19

r2_transition
; Proper change of r2 without HSYNC desynchronisation
; OSSC safe! 
; Extracted from sd:40y/lib4.o
; In: Client must ensure C0 in "start/middle" of line
    ; D = old r2
    ; E = new r2
; Out: AF, B trashed

; r0 = 63 + (old_r2 - new_r2) for compensation
          ld bc,&BC3F:out (c),0
          ld a,c:add d:sub e
          inc b:out (c),a
;Temporisation, a bit more than one line as r0 might be > 63 
;Note: might be wrong for extreme change, 
     ; but here we aim at simplicity (size-coding)
          ld b,13:djnz $
; restore r0
          ld b,&BD:out (c),c
; now we can set r2
          ld bc,&BC02:out (c),c
          inc b:out (c),e
          ret


set_crtc
; !!! Must be in int_ram2 (cf CALL_ROM)
;Stop at &ff
;out: b=&bd
          pop hl
.crtclp
;20us /iter
          ld b,&BD:outi
          ld b,&BE:outi
          ld a,(hl)
          inc a
          jr nz,.crtclp
          inc hl
jp_hl     jp hl

set_palette
;Stop at >= &80 (e.g. -1)
          pop hl
          ld bc,&7F00
.vgalp
          out (c),c:inc c
          ld a,(hl):inc hl
          or a
          jp m,jp_hl
          out (c),a
          jr .vgalp

waitlines
; Wait B lines + a bit more
      IF needroom
; TODO: use timer's version for FX.
      END
          push bc
          ld b,13:djnz $
          pop bc
          djnz waitlines
          ret

int_prelude
          push hl
          push bc
          push af
int_dispatch jp int0

offset WORD &3000


