; <<<< Phrase Editor >>>>
todo  = 0
; 2026
; -- Alpha2 --
  ; Feb
      ;01 CTRL-f0/f.: go to first/last phrase
        ; pre_view/post_view: handle when "scrolling" more than one page
                          ; (well we couldn't do that before, could we?)
; -- Alpha2 --
  ; Jan
      ;19 Do not transpose /note_c_10/
      ;17 Handle track loop
      ;13 CTRL-f0/f.
        ; CTRL-DEL, ENTER
; -- Alpha1 --
      ; 9 Display notes with transposition
      ; 8 Display phrase id and transpose
      ; 7 Display row number
      ; 5. Del: must go to next line even if empty
      ; 3. Handle CLR (stop sound)
      ; 1. Add consume_row (for CTRL-SPACE and when entering note)
; 2025
  ; Dec 31. Use ged binary.

      IMPORT "const.i"  ; kclr
dev_checks' = 1 - release

      IMPORT "memmap.i" ; BK_DISP
      IMPORT "macro.i"
          ASSERT($ AND &C000 == &4000) ; must be imported
      IMPORT "import.i"
      IMPORT "gedwidid.i"
          IMPORT_PHRASUI_DEPS() ; other deps below
; ged loaded at the end to help with visu

gedeihen_init = ged
gedeihen_set_hooks = ged+2
setup_widget = ged+4
gedeihen_disp = ged+6
gedeihen_enter = ged+9
gedeihen_process = ged+12
enter = ged+15
refresh_nofocus = ged+18
validate = ged+21
update_pos_y = ged+24

phrasui_code
          jp phrase_cold_refresh
          jp phrase_ui_process

      IMPORT "bitset.o" ; for now only used here
      IMPORT "phradisp.o"

;------------------
phrase_cold_refresh
;------------------
 ; -- restore state
          ld hl,saved_state
          ld de,state
          ld bc,state_
          ldir
 ; -- sync model
          ld a,(track_cur):call Song_select_track
 ; -- ad-hod display
          call refresh_page
 ; -- gedeihen 
          call gedeihen_init

          ld hl,ph_set_cursor
          ld ix,ph_get_cursor
          ld iy,ph_place_cursor
          ld de,ph_write_char
          ld bc,_paint_sprite
          call gedeihen_set_hooks

          ld hl,[1+wid_row#]*&0100 + 1
          call setup_phrase_ui
 ; -- focus on current row
          call gedeihen_disp
 ; -- enter        
          ld hl,[1+wid_row#]*&0100 + 1
          call _set_cursor
          ld hl,phrase_ui
          jp gedeihen_enter

phrase_ui_process
;----------------
          ld b,a
          xor a
          ld (is_modified),a
          ld (auto_skip),a
          ld (must_refresh),a
          ld a,b
          call gedeihen_process
          ret nc
          ld a,(is_modified)
          or a
          jr z,.skip_or_next
 ; repeat if repeated phrase OR flagged
          call song_get_current_phrase
          ld hl,phrase_dup:call bs_get:call z_to_val
          ld hl,must_refresh
          or (hl)
          jr z,.skip_or_next
          call refresh_page
          call refresh_row_from_time_cur ; needed for CTRL-DEL / RETURN
.skip_or_next
do_next_id = 1
do_skip_id = 2
          ld a,(auto_skip)
          or a
          scf
          ret z
          dec a
          jp z,row_dwn
 ; After row edited: skip exactly delai
          call refresh_nofocus ; needed for ?
          call get_time_row
          call get_delai_ui
          ld l,a:ld h,0:add hl,de
          jp refresh_row

; ---------------------
phrase_ui
; Ad-hoc version of w_multiline:
   ; - Y pos in not proportional to logical ml row
       ; -> We could address that in row selection, but ged might
          ; reset the cursor after that (too brittle/clunky)
   ; - CTRL-up/down 
   ; - The whole phrase disp is custom
      BYTE w_key_handler
      WORD phrase_row_ui
      WORD k_ml

phrase_row_ui
      BYTE w_struct
      WORD note_ui
      WORD instr_ui
      WORD vol_ui
      WORD 0

note_ui
; Just display note, edit is done via /extra_handler/,
; so it works from any field.
      BYTE w_refresh
      WORD note_ui'
note_ui'
      BYTE w_key_handler
      WORD note_ui''
      WORD note_handler
note_ui''
      BYTE w_text_dyn
      WORD note_as_text
note_handler
      BYTE kclr:WORD _clr_note
      BYTE kdel:WORD _del_note
      BYTE 0:WORD 0

instr_ui
      BYTE w_refresh
      WORD instr_ui'
instr_ui'
      BYTE w_key_handler
      WORD instr_ui''
      WORD instr_handler
instr_ui''
      BYTE w_optional_readwrite
      WORD instr_ui'''
      WORD has_instr
instr_ui'''
      BYTE w_deci_99_custom
      WORD _set_instr
      WORD _get_instr
instr_handler
      BYTE kdel:WORD _del_instr
      BYTE 0:WORD 0

vol_ui
      BYTE w_refresh
      WORD vol_ui'
vol_ui'
      BYTE w_key_handler
      WORD vol_ui''
      WORD vol_handler
vol_ui''
      BYTE w_optional_readwrite
      WORD vol_ui'''
      WORD has_vol
vol_ui'''
      BYTE w_hexa_digit_custom
      WORD _set_vol
      WORD _get_vol
vol_handler
      BYTE kdel:WORD _del_vol
      BYTE 0:WORD 0

k_ml
      BYTE kdwn:WORD row_dwn
      BYTE kcdwn:WORD row_ctrl_dwn
      BYTE kup:WORD row_up
      BYTE kcup:WORD row_ctrl_up
      BYTE kcf+0:WORD goto_top
      BYTE kcfdot:WORD goto_last_phrase
      BYTE krgt:WORD next_track
      BYTE kcrgt:WORD next_track
      BYTE klft:WORD prev_track
      BYTE kclft:WORD prev_track
      BYTE " ":WORD space
      BYTE kreturn:WORD insert_row
      BYTE kcdel:WORD delete_row
      BYTE "R"-&40:WORD refresh_page ; debug
;!! put at this level, so that /refresh_row/ update widget's Y at 
  ; the right level (struct)
      BYTE 0:WORD piano_keys
; -------------------------------------

note_as_text
          call is_empty
          jr z,.nonote
          call row_is_clr
          jr nz,.clr
          call row_get_note
          jr z,.nonote
          cp note_c_10
          jr z,.comnote
          ld hl,cur_transpose
          add (hl)
.comnote
          ld de,buf_note_text
          push de
          call put_note
          pop hl
          ret
.nonote
          ld hl,note_empty
          ret
.clr
          ld a,note_clr ; handled by put_note
          jr .comnote

_clr_note
          call pre_modif
          call row_clr
          jp edit_row_skip

_del_note
          call is_empty
          jp z,consume_goto_next
          call row_is_clr
          jr z,._del_note_
          call row_del_clr
          jr ._del_note_com
._del_note_
          call row_get_note
          jp z,consume_goto_next
._del_note_com
          call pre_modif
          call row_del_note
          jr edit_row_next

has_instr
          call is_empty
          ret z
          call row_get_instr_ui
          jr z_to_val
_get_instr
          call row_get_instr_ui
          scf
          ret
_set_instr
          call pre_modif
          call row_set_instr
          jr edit_row_skip
_del_instr
          call is_empty
          jp z,consume_goto_next
          call row_get_instr_ui
          scf
          jp z,consume_goto_next
          call pre_modif
          call row_del_instr
          jr edit_row_next

row_get_instr_ui
          call row_get_instr
          ret z
          cp instr_clr  ; CLR: no instr for ui perspective
          ret

has_vol
          call is_empty
          ret z
          call row_get_vol
z_to_val
          ld a,0
          ret z
          inc a
          ret
_get_vol
          call row_get_vol
          scf
          ret
_set_vol
          call pre_modif
;remove_clr done here to keep row_set_vol fast enough for salo
          call remove_clr
          call row_set_vol
          jr edit_row_skip
_del_vol
          call is_empty
          jp z,consume_goto_next
          call row_get_vol
          scf
          jp z,consume_goto_next
          call pre_modif
          call row_del_vol
          jr edit_row_next

is_empty
;Needed to avoid inserting empty rows when just navigating
          ld a,(row_exists)
          or a
          ret

remove_clr
          push af
          call row_is_clr
          call nz,row_del_clr
          pop af
          ret
;-------------------------
edit_row_next
          ld a,do_next_id
          jr _edit_row_com
edit_row_skip
          ld a,do_skip_id
;enchaine
_edit_row_com
          call consume_row
          ld a,1:ld (is_modified),a
          scf
          ret

goto_top
;-------
          ld hl,time_cur
          call set_time_zero
          jp refresh_from_time_cur

goto_last_phrase
;---------------
goto_implicit = 0
      IF goto_implicit
!! not intuitive
; Goto to last (implicit) phrase start
; E.g. if last phrase:
    ; track 1: At x, duration 16
    ; track 2: At x, duration 64
; Will go to x+64-16
      ELSE
; Goto to start of last phrase (across all tracks)
      END

          ld hl,time_cur:call set_time_zero ; to collect max
      IF goto_implicit
          ld hl,&FFFF:ld (tmp_min_duration),hl
      END
          ld b,3
.tlp
          push bc
          ld a,4:sub b:call Song_select_track
          call track_select_last_phrase
      IF goto_implicit
          call phrase_get_duration
          ld hl,(tmp_min_duration)
          or a:sbc hl,de:jr c,.okmin
          ld (tmp_min_duration),de
.okmin
          ld hl,time_tmp
          push hl
          ld bc,fetched_t0
          call add_ihl_ibc_de
          pop hl
      ELSE
          ld hl,fetched_t0
      END
;max(last,max_pos)
          ld de,time_cur
          call cp_ide_ihl
          call c,copy_time

          pop bc
          djnz .tlp

      IF goto_implicit
          ld hl,time_cur
          ld de,(tmp_min_duration)
          call sub_ihl_de_clipped
      END

          ld a,(track_cur):call Song_select_track
          jp refresh_from_time_cur

goto_last
;--------
; bottom of phrase might be further than end of track 
; (when loop in middle of phrase)
          call track_get_last_hook
          ex de,hl
          ld de,time_cur
          push de
          call copy_time
          call get_delai_ui
          ld e,a
          ld d,0
          pop hl
          call sub_ihl_de_clipped
          jp refresh_from_time_cur

row_dwn
;------     
          call get_next_row
          jp refresh_row


row_ctrl_dwn
;-----------
; Go exaclty +16 * delai_ui (don't try to align)
          call get_shift_ctrl
          ld hl,time_cur:call add_ihl_de
;enchaine
refresh_row_from_time_cur
;------------------------
; Like /refresh_row/
; In: time_cur set     

; before current phrase?
; Note: other tests (after current? in view?) done in refresh_row
          ld de,time_cur+2
          ld hl,t0+2
          call cp_ide_ihl_end
          jr nc,refresh_row_ ; no 
;enchaine
refresh_from_time_cur
;--------------------
; yes: switch phrase
          call refresh_state_cur
; time_cur will not actually change,
; save one "jr"
;enchaine 
refresh_row
;----------
; Update time_cur and cursor
; Select row (refresh itself done by ged)
; Change phrase or page if needed 
; !!! Only called from ged event (update_pos_y uses that?)
; In: HL: relative time in current phrase

          ld de,(t0)
          add hl,de
          ld (time_cur),hl
          ld a,(t0+2)
          adc 0
          ld (time_cur+2),a

refresh_row_
      IF dev_checks'
          xor a:ld (_rr_entered+1),a
;dbg       ld a,0
;          inc a
;          ld (dbg+1),a
      END
refresh_row__
; -- Get offset from top (and check if out of view port)
          call get_cur_minus_top
          jr c,.pre_view ; cur < time_at_top
          call check_past_view
          jr nc,.past_view

          inc a         ; ged cursor is 1-based
          call update_pos_y ; focus on new line

          call select_row_ui

          call enter    ; see rational in update_pos_y
          GED_HANDLED() ; when coming for e.g. edit_row_com
          ret

.pre_view
; shift up one page until time_cur is in view. Works both:
  ; - when using e.g cursor up 
  ; - when rewinding to arbitrary location
; HL = time_at_top
          call get_page_shift
          call sub_ihl_de_clipped
          call get_cur_minus_top ; only for Carry flag
          jr c,.pre_view
          jr .refresh_view


.past_view
          call get_page_shift
          call add_ihl_de
          call get_cur_minus_top
          call check_past_view
          jr nc,.past_view
.refresh_view
          call refresh_page
      IF dev_checks'
;Avoid infinite loop in case of bug
_rr_entered ld a,0
          or a:call nz,mess
          inc a
          ld (_rr_entered+1),a
      END
          jr refresh_row__

get_next_row
; Get offset next delai-aligned row or non-empty row
; whichever comes first.
; -- next row
          call get_time_row
          call phrase_seek_row_at
          ld hl,(row_t1)
          push hl
; -- next delai aligned
          call get_delai_aligned
          jr nz,$+3:add hl,bc ; already aligned -> add delai
; -- take min
          pop bc
          or a:sbc hl,bc:add hl,bc
          ret c
          ld l,c:ld h,b
          ret

get_time_row
;-----------
; Out: DE = relative time in phrase
     ;  Z if 0  (!! cannot use sub_ade_ibc_ihl as is)
; Assume offset <= &ffff
          push hl
          ld hl,(time_cur)
          ld de,(t0)
          or a:sbc hl,de
          ex de,hl
          pop hl
          ret

get_cur_minus_top
; Out: ADE = (cur-top).  Carry if cur < top
          ld bc,time_cur
          ld hl,time_at_top
          jp sub_ade_ibc_ihl

check_past_view
; In: ADE = (cur-top)
;OUT: Carry if in view
    ; NC if past view
          or d:ret nz   ; NC
          ld a,e
          ld ix,0
          jp correct_y

select_row_ui
;------------
; Non-modifying select: Don't create row if empty slot
; Change phrase if past phrase
; In: time_cur setup

      IF dev_checks'
          xor a
select_row_ui_
          ld (_sru_entered+1),a

; time_cur >= fetched_t0 (start of phrase)
          ld de,time_cur+2
          ld hl,t0+2
          call cp_ide_ihl_end
          call c,mess
      END

          ld de,time_cur+2
          ld hl,time_end+2
          call cp_ide_ihl_end
          jr nc,.past_phrase

          call get_time_row
          call phrase_seek_row_at
      IF dev_checks'
; past phrase already checked
          call nc,mess
      END
          jr nz,.no_row
          call phrase_select_row_at
      BYTE &3E          ; Hack: ld a,&af (non zero)
.no_row
          xor a
          ld (row_exists),a
          scf:sbc a     ; nz
          ret

.past_phrase
          call refresh_state_cur
          jp z,goto_last

      IF dev_checks'
; Avoid infinite loop
_sru_entered ld a,0
          or a:call nz,mess
          inc a
          jr select_row_ui_
      ELSE
          jr select_row_ui
      END

row_up
;-----
; Go to prev delai-aligned or non-empty row
; whichever is closest

; -- prev row             
          call get_time_row
          jr z,.prev_phrase
          dec de
          call phrase_seek_row_at
          ld hl,(row_t0)
          push hl
; -- prev delai aligned   
          inc de
          call get_delai_aligned
          or a:sbc hl,bc
; -- take max
          pop bc
          or a:sbc hl,bc:add hl,bc:jr nc,.ok
          ld l,c:ld h,b
.ok       jp refresh_row

.prev_phrase
          ld hl,time_cur
          call is_time_zero
          ret z
; select previous phrase
          call dec_ihl
          call refresh_state
; must point to last row or delai-aligned, whichever is last
  ; must rewind a bit, as get_delai_aligned return >= input
          call get_delai_ui
          inc hl
          ld c,a:xor a:ld b,a:sbc hl,bc:jr nc,.okclip
          ld hl,0
.okclip
          ex de,hl
          call get_delai_aligned
          push hl
          call phrase_seek_last_row
          pop hl
          or a:sbc hl,de:add hl,de:jr nc,.okmax
          ex de,hl
.okmax
          jp refresh_row

row_ctrl_up
;-----------
; Go exaclty -16 * delai_ui (don't try to align)
          call get_shift_ctrl
          ld hl,time_cur:call sub_ihl_de_clipped
          jp refresh_row_from_time_cur

insert_row
          call _insert_delete_setup
          call phrase_stable_insert_row_at
          scf
          ret

delete_row
          call _insert_delete_setup
          call phrase_stable_delete_row_at
          scf
          ret
_insert_delete_setup
          ld a,1
          ld (must_refresh),a
          ld (is_modified),a ; also needed to trigger refresh
          call clone_if_needed
          call get_time_row
          jp get_delai_ui

; --------------------------------
is_time_zero
;In: HL: time field (24 bits)
;OUT: Return Z if yes
    ; NC no matter what
    ;HL preserved
          ld a,(hl):inc hl
          or (hl):inc hl
          or (hl)
          2 ** dec hl
          ret

sub_ihl_de_clipped
          call sub_ihl_de
          ret nc
set_time_zero
;In: HL: time field (24 bits)
          xor a
          ld (hl),a:inc hl
          ld (hl),a:inc hl
          ld (hl),a
          ret

get_shift_ctrl
; de := 16 * step
          call get_delai_ui
          ld l,a:ld h,0
          4 ** add hl,hl
          ex de,hl
          ret

get_delai_aligned
; Get lowest k*step >= DE i.e (k-1)*step < DE
; In: DE = target time
;Out: HL >= DE, HL multiple of step
    ; BC = delai
    ; Z if HL == DE
    ; DE preserved
          call get_delai_ui
      IF dev_checks'
          or a:call z,mess
      END
          ld c,a
          xor a         ; for NC as well
          ld b,a
          ld l,a
          ld h,a
          sbc hl,de
          ret z         ; case DE = 0
.multiple
          add hl,bc
          jr nc,.multiple
          ld a,l:or h
          add hl,de
          ret

;-------------------------
next_track
          ld hl,track_cur
          ld a,(hl)
          cp 3:jr c,$+3:xor a
          inc a
          jr switch_track

prev_track
          ld hl,track_cur
          ld a,(hl)
          cp 2:jr nc,$+4:ld a,4
          dec a
switch_track
          ld (hl),a
          push af
          call gedeihen_disp ; remove focus
          pop af
          push af
          call Song_select_track
          call refresh_state_cur
          pop af
          dec a
track_wid = 24
          ASSERT(track_wid == 24)
          ld c,a:add a:add c:3 ** add a ; * 24
          add wid_row#+1 ;ged cursor 1-based
          push af
          call ph_get_cursor
          pop af
          ld h,a
;         GET_STATE_BYTE(widget_pos_y)
;         ld l,a
; we don't use update_pos_x, which would require ged.propagate_x = 1
; also, setup_phrase_ui rewind to 1st field, 
; which is what we want for next_track
          call setup_phrase_ui
          call select_row_ui
          call gedeihen_enter
          GED_HANDLED() ; when coming for e.g. edit_row_com
          ret

;-------------------------
piano_keys
          call is_piano_key_pressed
          ret nc
          call pre_modif
          cp note_c_10
          jr z,.oknote
          ld hl,cur_transpose
          sub (hl)
.oknote
          call row_set_note
          call Song_get_instr
          call row_set_instr
          call validate ; needed to activate w_refresh
          jp edit_row_skip

; ----------------------
_set_cursor = ph_set_cursor
_paint_sprite = &BE00
; ----------------------

refresh_page
;-----------   
          call cls_
          ld hl,phrase_met:ld a,MAX_PHRASES:call bs_init
          ld hl,phrase_dup:ld a,MAX_PHRASES:call bs_init

          ld b,3
          ld ixh,0      ; cursor x
.track_lp
          push bc
          ld a,4:sub b:call Song_select_track

          ld hl,time_at_top
          ld ixl,0      ; cursor y
.slice_lp
          call refresh_state
          jr z,.next_track
          ld e,l:ld d,h ; save cur time
; Set iyh: row#
          call get_delai_ui
          push af
          ld c,a
          xor a
          ld b,a
.div_hl_bc inc a
          sbc hl,bc
          jr nc,.div_hl_bc
          dec a
          ld iyh,a
; Set DE: time end   
          ld hl,(time_end)
          ld bc,(t0)
          or a:sbc hl,bc
          ex de,hl      ; hl = cur time, de = time end
          push hl
          call song_get_current_phrase
          pop hl
          ld b,a
          ld a,(cur_transpose):ld c,a
          pop af        ; step
          call disp_rows
          ex de,hl      ; de : cur time

; --flag repeated phrase
          push af
          call song_get_current_phrase
          ld hl,phrase_met:call bs_get:call bs_set
          ld hl,phrase_dup:call nz,bs_set
          pop af

          ld ixl,a
          ld hl,time_end
          jr nc,.slice_lp

.next_track
          ld a,ixh:add track_wid:ld ixh,a
          pop bc
          djnz .track_lp

          ld a,(track_cur):call Song_select_track

          call refresh_state_cur
          jp select_row_ui

refresh_state_cur
;----------------
          ld hl,time_cur
;Enchaine
refresh_state
;------------
; Select phrase and set associated info.
; in: hl: pnt time 
;out: if in range: NZ
        ; hl: offset time in phrase
        ; phrase selected
        ; time_end set to nxt phrase in track or end of selected one,
               ; whichever comes first
        ; (cur_transpose) updated
    ; otherwise, Z
          call track_get_state_at
          ld b,a
          push bc
          call track_select_phrase_at
          pop bc
          ret z
; only update if successful
          ld a,b:ld (cur_transpose),a
          push hl
          sbc a:ld (is_first_iter),a
; store fetched_t0 (so that t0 isn't invalidated when
                   ;track_select_phrase_at fails)
          ld hl,fetched_t0:ld de,t0:call copy_time
; -- If phrase clipped?
; -- de = min(duration, t1 - t0)
; Note: for now we drop MSB 24 bits
          ld hl,(fetched_t1)
          ld de,(fetched_t0)
          or a:sbc hl,de
          call phrase_get_duration
          or a:sbc hl,de:add hl,de
          jr nc,.okmin  ;-- phrase end (de) comes first
; -- next event (hl) comes first
          ex de,hl
.okmin
; time_end (start of next slice) = fetched_t0 + de
          ld hl,time_end
          ld bc,fetched_t0
          call add_ihl_ibc_de
          pop hl
          scf:sbc a     ; nz
          ret

pre_modif
; 1/ Clone phrase if needed
; 2/ Create row if empty
; A preserved    
          push af
          call clone_if_needed
          call is_empty
          jr nz,.ok
          ld a,1:ld (row_exists),a
          call get_time_row
          call phrase_select_row_at
.ok
          pop af
          ret

clone_if_needed
          ld a,(is_first_iter):or a
          ret nz
;-- clone phrase
          ld hl,t0
          ld de,time_tmp
          call copy_time
          call song_get_current_phrase
          ld hl,phrase_dup:call bs_get
          push af
          call phrase_clone
          ld hl,time_tmp
          call Set_phrase_at_t
          call select_row_ui
          pop af
          ret z
; If source phrase was duplicated, considere new phrase as duplicated
          call song_get_current_phrase
          ld hl,phrase_dup
          jp bs_set
; ----------------------
get_page_shift
; Out: HL= time_at_top
     ; DE= shift in ticks
          call get_delai_ui
          call ticks_per_page
          ld d,0
          ld hl,time_at_top
          ret

setup_phrase_ui
;IN: hl = cursor (1-based)
          call _set_cursor
          ld hl,phrase_ui
          jp setup_widget
; ----------------------
space
;----          
;Play row and "row_dwn"
consume_goto_next
          ld a,do_next_id
;enchaine
consume_row
; Play current row and go to next one
; IN: A: skip mode 
          ld (auto_skip),a
; compute duration
          call get_next_row
          call get_time_row
          or a:sbc hl,de
          push hl
          call Amorce_song ; for sane default
;fast forward
          ld a,1
.tracklp
          push af
          call Song_select_track
      IF todo
; reuse refresh_state_cur? 
    ; - less code
    ; - give current transpose
      END
          ld hl,time_cur
          call track_select_phrase_at
          call get_time_row
          call phrase_seek_row_at
          ld de,&FFFF   ; flag no row
          jr nc,.done
; if  Z: row starts here (set de = 0)
          ld e,c:ld d,b
          jr z,.done
; if NZ: program nxt row 
          ex de,hl
          ld hl,(row_t1) ; time nxt row
          or a:sbc hl,bc ; - offset cur
          ex de,hl
          call skip_all_ext
.done
          push hl
          push de
          ld hl,time_cur
          call track_get_state_at
          ld b,a
          pop de
          pop hl
          pop af
          push af
          call set_track_stack
          pop af
          inc a
          cp 4
          jr c,.tracklp

          pop bc        ; duration to play
          ld a,c        ; only LSB 
          call play_song_cpt
; restore
          ld a,(track_cur)
          call Song_select_track
; Necessary for ged refresh when leaving field
          call refresh_state_cur
          call select_row_ui
          scf
          ret


; ----------------------
note_empty BYTE "---",0
buf_note_text FILL 4,0

;------
; vars
;------                                        
is_first_iter BYTE 0    ; 0 = implicit repeat
row_exists BYTE 0       ; 0 = empty
is_modified BYTE 0
auto_skip BYTE 0        ; see do_next_id/do_skip_id
must_refresh BYTE 0
cur_y BYTE 0
t0        TIME(0)       ; start of current phrase
      IF goto_implicit
tmp_min_duration WORD 0
      END

_savepc
      ORG phrasui_shared_vars
; Time passed to track.o must be out of bank
state
; All vars needed to recover when switching screen
time_at_top SKIP 3      ; absolute time (determines "page")
time_cur SKIP 3         ; absolute time (determine pos in page)
track_cur BYTE          ; not shared 
state_ = $ - state

time_end SKIP 3         ; bottom of slice
time_tmp SKIP 3

          LIMIT(&4000)

      ORG _savepc

      IF 0
defaut_state
dfd   = $ - state
          ASSERT($ == dfd+time_at_top)
          TIME(0)
          ASSERT($ == dfd+time_cur)
          TIME(0)
          ASSERT($ == dfd+track_cur)
      BYTE 1
      END

saved_state
dfs   = $ - state
          ASSERT($ == dfs+time_at_top)
          TIME(0)
          ASSERT($ == dfs+time_cur)
          TIME(0)
          ASSERT($ == dfs+track_cur)
      BYTE 1

phrase_met DECLARE_BITSET(MAX_PHRASES)
phrase_dup DECLARE_BITSET(MAX_PHRASES)

phrasui_end
          LIMIT(disp_ayane)

.savepc
      ORG field_module
      IF release
      LOAD "ayagedr.bin"
      ELSE
      LOAD "ayagedd.bin"
      END
      ORG .savepc

