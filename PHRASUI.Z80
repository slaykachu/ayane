; <<<< Phrase Editor >>>>
todo  = 1
; 2025
; -- Alpha1 --
  ; Dec       
    ; 12 Handle kcup/kcdwn
    ; 10 Clean-up code: - All vars infered from time_at_top & time_cur
                          ; See /state/
                      ; - Better naming

  ; Nov
    ; 27 
    ; 19 1st version

dev_checks' = 1

      IMPORT "const.i"  ; kclr
;      IMPORT "memmap.i"
      IMPORT "macro.i"
      IMPORT "import.i"
          IMPORT_CORE() ; conv.put_note
      IF todo
;use shared imports
      END
      IMPORT "song.o"   ; Song_get_instr
      IMPORT "phrase.o"
      IMPORT "piano.o"
      IMPORT "ged.o"
      IMPORT "track.o"
      SKIP -$ AND &0F
      IMPORT "phradisp.o"


;------------------
      MACRO CALL_DISP_BK adr
; When caller out of bank
          ASSERT($ AND &C000 != &4000)
   ;       ASSERT(adr AND &C000 == &4000) (cannot check: forward ref)
          call call_disp:WORD adr
      ENDM

      MACRO JP_DISP_BK adr
; When caller out of bank
          ASSERT($ AND &C000 != &4000)
   ;       ASSERT(adr AND &C000 == &4000) (cannot check: forward ref)
          call jp_disp:WORD adr
      ENDM

;------------------

phrase_cold_refresh
;------------------
 ; -- ad-hod display
          call refresh_page

 ; -- gedeihen 
          call gedeihen_init

          ld hl,_set_cursor
          ld ix,_get_cursor
          ld iy,_place_cursor
          ld de,_write_char
          ld bc,_paint_sprite
          call gedeihen_set_hooks

          ld hl,&0101:call _set_cursor
          ld hl,phrase_ui
          call setup_widget

;refresh current row 
 ; -- restore state
          ld hl,saved_state
          ld de,state
          ld bc,state_
          ldir
          call refresh_state_cur
 ; -- sync model
          ld a,(track_cur):call Song_select_track
          call select_row_ui
 ; -- focus on current row
          call gedeihen_disp
 ; -- enter        
          ld hl,&0101:call _set_cursor
          ld hl,phrase_ui
          jp gedeihen_enter

phrase_ui_process
          call gedeihen_process
          ret nc
          ld a,(is_modified)
          or a
          scf
          ret z
 ; After row edited: skip exactly delai
          call refresh_nofocus ; needed for env
          call get_time_row
          call get_delai_ui
          ld l,a:ld h,0:add hl,de
          jp refresh_row

; ---------------------
phrase_ui
; Ad-hoc version of w_multiline:
   ; - Y pos in not proportional to logical ml row
       ; -> We could address that in row selection, but ged might
          ; reset the cursor after that (too brittle/clunky)
   ; - CTRL-up/down 
   ; - The whole phrase disp is custom
      BYTE w_key_handler
      WORD phrase_row_ui
      WORD k_ml

phrase_row_ui
      BYTE w_struct
      WORD note_ui
      WORD instr_ui
      WORD vol_ui
      WORD 0

note_ui
; Just display note, edit is done via /extra_handler/,
; so it works from any field.
      BYTE w_refresh
      WORD note_ui'
note_ui'
      BYTE w_text_dyn
      WORD note_as_text

instr_ui
      BYTE w_refresh
      WORD instr_ui'
instr_ui'
      BYTE w_optional_readwrite
      WORD instr_ui''
      WORD has_instr
instr_ui''
      BYTE w_deci_99_custom
      WORD _set_instr
      WORD _get_instr

vol_ui
      BYTE w_refresh
      WORD vol_ui'
vol_ui'
      BYTE w_key_handler
      WORD vol_ui''
      WORD vol_handler
vol_ui''
      BYTE w_optional_readwrite
      WORD vol_ui'''
      WORD has_vol
vol_ui'''
      BYTE w_hexa_digit_custom
      WORD _set_vol
      WORD _get_vol
vol_handler
      BYTE kclr:WORD _del_vol
      BYTE 0:WORD 0

k_ml
      BYTE kdwn:WORD row_dwn
      BYTE kcdwn:WORD row_ctrl_dwn
      BYTE kup:WORD row_up
      BYTE kcup:WORD row_ctrl_up
      BYTE "R"-&40:WORD refresh_page ; debug
;!! put at this level, so that /refresh_row/ update widget's Y at 
  ; the right level (struct)
      BYTE 0:WORD piano_keys
; -------------------------------------

note_as_text
          call has_note
          jr z,.nonote
          call row_get_note
          ld de,buf_note_text
          push de
          call put_note
          pop hl
          ret
.nonote
          ld hl,note_empty
          ret

has_note
          call is_empty
          ret z
          call row_get_note
          jr z_to_val

has_instr
          call is_empty
          ret z
          call row_get_instr
          jr z_to_val
_get_instr
          call row_get_instr
          scf
          ret
_set_instr
          call create_if_empty
          call row_set_instr
          jr edit_row_com

has_vol
          call is_empty
          ret z
          call row_get_vol
z_to_val
          ld a,0
          ret z
          inc a
          ret
_get_vol
          call row_get_vol
          scf
          ret
_set_vol
          call create_if_empty
          call row_set_vol
          jr edit_row_com
_del_vol
      IF todo
; todo
      END
          ret

is_empty
;Needed to avoid inserting empty rows when just navigating
          ld a,(row_exists)
          or a
          ret

;-------------------------
edit_row_com
;-----------
          call play_piano
          ld a,1:ld (is_modified),a
          scf
          ret

row_dwn
;------
; Go to next delai-aligned row or non-empty row
; whichever comes first
; -- next row
          call get_time_row
          call phrase_get_row_at
          ld hl,(row_t1)
          push hl
; -- next delai aligned
          call get_delai_aligned
          jr nz,$+3:add hl,bc ; already aligned -> add delai
; -- take min
          pop bc
          or a:sbc hl,bc:add hl,bc:jr c,.ok
          ld l,c:ld h,b
.ok
          jr refresh_row

row_ctrl_dwn
;-----------
; Go exaclty +16 * delai_ui (don't try to align)
          call get_shift_ctrl
          ld hl,time_cur:call add_ihl_de
;enchaine
refresh_row_from_time_cur
;------------------------
; Like /refresh_row/
; In: time_cur set     

; before current phrase?
; Note: other tests (after current? in view?) done in refresh_row
          ld de,time_cur+2
          ld hl,fetched_t0+2
          call cp_ide_ihl_end
          jr nc,refresh_row_ ; no 
; yes: switch phrase
          call refresh_state_cur
; time_cur will not change,
; as well pass hl = time_cur - fetched_t0
; save one "jr"
;enchaine 
refresh_row
;----------
; Update time_cur and cursor
; Select row (refresh itself done by ged)
; Change phrase or page if needed 
; !!! Only called from ged event (update_pos_y uses that?)
; In: HL: relative time in current phrase

          ld de,(fetched_t0)
          add hl,de
          ld (time_cur),hl
          ld a,(fetched_t0+2)
          adc 0
          ld (time_cur+2),a

refresh_row_
          xor a:ld (is_modified),a

; -- check if out of view port or out of phrase
          ld hl,(time_cur)
          ld de,(time_at_top)
          or a:sbc hl,de:jr c,.pre_view

      IF dev_checks'
          inc h:dec h:call nz,mess ; Not expecting > &100
      END
          ld a,l
          ld ix,0
          CALL_DISP_BK(correct_y)
          jr nc,.past_view

          inc a         ; ged cursor is 1-based
          call update_pos_y ; focus on new line

          call select_row_ui

          call enter    ; see rational in update_pos_y
          GED_HANDLED() ; when coming for e.g. edit_row_com
          ret

.pre_view
;todo
      BRK

.past_view
;todo
      BRK

get_time_row
;-----------
; Out: DE = relative time in phrase
     ;  Z if 0  
; Assume offset <= &ffff
          ld hl,(time_cur)
          ld de,(fetched_t0)
          or a:sbc hl,de
          ex de,hl
          ret

select_row_ui
;------------
; Non-modifying select: Don't create row if empty slot
; Change phrase if past phrase
; In: time_cur setup

      IF dev_checks'
          xor a
select_row_ui_
          ld (_sru_entered+1),a

; time_cur >= fetched_t0 (start of phrase)
          ld de,time_cur+2
          ld hl,fetched_t0+2
          call cp_ide_ihl_end
          call c,mess
      END

          ld de,time_cur+2
          ld hl,time_end+2
          call cp_ide_ihl_end
          jr nc,.past_phrase

          call get_time_row
          call phrase_get_row_at
      IF dev_checks'
; past phrase already checked
          call nc,mess
      END
          jr nz,.no_row
          call phrase_select_row_at
      BYTE &3E          ; Hack: ld a,&af (non zero)
.no_row
          xor a
          ld (row_exists),a
          ret

.past_phrase
; here "time_at_top" already = time at top next slice
          call refresh_state_cur
;      IF dev_checks'
;;Since start of phrase: should be 0
;          ld hl,(time_row_start)
;          ld a,l:or h:call nz,mess
;      END

      IF dev_checks'
; Avoid infinite loop
_sru_entered ld a,0
          or a:call nz,mess
          inc a
          jr select_row_ui_
      ELSE
          jr select_row_ui
      END

row_up
;-----
; Go to prev delai-aligned or non-empty row
; whichever is closest

; -- prev row             
          call get_time_row
          jr z,.prev_phrase
          dec de
          call phrase_get_row_at
          ld hl,(row_t0)
          push hl
; -- prev delai aligned   
          inc de
          call get_delai_aligned
          or a:sbc hl,bc
; -- take max
          pop bc
          or a:sbc hl,bc:add hl,bc:jr nc,.ok
          ld l,c:ld h,b
.ok       jp refresh_row

.prev_phrase
          ld hl,time_cur
          call is_time_zero
          ret z
; select previous phrase
          call dec_ihl
          call refresh_state
; must point to last row or delai-aligned, whichever is last
  ; must rewind a bit, as get_delai_aligned return >= input
          call get_delai_ui
          inc hl
          ld c,a:xor a:ld b,a:sbc hl,bc:jr nc,.okclip
          ld hl,0
.okclip
          ex de,hl
          call get_delai_aligned
          push hl
          call phrase_get_last_row
          pop hl
          or a:sbc hl,de:add hl,de:jr nc,.okmax
          ex de,hl
.okmax
          jp refresh_row

row_ctrl_up
;-----------
; Go exaclty -16 * delai_ui (don't try to align)
          call get_shift_ctrl
          ld hl,time_cur:push hl:call sub_ihl_de:pop hl
          call c,set_time_zero ; clip
          jp refresh_row_from_time_cur

; --------------------------------
is_time_zero
;In: HL: time field (24 bits)
;OUT: Return Z if yes
    ; NC no matter what
    ;HL preserved
          ld a,(hl):inc hl
          or (hl):inc hl
          or (hl)
          2 ** dec hl
          ret

set_time_zero
;In: HL: time field (24 bits)
          xor a
          ld (hl),a:inc hl
          ld (hl),a:inc hl
          ld (hl),a
          ret

get_shift_ctrl
; de := 16 * step
          call get_delai_ui
          ld l,a:ld h,0
          4 ** add hl,hl
          ex de,hl
          ret

get_delai_aligned
; Get lowest k*step >= DE i.e (k-1)*step < DE
; In: DE = target time
;Out: HL >= DE, HL multiple of step
    ; BC = delai
    ; Z if HL == DE
    ; DE preserved
          call get_delai_ui
      IF dev_checks'
          or a:call z,mess
      END
          ld c,a
          xor a         ; for NC as well
          ld b,a
          ld l,a
          ld h,a
          sbc hl,de
          ret z         ; case DE = 0
.multiple
          add hl,bc
          jr nc,.multiple
          ld a,l:or h
          add hl,de
          ret

;-------------------------
piano_keys
          call is_piano_key_pressed
          ret nc
          call create_if_empty
          call row_set_note
          call Song_get_instr
          call row_set_instr
          call validate ; needed to activate w_refresh
;          call refresh_nofocus
;          ld bc,&0404:call &BC38
;          call &BB06
;          ld bc,&0606:call &BC38
          jp edit_row_com
; ----------------------
_set_cursor JP_DISP_BK(ph_set_cursor)
_get_cursor JP_DISP_BK(ph_get_cursor)
_place_cursor JP_DISP_BK(ph_place_cursor)
_write_char JP_DISP_BK(ph_write_char)
_paint_sprite = &BE00
; ----------------------

refresh_page
;-----------   
      IF todo
; - for all tracks
; - compute time_phrase_at_bottom
; - compute delai
      END
          ld hl,time_at_top
          ld ixl,0      ; cursor y
.lp
          call refresh_state

; Set DE: time end   
          ex de,hl      ; save hl
          ld hl,(time_end)
          ld bc,(fetched_t0)
          or a:sbc hl,bc
          ex de,hl
          call get_delai_ui
          ld ixh,0      ; cursor x
          CALL_DISP_BK(disp_rows)
          ld ixl,a
          ld hl,time_end
          jr nc,.lp
          ret


refresh_state_cur
;----------------
          ld hl,time_cur
;Enchaine
refresh_state
;------------
; Select phrase and set associated info.
; in: hl: pnt time 
;out: hl: offset time in phrase
    ; phrase selected
    ; time_end set to nxt phrase in track or end of selected one,
             ; whichever comes first
          call track_select_phrase_at
          push hl
          sbc a:ld (is_first_iter),a
; -- If phrase clipped?
; -- de = min(duration, t1 - t0)
; Note: for now we drop MSB 24 bits
          ld hl,(fetched_t1)
          ld de,(fetched_t0)
          or a:sbc hl,de
          call phrase_get_duration
          or a:sbc hl,de:add hl,de
          jr nc,.okmin  ;-- phrase end (de) comes first
; -- next event (hl) comes first
          ex de,hl
.okmin
; time_end (start of next slice) = fetched_t0 + de
          ld hl,time_end
          ld bc,fetched_t0
          call add_ihl_ibc_de
          pop hl
          ret

create_if_empty
; A preserved
          ld b,a
          call is_empty
          ld a,b
          ret nz
          ld a,1:ld (row_exists),a
          call get_time_row
          call phrase_select_row_at
          ld a,b
          ret
; ----------------------

note_empty BYTE "---",0
buf_note_text SKIP 3:BYTE 0

;------
; vars
;------                                        
state
; All vars needed to recover when switching screen
time_at_top FILL 3,0    ; absolute time (determines "page")
time_cur FILL 3,0       ; absolute time (determine pos in page)
track_cur BYTE 1
state_ = $ - state

; -- work variables
;time_row_start WORD 0   ; time in phrase
time_end FILL 3,0       ; bottom of slice
is_first_iter BYTE 0    ; 0 = implicit repeat
row_exists BYTE 0       ; 0 = empty
is_modified BYTE 0
cur_y BYTE 0

      IF 0
defaut_state
dfd   = $ - state
          ASSERT($ == dfd+time_at_top)
          TIME(0)
          ASSERT($ == dfd+time_cur)
          TIME(0)
          ASSERT($ == dfd+track_cur)
      BYTE 1
      END

saved_state
dfs   = $ - state
          ASSERT($ == dfs+time_at_top)
          TIME(0)
          ASSERT($ == dfs+time_cur)
          TIME(0)
          ASSERT($ == dfs+track_cur)
      BYTE 1

