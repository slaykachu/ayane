; <<<< Phrase Editor >>>>
todo  = 1
; 2025
; -- Alpha1 --
  ; Dec 
    ; 16 IMPORT_PHRADISP: in BK_DISP
       ; Fix display of non-aligned row at end of page.
         ; (switch pages by 32 rows instead of 33)
    ; 15 Handle all tracks
       ; Handle deletion note/vol/instr
       ; Clone when modifying repetition (pre_modif)
    ; 13 Refresh all instances of repeated phrase       
    ; 12 Handle page change
       ; Handle kcup/kcdwn
    ; 10 Clean-up code: - All vars infered from time_at_top & time_cur
                          ; See /state/
                      ; - Better naming

  ; Nov
    ; 27 
    ; 19 1st version

dev_checks' = 1

      IMPORT "const.i"  ; kclr
      IMPORT "memmap.i" ; BK_DISP
      IMPORT "macro.i"
      IMPORT "import.i"
ref_pc
          IMPORT_CORE() ; conv.put_note
          IMPORT_GED()
      IF todo
;use shared imports
      END
      IMPORT "bitset.o"
      IMPORT "song.o"   ; Song_get_instr
      IMPORT "phrase.o"
      IMPORT "piano.o"
      IMPORT "ged.o"
      IMPORT "track.o"
          ASSERT($ == ref_pc) ; deps must have been imported by client

      IMPORT "phradisp.o"

;------------------
phrase_cold_refresh
;------------------
 ; -- restore state
          ld hl,saved_state
          ld de,state
          ld bc,state_
          ldir
 ; -- sync model
          ld a,(track_cur):call Song_select_track
 ; -- ad-hod display
          call refresh_page
 ; -- gedeihen 
          ld hl,&0101
          call setup_phrase_ui
 ; -- focus on current row
          call gedeihen_disp
 ; -- enter        
          ld hl,&0101:call _set_cursor
          ld hl,phrase_ui
          jp gedeihen_enter

phrase_ui_process
          ld b,a
          xor a:ld (is_modified),a
          ld a,b
          call gedeihen_process
          ret nc
          ld a,(is_modified)
          or a
          scf
          ret z
 ; Must we refresh repeated phrase?
          call song_get_current_phrase
          ld hl,phrase_dup:call bs_get
          call nz,refresh_page
 ; After row edited: skip exactly delai
          call refresh_nofocus ; needed for env
          call get_time_row
          call get_delai_ui
          ld l,a:ld h,0:add hl,de
          jp refresh_row

; ---------------------
phrase_ui
; Ad-hoc version of w_multiline:
   ; - Y pos in not proportional to logical ml row
       ; -> We could address that in row selection, but ged might
          ; reset the cursor after that (too brittle/clunky)
   ; - CTRL-up/down 
   ; - The whole phrase disp is custom
      BYTE w_key_handler
      WORD phrase_row_ui
      WORD k_ml

phrase_row_ui
      BYTE w_struct
      WORD note_ui
      WORD instr_ui
      WORD vol_ui
      WORD 0

note_ui
; Just display note, edit is done via /extra_handler/,
; so it works from any field.
      BYTE w_refresh
      WORD note_ui'
note_ui'
      BYTE w_key_handler
      WORD note_ui''
      WORD note_handler
note_ui''
      BYTE w_text_dyn
      WORD note_as_text
note_handler
      BYTE kdel:WORD _del_note
      BYTE 0:WORD 0

instr_ui
      BYTE w_refresh
      WORD instr_ui'
instr_ui'
      BYTE w_key_handler
      WORD instr_ui''
      WORD instr_handler
instr_ui''
      BYTE w_optional_readwrite
      WORD instr_ui'''
      WORD has_instr
instr_ui'''
      BYTE w_deci_99_custom
      WORD _set_instr
      WORD _get_instr
instr_handler
      BYTE kdel:WORD _del_instr
      BYTE 0:WORD 0

vol_ui
      BYTE w_refresh
      WORD vol_ui'
vol_ui'
      BYTE w_key_handler
      WORD vol_ui''
      WORD vol_handler
vol_ui''
      BYTE w_optional_readwrite
      WORD vol_ui'''
      WORD has_vol
vol_ui'''
      BYTE w_hexa_digit_custom
      WORD _set_vol
      WORD _get_vol
vol_handler
      BYTE kdel:WORD _del_vol
      BYTE 0:WORD 0

k_ml
      BYTE kdwn:WORD row_dwn
      BYTE kcdwn:WORD row_ctrl_dwn
      BYTE kup:WORD row_up
      BYTE kcup:WORD row_ctrl_up
      BYTE krgt:WORD next_track
      BYTE kcrgt:WORD next_track
      BYTE klft:WORD prev_track
      BYTE kclft:WORD prev_track
      BYTE "R"-&40:WORD refresh_page ; debug
;!! put at this level, so that /refresh_row/ update widget's Y at 
  ; the right level (struct)
      BYTE 0:WORD piano_keys
; -------------------------------------

note_as_text
          call has_note
          jr z,.nonote
          call row_get_note
          ld de,buf_note_text
          push de
          call put_note
          pop hl
          ret
.nonote
          ld hl,note_empty
          ret

has_note
          call is_empty
          ret z
          call row_get_note
          jr z_to_val
_del_note
          call row_get_note
          scf
          ret z         ; no modif if no instr
          call pre_modif
          call row_del_note
          jr edit_row_com

has_instr
          call is_empty
          ret z
          call row_get_instr
          jr z_to_val
_get_instr
          call row_get_instr
          scf
          ret
_set_instr
          call pre_modif
          call row_set_instr
          jr edit_row_com
_del_instr
          call row_get_instr
          scf
          ret z         ; no modif if no instr
          call pre_modif
          call row_del_instr
          jr edit_row_com

has_vol
          call is_empty
          ret z
          call row_get_vol
z_to_val
          ld a,0
          ret z
          inc a
          ret
_get_vol
          call row_get_vol
          scf
          ret
_set_vol
          call pre_modif
          call row_set_vol
          jr edit_row_com
_del_vol
          call row_get_vol
          scf
          ret z         ; no modif if no instr
          call pre_modif
          call row_del_vol
          jr edit_row_com

is_empty
;Needed to avoid inserting empty rows when just navigating
          ld a,(row_exists)
          or a
          ret

;-------------------------
edit_row_com
;-----------
          call play_piano
          ld a,1:ld (is_modified),a
          scf
          ret

row_dwn
;------
; Go to next delai-aligned row or non-empty row
; whichever comes first
; -- next row
          call get_time_row
          call phrase_seek_row_at
          ld hl,(row_t1)
          push hl
; -- next delai aligned
          call get_delai_aligned
          jr nz,$+3:add hl,bc ; already aligned -> add delai
; -- take min
          pop bc
          or a:sbc hl,bc:add hl,bc:jr c,.ok
          ld l,c:ld h,b
.ok
          jr refresh_row

row_ctrl_dwn
;-----------
; Go exaclty +16 * delai_ui (don't try to align)
          call get_shift_ctrl
          ld hl,time_cur:call add_ihl_de
;enchaine
refresh_row_from_time_cur
;------------------------
; Like /refresh_row/
; In: time_cur set     

; before current phrase?
; Note: other tests (after current? in view?) done in refresh_row
          ld de,time_cur+2
          ld hl,fetched_t0+2
          call cp_ide_ihl_end
          jr nc,refresh_row_ ; no 
; yes: switch phrase
          call refresh_state_cur
; time_cur will not change,
; as well pass hl = time_cur - fetched_t0
; save one "jr"
;enchaine 
refresh_row
;----------
; Update time_cur and cursor
; Select row (refresh itself done by ged)
; Change phrase or page if needed 
; !!! Only called from ged event (update_pos_y uses that?)
; In: HL: relative time in current phrase

          ld de,(fetched_t0)
          add hl,de
          ld (time_cur),hl
          ld a,(fetched_t0+2)
          adc 0
          ld (time_cur+2),a

refresh_row_
      IF dev_checks'
          xor a:ld (_rr_entered+1),a
      END
refresh_row__
; -- Get offset from top (and check if out of view port)
          ld bc,time_cur
          ld hl,time_at_top
          call sub_ade_ibc_ihl
          jr c,.pre_view

          or d:jr nz,.past_view
          ld a,e
          ld ix,0
          call correct_y
          jr nc,.past_view

          inc a         ; ged cursor is 1-based
          call update_pos_y ; focus on new line

          call select_row_ui

          call enter    ; see rational in update_pos_y
          GED_HANDLED() ; when coming for e.g. edit_row_com
          ret

.pre_view
          call get_page_shift
          call sub_ihl_de_clipped
          jr .refresh_view


.past_view
          call get_page_shift
          call add_ihl_de
.refresh_view
          call refresh_page
      IF dev_checks'
;Avoid infinite loop in case of bug
_rr_entered ld a,0
          or a:call nz,mess
          inc a
          ld (_rr_entered+1),a
      END
          jr refresh_row__

get_time_row
;-----------
; Out: DE = relative time in phrase
     ;  Z if 0  
; Assume offset <= &ffff
          ld hl,(time_cur)
          ld de,(fetched_t0)
          or a:sbc hl,de
          ex de,hl
          ret

select_row_ui
;------------
; Non-modifying select: Don't create row if empty slot
; Change phrase if past phrase
; In: time_cur setup

      IF dev_checks'
          xor a
select_row_ui_
          ld (_sru_entered+1),a

; time_cur >= fetched_t0 (start of phrase)
          ld de,time_cur+2
          ld hl,fetched_t0+2
          call cp_ide_ihl_end
          call c,mess
      END

          ld de,time_cur+2
          ld hl,time_end+2
          call cp_ide_ihl_end
          jr nc,.past_phrase

          call get_time_row
          call phrase_seek_row_at
      IF dev_checks'
; past phrase already checked
          call nc,mess
      END
          jr nz,.no_row
          call phrase_select_row_at
      BYTE &3E          ; Hack: ld a,&af (non zero)
.no_row
          xor a
          ld (row_exists),a
          ret

.past_phrase
          call refresh_state_cur

      IF dev_checks'
; Avoid infinite loop
_sru_entered ld a,0
          or a:call nz,mess
          inc a
          jr select_row_ui_
      ELSE
          jr select_row_ui
      END

row_up
;-----
; Go to prev delai-aligned or non-empty row
; whichever is closest

; -- prev row             
          call get_time_row
          jr z,.prev_phrase
          dec de
          call phrase_seek_row_at
          ld hl,(row_t0)
          push hl
; -- prev delai aligned   
          inc de
          call get_delai_aligned
          or a:sbc hl,bc
; -- take max
          pop bc
          or a:sbc hl,bc:add hl,bc:jr nc,.ok
          ld l,c:ld h,b
.ok       jp refresh_row

.prev_phrase
          ld hl,time_cur
          call is_time_zero
          ret z
; select previous phrase
          call dec_ihl
          call refresh_state
; must point to last row or delai-aligned, whichever is last
  ; must rewind a bit, as get_delai_aligned return >= input
          call get_delai_ui
          inc hl
          ld c,a:xor a:ld b,a:sbc hl,bc:jr nc,.okclip
          ld hl,0
.okclip
          ex de,hl
          call get_delai_aligned
          push hl
          call phrase_seek_last_row
          pop hl
          or a:sbc hl,de:add hl,de:jr nc,.okmax
          ex de,hl
.okmax
          jp refresh_row

row_ctrl_up
;-----------
; Go exaclty -16 * delai_ui (don't try to align)
          call get_shift_ctrl
          ld hl,time_cur:call sub_ihl_de_clipped
          jp refresh_row_from_time_cur

; --------------------------------
is_time_zero
;In: HL: time field (24 bits)
;OUT: Return Z if yes
    ; NC no matter what
    ;HL preserved
          ld a,(hl):inc hl
          or (hl):inc hl
          or (hl)
          2 ** dec hl
          ret

sub_ihl_de_clipped
          call sub_ihl_de
          ret nc
set_time_zero
;In: HL: time field (24 bits)
          xor a
          ld (hl),a:inc hl
          ld (hl),a:inc hl
          ld (hl),a
          ret

get_shift_ctrl
; de := 16 * step
          call get_delai_ui
          ld l,a:ld h,0
          4 ** add hl,hl
          ex de,hl
          ret

get_delai_aligned
; Get lowest k*step >= DE i.e (k-1)*step < DE
; In: DE = target time
;Out: HL >= DE, HL multiple of step
    ; BC = delai
    ; Z if HL == DE
    ; DE preserved
          call get_delai_ui
      IF dev_checks'
          or a:call z,mess
      END
          ld c,a
          xor a         ; for NC as well
          ld b,a
          ld l,a
          ld h,a
          sbc hl,de
          ret z         ; case DE = 0
.multiple
          add hl,bc
          jr nc,.multiple
          ld a,l:or h
          add hl,de
          ret

;-------------------------
next_track
          ld hl,track_cur
          ld a,(hl)
          cp 3:jr c,$+3:xor a
          inc a
          jr switch_track

prev_track
          ld hl,track_cur
          ld a,(hl)
          cp 2:jr nc,$+4:ld a,4
          dec a
switch_track
          ld (hl),a
          push af
          call gedeihen_disp ; remove focus
          pop af
          push af
          call Song_select_track
          call refresh_state_cur
          pop af
          dec a
track_wid = 20
          ASSERT(track_wid == 20)
          ld c,a:2 ** add a:add c:2 ** add a ; * 20
          inc a         ;ged cursor 1-based
          ld h,a
          GET_STATE_BYTE(widget_pos_y)
          ld l,a
; we don't use update_pos_x, which would require ged.propagate_x = 1
; also, setup_phrase_ui rewind to 1st field, 
; which is what we want for next_track
          call setup_phrase_ui
          call select_row_ui
          call gedeihen_enter
          GED_HANDLED() ; when coming for e.g. edit_row_com
          ret

;-------------------------
piano_keys
          call is_piano_key_pressed
          ret nc
          call pre_modif
          call row_set_note
          call Song_get_instr
          call row_set_instr
          call validate ; needed to activate w_refresh
;          call refresh_nofocus
;          ld bc,&0404:call &BC38
;          call &BB06
;          ld bc,&0606:call &BC38
          jp edit_row_com

; ----------------------
_set_cursor = ph_set_cursor
_paint_sprite = &BE00
; ----------------------

refresh_page
;-----------   
          call cls_
          ld hl,phrase_met:ld a,MAX_PHRASES:call bs_init
          ld hl,phrase_dup:ld a,MAX_PHRASES:call bs_init

          ld b,3
          ld ixh,0      ; cursor x
.track_lp
          push bc
          ld a,4:sub b:call Song_select_track

          ld hl,time_at_top
          ld ixl,0      ; cursor y
.slice_lp
          call refresh_state

; Set DE: time end   
          ex de,hl      ; save hl
          ld hl,(time_end)
          ld bc,(fetched_t0)
          or a:sbc hl,bc
          ex de,hl
          call get_delai_ui
          call disp_rows
          ex de,hl      ; de : cur time

; --flag repeated phrase
          push af
          call song_get_current_phrase
          ld hl,phrase_met:call bs_get
          jr z,.nodup
          push hl
          ld hl,phrase_dup:call bs_set
          pop hl
.nodup
          call bs_set
          pop af

          ld ixl,a
          ld hl,time_end
          jr nc,.slice_lp

          ld a,ixh:add track_wid:ld ixh,a
          pop bc
          djnz .track_lp

          ld a,(track_cur):call Song_select_track

          call refresh_state_cur
          jp select_row_ui


refresh_state_cur
;----------------
          ld hl,time_cur
;Enchaine
refresh_state
;------------
; Select phrase and set associated info.
; in: hl: pnt time 
;out: hl: offset time in phrase
    ; phrase selected
    ; time_end set to nxt phrase in track or end of selected one,
             ; whichever comes first
          call track_select_phrase_at
          push hl
          sbc a:ld (is_first_iter),a
; -- If phrase clipped?
; -- de = min(duration, t1 - t0)
; Note: for now we drop MSB 24 bits
          ld hl,(fetched_t1)
          ld de,(fetched_t0)
          or a:sbc hl,de
          call phrase_get_duration
          or a:sbc hl,de:add hl,de
          jr nc,.okmin  ;-- phrase end (de) comes first
; -- next event (hl) comes first
          ex de,hl
.okmin
; time_end (start of next slice) = fetched_t0 + de
          ld hl,time_end
          ld bc,fetched_t0
          call add_ihl_ibc_de
          pop hl
          ret

pre_modif
; 1/ Clone phrase if needed
; 2/ Create row if empty
; A preserved
          push af
          ld a,(is_first_iter):or a:jr nz,.okclone
;-- clone phrase
          ld hl,fetched_t0
          ld de,time_tmp
          call copy_time
          call song_get_current_phrase
          ld hl,phrase_dup:call bs_get
          push af
          call phrase_clone
          ld hl,time_tmp
          call Set_phrase_at_t
          call select_row_ui
          pop af
          jr z,.okclone
; If source phrase was duplicated, considere new phrase as duplicated
          call song_get_current_phrase
          ld hl,phrase_dup:call bs_set
.okclone
          pop bc        ; was A
          call is_empty
          ld a,b
          ret nz
          ld a,1:ld (row_exists),a
          call get_time_row
          call phrase_select_row_at
          ld a,b
          ret
; ----------------------
get_page_shift
; Out: HL= time_at_top
     ; DE= shift in ticks
          call get_delai_ui
          call ticks_per_page
          ld d,0
          ld hl,time_at_top
          ret

setup_phrase_ui
;IN: hl = cursor (1-based)
          call _set_cursor

          call gedeihen_init ;needed before (re)calling setup_widget

          ld hl,ph_set_cursor
          ld ix,ph_get_cursor
          ld iy,ph_place_cursor
          ld de,ph_write_char
          ld bc,_paint_sprite
          call gedeihen_set_hooks

          ld hl,phrase_ui
          jp setup_widget
; ----------------------

note_empty BYTE "---",0
buf_note_text SKIP 3:BYTE 0

;------
; vars
;------                                        
is_first_iter BYTE 0    ; 0 = implicit repeat
row_exists BYTE 0       ; 0 = empty
is_modified BYTE 0
cur_y BYTE 0

_savepc

      ORG phrasui_shared_vars
; Time passed to track.o must be out of bank
state
; All vars needed to recover when switching screen
time_at_top SKIP 3      ; absolute time (determines "page")
time_cur SKIP 3         ; absolute time (determine pos in page)
track_cur BYTE          ; not shared 
state_ = $ - state

time_end SKIP 3         ; bottom of slice
time_tmp SKIP 3

          LIMIT(&4000)

      ORG _savepc

      IF 0
defaut_state
dfd   = $ - state
          ASSERT($ == dfd+time_at_top)
          TIME(0)
          ASSERT($ == dfd+time_cur)
          TIME(0)
          ASSERT($ == dfd+track_cur)
      BYTE 1
      END

saved_state
dfs   = $ - state
          ASSERT($ == dfs+time_at_top)
          TIME(0)
          ASSERT($ == dfs+time_cur)
          TIME(0)
          ASSERT($ == dfs+track_cur)
      BYTE 1

phrase_met DECLARE_BITSET(MAX_PHRASES)
phrase_dup DECLARE_BITSET(MAX_PHRASES)
phrasui_end
