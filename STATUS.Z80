; Display routine in status bar (AYANE VERSION)

dev_checks = 1
need_room = 1

; 2025 
 ; -- v0au --
 ; Nov
    ; 15 Reactivate field_refresh and copy_nt
       ; Deactivate ClearQuestion
 ; -- v0aq --
 ; Sep
    ; 28 Use disp.o Only ClearQuestion reactivated
 ; -- v0a? --
 ; jun 9 Use disp-jp.o adapt for new bandeau (page 4000, r9=7)

      IF $ AND &C000 != &C000
  !! must be in c1 (done by host)
 ; -> allow to call status_* routine directly
      END

.test_pc
      IMPORT "disp.o"   ; !!! disp.bin loaded by client

      IF $ != .test_pc
  !! disp must have been imported by host
      END

fail  = &BE00

; ------------------------------------------------
      IF 0
disp_infos_com
; IN:  DE: cursor
    ;  HL: nt str
;OUT:  D (X) updated
    ;  HL: post str
    ; hl trashed

          push af
          push iy       ; Needed?
          ld c,l
          ld b,h
          CALL_BRIC(status_str_at)
          ld a,c:scf:sbc l ;longueur chaine
          ld l,c
          ld h,b
          add d:ld d,a
          pop iy
          pop af
          ret

clear_buf_info
; Clear buffer
; OUT: hl buffer
          ld hl,BUF_INFO
.lp       ld (hl),0:inc l:jr nz,.lp
      IF BUF_INFO AND &FF
          ld l,BUF_INFO AND &FF
      END
          ret

txt_free BYTE "Free: &",0
txt_free' BYTE "00 ("

; ----------------------

ClearQuestion
; Efface ligne question.             
; Out: de trashed, all other registers saved
      IF need_room
; Factorize with disp.clear_line (or whatever it is called)
      END

          push af       ; Save answer and flags
          push bc       ; needed?
          push de       ; needed?
          ld de,0 + status_line_question
          CALL_BRIC(status_set_cursor)

          ld b,LEN_QUESTION
.cqlp
          ld a," "
          push bc
          call status_char
          pop bc
          djnz .cqlp
          pop de
          pop bc
          pop af
          ret


disp_modified
; Affiche le status du source modifi{ ou non
; In:  Z Non modifie.
    ; NZ Modifie.

          push de       ; Preserve line# when coming from quitLine context
          ld a,ASTERIX  ; C'est plus drole comme \a
          jr nz,$+4:ld a," " ; Clear if not modified
          ld de,X_MODIFIED*&0100 + status_line_main
          CALL_BRIC(status_char_at)
          pop de
          ret

      END

field_refresh
; Affichage complet de tout le champ dans bar status, avec cursor.
; A utiliser conjointement avec field editor.

; In:
; HL : adr du champ (NT string)
; DE : x, y in status bar (start champ)
; B  : longueur max du champ           
; C  : cursor pos dans champ (0: first)
; A  : Si Bit 7 est mÿs, inverse video  (or &80 sur chaque char)
; Out: A trashed, all other saved
          push hl
          call status_set_cursor

          push bc
          and &80:ld c,a
print_lp
          ld a,(hl):or a
          jr z,.stay_0  ; Stay at same position, and no inverse!
          inc hl
          or c          ; Inverse video?
.stay_0
          call status_char
          djnz print_lp

; Don't display cursor when inverse video.
; (expect if empty field)
          ld a,c
          pop bc
          inc c:dec c:jr z,.cursor ; empty field: cursor
          add a:jr c,.nocursor
.cursor
          push de
;display cursor at Offset + C
          ld a,d:add c:ld d,a
          call status_inv_cursor_at
          pop de
.nocursor
          pop hl
          ret

      IF 0

;----------------------

; Conversion d'un entier 16bit en string justifie a droite.
; Entr{e : HL=Nombre @ convertir
;          DE=Adresse d'un buffer pour stocker la chaine
; Sortie : Buffer remplit
DEC2STR
          ld a,h:or l
          jr nz,ContDec2Str

; NB: Justification a droite manquante pour 0.
    ; Nevermind since line# always > 0.
          ld a,"0":ld (de),a
          inc de:xor a:ld (de),a
          ret

ContDec2Str
          push de
          ld bc,-10000
          call DEC2STR1
          ld bc,-1000
          call DEC2STR1
          ld bc,-100
          call DEC2STR1
          ld c,-10
          call DEC2STR1
          ld c,b
          call DEC2STR1
          pop hl
          ld a,"0"
BCL       cp (hl)
          ret nz
          ld (hl)," "
          inc hl
          jr BCL
DEC2STR1  ld a,"0"-1
DEC2STR2  inc a
          add hl,bc
          jr c,DEC2STR2
          sbc hl,bc
          ld (de),a
          inc de
          xor a
          ld (de),a     ; Put 0 to mark end of string
          ret

; GETPATH was cubemdos's RSX.
;nget_path BYTE "GETPATH"+&80,0 ; &80 for rsx search, 0 for copy_nt
; PATH is unidos's version.
nget_path BYTE "PATH"+&80,0 ; &80 for rsx search, 0 for copy_nt
      END

; ----- Constantes -----

;status_line_question = 6

;ASTERIX = "*"

; Positions dans status
; line 0
;X_TAB# = 2              ; "f1:"
;X_MODIFIED = X_TAB#+3
;X_FILENAME = X_MODIFIED+1
;X_FREE = 73
; line 2          
;X_DRIVE = 2
;X_CWD = X_DRIVE + 3

WIDTH = 96              ; largeur totale bandeau

LEN_QUESTION = WIDTH-2  ; Max len question (for clean)
; Actually max would be 2 + len("import:") + LEN_SRC  
; But for now we erase whole line (which start at 2)


