; <<<< Tests salo and generate libs >>>>
; 2025      
; -- Alpha1 --
   ; Dec 25. Default instrument is now 1 (see by init.full_init)
; -- v0.0au --
   ; Nov: test_assets: test New_subsong

; -- v0.0aq -- 
   ; Oct 
        ;28 Test saving syncbuzzer
            ; -> NOPE, already here (dummy /raw_row3/)
                      ; (hum, it sets fx_null apparently) 
; -- v0.0ao -- 
        ;17 Reorder so it fits in RAM
   ; Aug  9 Exercise file > &100 
; -- v0.0ac --
   ; Mar  5 First version

      IMPORT "const.i"  ; just for track_param#
      IMPORT "memmap.i"

      ORG 0:BRK

      ORG code_start
      ENT tests

      IMPORT "import.i"
      IMPORT "macro.i"

          IMPORT_SALO_DEPS()
hu
      ORG shortcut
      IMPORT "shortcut.o" ; init.o dep
      ORG init_module
      IMPORT "init.o"   ; for test and ayalib2.bin
      IMPORT "instr.o"
      IF use_widget
      IMPORT ":lib/rgb256.o" ; for rgb256_code
      END

ho    SKIP ramlimit - $ ; poor man's limit

      ORG io
      IMPORT "io.o"     ; for save

      IMPORT "salo.o"   ; set ORG salo

      SKIP free_ram_for_nrt - $
      IMPORT "testlib.o"

;-----------------------------
      MACRO NO_TEXT
;Null terminated: only the 0
      BYTE 0
      ENDM
;-----------------------------

tests
          call test_save_empty_module
          call test_save_empty_phrase
          call test_load_empty_module ; also test save-load-save
          call test_assets
          call test_big
          ret

nrt_init
          call full_init
          ld a,1:ld bc,&1A1A:call &BC32
          ld a,2:call &BD1C
          ret

test_save_empty_module
;---- Check saving empty module
          call nrt_init

          ld de,destnrt
          call nrt_save

          ld hl,almost_empty
          ld de,destnrt
          ld bc,almost_empty_
          call connect_bk_io
          call compare_sized
          ret

test_load_empty_module
;---- Check load empty module
          call nrt_init

          ld hl,almost_empty
          call nrt_load
; First success is that 'load' didn't assert!
; Now save+load+save should give back same result
          call check_save_load_save
          ret

test_save_empty_phrase
;---- Check saving module with just one empty phrase
          call nrt_init

          xor a:call song_select_new_phrase

          ld de,destnrt
          call nrt_save

          ld hl,empty_phrase
          ld de,destnrt
          ld bc,empty_phrase_
          call connect_bk_io
          call compare_sized
          ret


test_assets
;---- Progressively build a module,
; and checks save+load+save    
          ld a,0:ld (hack_ret),a

          call nrt_init

; Sanity: check no track in subsong
          call Song_get_first_track:call nz,fail

; - Empty instr 
          ld a,1        ; id (0 is reserved)
          ld b,type_instr_default
          ld c,0        ; nb params
          call New_instr
          call check_save_load_save
; -- with one row
          ld b,1
          ld hl,raw_row1
; Note: invalid fx routine, sets fx_null apparently.
      ; Sanatized by chung or what?
          call instr_ayane_append_rows
          call check_save_load_save
; -- with two rows
          ld b,1
          ld hl,raw_row2
          call instr_ayane_append_rows
          call check_save_load_save
; - New instr 2 
          ld a,3        ; skip id 2
          ld b,type_instr_default
          ld c,0        ; nb params
          call New_instr
          call check_save_load_save
; -- with one row
          ld b,1
          ld hl,raw_row3
          call instr_ayane_append_rows
          call check_save_load_save
; -- with 1 sync buzzer
      IF 0
          ld b,1
          ld hl,raw_row_buzz
          call instr_ayane_append_rows
          call check_save_load_save
      END
; - Empty phrase  
          xor a
          call song_select_new_phrase
          call check_save_load_save
; -- With params      
          ld c,1
          ld hl,paramX
          call phrase_set_params
          call check_save_load_save
; ---- Sanity check
          call phrase_get_rows#:or a:call nz,fail
; -- With one empty row (duration 0)
          xor a:call phrase_select_new_row
          call phrase_get_rows#:cp 1:call nz,fail
          call check_save_load_save
          call phrase_get_rows#:cp 1:call nz,fail
; --- With non-zero duration 
          ld a,42
          call row_add_duration
          call phrase_get_rows#:cp 1:call nz,fail
          call check_save_load_save
          call phrase_get_rows#:cp 1:call nz,fail
; --- With fx
; --- With note
          ld a,43
          call row_set_note
          call phrase_get_rows#:cp 1:call nz,fail
          call check_save_load_save
          call phrase_get_rows#:cp 1:call nz,fail
; --- With vol            
          ld a,&0E
          call row_set_vol
          call check_save_load_save
; --- With instr
          ld a,1
          call row_set_instr
          call check_save_load_save
; -- With another row
          call phrase_select_new_row
          call check_save_load_save
; - Another (empty) phrase
phrase4 = 4
          ld a,phrase4  ; skip id 1,2,3
          call song_select_new_phrase
          call check_save_load_save
; - Empty track                              
          ld a,1        ; id
          ld bc,&0100   ; output and mix mode
          call Song_select_new_track
          ld hl,_check_1_track:ld (hook_check_jp),hl
          call check_save_load_save
; -- With event
          ld a,5
          ld hl,time1
          call Set_transpose_at_t
          call check_save_load_save
; -- With phrase at same time
          xor a
          ld hl,time1
          call Set_phrase_at_t
          call check_save_load_save
; -- With phrase at different time
          ld a,phrase4
          ld hl,time2
          call Set_phrase_at_t
          call check_save_load_save
; - Another track
          ld a,2
          ld bc,&0200   ; output and mix mode
          call Song_select_new_track
          ld hl,_check_2_tracks:ld (hook_check_jp),hl
          call check_save_load_save
; - Empty subsong
          xor a
          call Subsong_add
; Sanity: check no track in subsong
          call Song_get_first_track:call nz,fail
          call check_save_load_save
; -- With one track
          ld hl,.trackinfo
          ld c,2
          call Subsong_add_track
          ld hl,_check_1_track_in_subsong:ld (hook_check_jp),hl
          call check_save_load_save
; -- With two tracks
          ld hl,_nocheck:ld (hook_check_jp),hl
          ld hl,.trackinfo'
          ld c,2
          call Subsong_add_track
          call check_save_load_save
; -- Big instruments to have buffer > &100
          ld b,30
          ld hl,raw_row3
          call instr_ayane_append_rows
          call check_save_load_save
; -- New_susbong
          call Reset_tracks_and_subsongs ; remove previous tracks
          xor a:call New_subsong
          call .check_tracks
          call check_save_load_save
          call .check_tracks
; -- With loop
          ld a,0:ld (hack_ret),a
          call Song_get_first_track
          call Song_select_track
          ld hl,time_zero:call Set_track_loop
          ret

.trackinfo BYTE 1,1     ; id, channel
.trackinfo' BYTE 2,2

.check_tracks
          call Song_get_first_track:call z,fail
          cp 1:call nz,fail
          call Song_get_next_track:call z,fail
          cp 2:call nz,fail
          call Song_get_next_track:call z,fail
          cp 3:call nz,fail
          ret

instr_param1 BYTE "yeh"

raw_row1  instr_row_size_max ** BYTE #
raw_row2  instr_row_size_max ** BYTE #+16
raw_row3  instr_row_size_max ** BYTE #+32

paramX BYTE "X"

time1 WORD &BABE:BYTE 0
time2 WORD &8000:BYTE 2 ; more than &10000 ticks away 

test_big
;-------
;Full file 
          call nrt_init
          ld hl,vampire_name
          ld bc,0
          call load_file:call nc,fail
          ld de,destnrt:call nrt_save_no_meta
          call connect_bk_io
          ld hl,vampire
          ld de,destnrt
          ld bc,vampire_size
          call compare_sized
          ret

check_save_load_save
; --- Check idempotence ----

          ld a,".":call &BB5A
hack_ret  ret           ; to speed-up tests
; Save state
          call Song_get_instr:push af
; -- In NRT: doesn't use id > 4
          cp 5:call nc,fail
      ;    call phrase_get_row_position:push hl
          call song_get_current_phrase:push af
          cp 5:call nc,fail
          call get_current_track_header:push af ; also gives ID
          cp 5:call nc,fail
          call Song_get_current_subsong:push af
          cp 5:call nc,fail

; Clear buffer for comparaison (we don't know exact lenght)
          call connect_bk_io
          ld hl,destnrt:ld de,destnrt+1:ld bc,destsize-1:ld (hl),0:ldir
          ld hl,destnrt2:ld de,destnrt2+1:ld bc,destsize-1:ld (hl),0
          ldir

          call hook_check ; sanity

; -- Save twice: must give same result
          ld de,destnrt:call nrt_save
          call hook_check
          ld de,destnrt2:call nrt_save
          call hook_check
          ld de,destnrt
          ld hl,destnrt2
          ld bc,destsize
          call connect_bk_io
          call compare_sized

; -- Reload + save 
          ld hl,destnrt:call nrt_load
          call hook_check
          ld de,destnrt2:call nrt_save
          call hook_check
          ld de,destnrt
          ld hl,destnrt2
          ld bc,destsize
          call connect_bk_io
          call compare_sized

; Check state    
          call Song_get_current_subsong
          pop bc:cp b:call nz,fail
          call get_current_track_header
          pop bc:cp b:call nz,fail
          call song_get_current_phrase
          pop bc:cp b:call nz,fail
     ;     call phrase_get_row_position
     ;     pop de:or a:sbc hl,de:add hl,de:call nz,fail
          call Song_get_instr
          pop bc:cp b:call nz,fail
          ret

hook_check
hook_check_jp = $+1
          call _nocheck
_nocheck
          ret

_check_1_track
;Only track 1 set
          ld a,1:call _check_has_track
          ld a,2:call _check_no_track
          ret
_check_2_tracks
;Only track 1 and 4 set
          ld a,1:call _check_has_track
          ld a,2:call _check_has_track
          ld a,3:call _check_no_track
          ret
_check_has_track
          call get_track_header
          ld a,(hl):inc hl:or (hl):call z,fail
          ret
_check_no_track
          call get_track_header
          ld a,(hl):inc hl:or (hl):call nz,fail
          ret

_check_1_track_in_subsong
          call Song_get_first_track:call z,fail
          call Song_get_next_track:call nz,fail
          ret

almost_empty
; no assets, just some meta_data
      BYTE "AYA!"
          NO_TEXT()     ; author
          NO_TEXT()     ; album
      BYTE delai_ui_default
      WORD diapason_default
; meta data
      WORD dummy_       ; size
dummy_meta BYTE 0,1,2,3,4
dummy_ = $ - dummy_meta
      BYTE "Tabl":BYTE SENTINELLE ; End of list
      BYTE 0            ; Selected (given even if no table exist)
      BYTE "Inst":BYTE SENTINELLE
      BYTE 1            ; default instr
      BYTE "Phrs"
      WORD SENTINELLE_16 ; More than 256 possible phrases
      BYTE 0
      BYTE "Trck",SENTINELLE
      BYTE 0
      BYTE "Song"
;Even empty module has one subsong
      BYTE 0            ; id
      BYTE 1            ; alternative#
          NO_TEXT()
      BYTE SENTINELLE   ; no tracks
      BYTE 0            ; selected alternative
      BYTE SENTINELLE   ; no more subsongs
      BYTE 0            ; selected subsong
      BYTE "Smpl":BYTE SENTINELLE
      BYTE "Book":BYTE SENTINELLE
      BYTE "Xtra":BYTE SENTINELLE
      BYTE "Hist":BYTE SENTINELLE
      BYTE "End!"
almost_empty_ = $ - almost_empty

empty_phrase
; Just one empty phrase
      BYTE "AYA!"
          NO_TEXT()     ; author
          NO_TEXT()     ; album
      BYTE delai_ui_default
      WORD diapason_default
; meta data
      WORD dummy_       ; size
      BYTE 0,1,2,3,4
      BYTE "Tabl":BYTE SENTINELLE ; End of list
      BYTE 0            ; Selected (given even if no table exist)
      BYTE "Inst":BYTE SENTINELLE
      BYTE 1
      BYTE "Phrs"
      BYTE 0            ; phrase id
      BYTE 1            ; alt#
      BYTE type_phrase
      BYTE 0            ; no custom delai_ui
          NO_TEXT()
      BYTE phrase_param#
      BYTE 1            ; color = id + 1
      IF phrase_param# - 1
  !! add other params here
      END
      BYTE 0            ; rows #
      BYTE 0            ; alt selected
      WORD SENTINELLE_16 ; More than 256 possible phrases
      BYTE 0
      BYTE "Trck",SENTINELLE
      BYTE 0
      BYTE "Song"
;Even empty module has one subsong
      BYTE 0            ; id
      BYTE 1            ; alternative#
          NO_TEXT()
      BYTE SENTINELLE   ; no tracks
      BYTE 0            ; selected alternative
      BYTE SENTINELLE   ; no more subsongs
      BYTE 0            ; selected subsong
      BYTE "Smpl":BYTE SENTINELLE
      BYTE "Book":BYTE SENTINELLE
      BYTE "Xtra":BYTE SENTINELLE
      BYTE "Hist":BYTE SENTINELLE
      BYTE "End!"
empty_phrase_ = $ - empty_phrase


nrt_save
;In: de=dest
          ld a,d
          add vampire_size+&FF /&0100 ; max size
          cp &80:jr c,$+4:ld a,&80 ; clip to &8000
          call memdisk_init_write
          ld hl,memdisk_write_bloc
          ld de,dummy_meta
          ld bc,dummy_
          call save:call nc,fail
          ret

nrt_save_no_meta
          ld a,d:add destsize/&0100
          call memdisk_init_write
          ld hl,memdisk_write_bloc
          ld bc,0
          call save:call nc,fail
          ret

tmpbrk
          call &BE00
          scf           ; pretend it's ok
          ret


nrt_load
;In: hl=source   

; Clear dest for check below
          ld b,5
          ld de,dest_meta
          xor a
.clr      ld (de),a:inc de:djnz .clr

          ld a,h:add destsize/&0100:call memdisk_init_read
          ld hl,memdisk_load_bloc
          ld de,dest_meta
          ld bc,dummy_
          call load:call nc,fail
; Check meta data was loaded
          ld hl,dummy_meta
          ld de,dest_meta
          ld bc,dummy_
          call connect_bk_io
          call compare_sized
          ret

dest_meta SKIP dummy_

destsize = &1100        ; max fitting in page c0:4000

;Since IO buf is in c0, that's safe to put them here
destnrt = &5E00
destnrt2 = destnrt + destsize
          ASSERT(destnrt2 + destsize <= &8000)

vampire_name BYTE "testdata/vampire1.aya",0

hi
      SKIP &A400 - $    ; poor man's limit

      ORG &4C00
vampire
;Created with chipconv.o
      LOAD "testdata/vampire1.aya" ; Ref file
; vampire_size = $ - vampire   Doesn't work: unidos copy rounded to b00
vampire_size = &1110

; Sanity checks
          ASSERT(memcpc_code == memcpc)
          ASSERT(scankey_code == scankey)
          ASSERT(conv_code == conv)
          ASSERT(chunk_code == chunk_module)
; Sync with phrasui
          ASSERT(phrase_code == phrase)
          ASSERT(track_code == track_module)
; Sync with ayane             
          ASSERT(playsong_code == playsong_module)
          ASSERT(init_code == init_module)

      IF 0              ; dev_checks (ambiguous)
      SAVE "set const.dev_checks=0",0,0
      ELSE
      IF release
      SAVE "ayalib1r.bin",phrase,init_end - phrase
      SAVE "ayaior.bin",io_code,io_end - io_code
      SAVE "ayasalor.bin",salo_code,salo_end - salo_code
      ELSE
      SAVE "ayalib1d.bin",phrase,init_end - phrase
      SAVE "ayalib'd.bin",fx_module,init_end - fx_module ; for debug
      SAVE "ayaiod.bin",io_code,io_end - io_code
      SAVE "ayasalod.bin",salo_code,salo_end - salo_code
      END
      END
