	hack_minimala = 0       ; also used for 4k08
	hack_4k08 = 0
	hack_kim9 = 1
	hack  = 1
	 ; Convertion for chip'n'sfx

	; TOC:  
	  ; - song_map
	  ; - patterns
	  ; - instruments

	; 2025
	; ----- v0j2 -----
	  ; Mar
	   ; 20 Fix pitch pokage in workzone
	   ; 17 Skip loop pnt "*" (at 0 anyway in kim9.chp)    
	      ; Skip break "===" in patterns
             ; One was in a blank pattern
             ; The other makes no big difference
      ; Handle slow portemento down
      ; Use "use_instr_default" from ply conf
        ; instead of enable_instr_default
      ; Check no arp when default_use_arp=0
v0l2  = 1               ; Activate changes for kim9.chp

; 2024                                              
; ----- v0y ------
  ; Oct       
    ; 30 Introduce /import_row_size/ (< instr_row_size_max)
       ; Handle "C-B" (encoding for C-9) -> Period 0 
    ; 24 Remove "chip instr" specific code:
          ; - routines removed from chung anyway (rotten calls)
          ; - simpler/shorter code 
  ; Jun
; ----- v0l ------
    ; 17 New_instr_ayane and co: take ID
    ; 11 Fix regression minimala (un push de trop dans le refactoring)
; ----- v0k ------
    ;  6 Use both vib and vib_noise to avoid conflict
    ; Ok but conflict noise with 2 instr vib_noise at the same time.
    ;  3 Reprise.
       ; Fix: instr skip_line when already pointing on nl
            ; (needed when instrument don't have name)
       ; Fix global_transpose (wasn't applied)
       ; Fix Fx "10Y". Was doing vib with 256 steps 
                     ; instead of portamento
; ----- v0j ------    
  ; May
   ; 16 Revert v0i. See "journal.o" for rationale.
; ----- v0i ------    
   ; 15 Rewrite duration setting to allow duration 0 (= 65536)
       ; (see comment v0h below and rationale in journal)
  ; Apr                
   ; 29 Rename s/instr_ayane/instr_default for consistency (hmmmm)
      ; Hack instr_default: limit length to 16 (see /hack_minimala/)
        ; -> not enough anyway
      ; Replace instr_defaut by chipdownarpnoise:
        ; - less code (and more similaire to chipdownvib)
        ; - more compact data (no huge sequence due to slow volume fade)
        ; - all minimala instrs fit in &100

   ; 23 Fix .arpeggio for Y >= &e
   ; 22 Fix .chipdownvib: XY params weren't read
          ; + HACK for minimala 
      ; Fix .instr_ayane: copy/paste error for noise
      ; Fix .arpeggio: pre-multiply
      ; Fix .lpnoise: fill all rows
   ; 11 Fix song_length (wasn't incrementing C): 
      ; Fix note computation (wasn't subtracting "A" to get index)
                             ;wasn't subtracting "0" to get octave)
      ; /patterns/ Don't skip empty pattern 

      IMPORT "const.i"
      IMPORT "memmap.i"
      IMPORT "memcpc.o" ; connect_bk_st
      IMPORT "phrase.o"
      IMPORT "chung.o"
      IMPORT "track.o"  ; Song_add_map
      IMPORT "plyconf.i" ; tmp hack: some stuff deactivated

connect_bk_chip = connect_bk_io
module = st_module      ; &4000 (same address than for st module)

fail  = &BE00
to_be_implemented = &BE00
unexpectedinput = &BE00

;---------------------------------------
      MACRO CHECK_ROWS
      IF dev_checks
          call _check_rows
      END
      ENDM
;---------------------------------------

conv_chipn
;---------             
; IN: hl: start of CHP module (text)
          call connect_bk_chip

; "chip n sfx" tag, already checked to get file type (TODO)
          call skip_line

          call skip_line ; song name (TODO)
          call skip_line ; description (TODO)
          call skip_separator ; "==="
; -- Replay freq
          call decXX2val
          cp 50:call nz,to_be_implemented
          ld a,"/":call consume_char
; -- Delai
          call decX2val
          ld (delai),a
; -- Transpose
          ld a," ":call consume_char ; If fail: handle delai > 9
          call decXX2val_signed
          ld (global_transpose),a
          call skip_nl
;-------
song_map
;-------
          ld c,0        ; Song_length
          ld de,workzone
.lpmap
          ld a,(hl):cp "="
          jr z,.endmap

          ld b,3
.lpchan
; --- Pattern id
          call hex#XX2val
          ld (de),a:inc de
; --- Transpose
          call decXX2val_signed
          ld (de),a:inc de

          dec b
          jr z,.endchan

          ld a," ":call consume_char
          jr .lpchan

.endchan
      IF v0l2
;for now skip "*" loop 
          ld a," ":call skip_char_if_present
          ld a,"*":call skip_char_if_present
      END
          call skip_nl
          inc c
          jr .lpmap

.endmap
          ld a,c:ld (song_length),a
          call skip_separator

; !!!! Cannot register song_map right now:
; !!!! -> we must process patterns, because /Song_add_map/
; !!!! -> needs to know each pattern length to place events.

; ------
patterns
; ------

.patlp                  ; each pattern
          ld a,(hl):cp "="
          jp z,.patend

          push hl
.progress ld hl,&C000
          ld (hl),&55
          inc hl
          ld (.progress+1),hl
          pop hl

          call hex#XX2val

      IF 0
; Handle empty pattern
; Deactivated: minimala.chp songmap refers to the empty pattern #27
; If we don't register this empty pattern, Song_add_map will assert
; (via Get_phrase)
          ld c,a
          call is_nl
          jr z,.rowend
          ld a,c
      END

          call song_select_new_phrase:call nc,fail
.rowlp
          call connect_bk_chip
          call is_nl
          jr z,.rowend

          ld a," ":call consume_char
;----
;convert note
;----             
      IF todo
;If same note: don't flag it
      END
          ld a,(hl)
          cp ".":jr z,.no_note
      IF v0l2
          cp "=":jr z,.break
      END

; set delai to 0, proper delai added at end of iteration
          xor a
          call phrase_select_new_row:call nc,fail
          call connect_bk_chip

          ld a,(hl):inc hl
          add notes AND &FF - "A":ld e,a
          ld d,notes/&0100
          ld a,(de):ld c,a
          ld a,(hl):inc hl
          cp "#":jr nz,$+3:inc c
; handle "C-B": encoding for "C-9" 
      IF todo
; (period 0 or cut?)
; For now choose octave 9: should point to period 0 as well.
; !! todo, check that as well 
      END
          ld a,(hl):inc hl
          cp "B":ld a,9:jr z,.okoctave
          dec hl
          call decX2val
.okoctave
          inc a         ; +1 octave to match midi numbering
          2 ** add a:ld b,a:add a:add b ; octave: a*12
          add c
          ld c,a:ld a,(global_transpose):add c
          call row_set_note
          call connect_bk_chip
          ld a,":":call consume_char
          call decXX2val
          call row_set_instr
          call connect_bk_chip
          jr .ok_note

      IF v0l2
.break
; For now just skip it
      IF todo
  ; Warn that is not handled
  ; Later: handle it
      END
          call consume_inline:BYTE "===:..",0
          jr .ok_note
      END


.no_note
          call consume_inline:BYTE "...:..",0
;enchaine
.ok_note
          ld a,(delai)
          call row_add_duration
          jr .rowlp

.rowend
          call skip_nl
          jp .patlp
.patend
          ld a,(song_length):ld b,a

          push hl
          ld hl,workzone
          call Song_add_map
          pop hl

          call connect_bk_chip
          call skip_separator

; --------------
instruments
; --------------

.instrlp
          call connect_bk_chip
          ld a,(hl):cp "="
          jp z,.instrend

          ld a,":":call consume_char
;instr_id
          call hexXX2val
          ld (cur_instr),a
          call consume_space

;Clear workzone (512 bytes)
;No longer instrument will be generated: if vol decrease too slowly,
; we switch to chipnsfx like instr. 
;Well, some corner cases not handled (noise decreasing too slowly)
max_rows = 512 / instr_row_size_max
          push hl
          ld hl,workzone
          ld de,workzone+1
          ld bc,511
      IF workzone AND &FF
 !!! ld (hl),0  instead
      END
          ld (hl),l
          ldir
          pop hl

;volume 
          call hexXX2val:ld b,a ; initial volume
          call hexXX2val:ld c,a ; step
          ld (volume),bc
          call consume_space
;noise
          call hexXX2val:ld b,a ; initial noise
          call hexXX2val:ld c,a ; step
          ld (noise),bc
          call consume_space
   ; poke noise even in default instrument is not used in the end 
   ; done even if noise = 0 (save test) 
          ld a,c
          cp &7F:call z,to_be_implemented
          cp &80:call z,to_be_implemented
          push hl
          ld hl,workzone + instr_noise
          ld de,instr_row_size_max
          ld a,b
          ld b,max_rows
.noiselp
          ld (hl),a:3 ** srl (hl)
          add hl,de
          add c
          djnz .noiselp
          pop hl
;fx
          call hexX2val
          push af
          ld (fx),a
          call hexX2val:ld b,a ; X
          call hexX2val:ld c,a ; Y      
          ld (XY),bc
          pop af
          push hl
          call poke_fx
          call create_instr
;.instrname
          call connect_bk_chip
          pop hl
      IF dev_checks
 ; check proper pnt
          ld a,h:cp &40:call c,fail
          cp &80:call nc,fail
      END

      IF todo
; copy name
      END
          call skip_line
          jp .instrlp

.instrend
          ret


create_instr
;Dispatch to dedicated inst
;if non constant noise, needs default instr 
; here a = nb rows (arpegio length)     

          ld bc,(noise)
          ld a,c:or b:jr z,.chipdown
          ld a,c:jr nz,.instr_default
;Constant noise
          ld a,(fx)
          or a:jr z,.chipdownarp_noise
          jr .chipdownvib_noise

.chipdown
; No noise
          ld a,(fx)
          or a:jr z,.chipdownarp_only
          jr .chipdownvib_only

.chipdownarp_only
; -register instr 
      IF use_instr_chip_down_arp
          ld bc,(volume)
; In instr code, we use 'sub' for saturation
; So we must convert +Y -> -Y
          ld a,c:neg:ld c,a
          ld a,(cur_instr)
          call New_instr_chp_down_arp
          jr .chipdownarp_com
      ELSE
          jr .instr_default
      END

.chipdownarp_noise
; here (sp) = nb rows (arpegio length)
; -register instr    
      IF use_instr_chip_down_arp_noise
          ld bc,(noise)
; For now we assume constant noise
          ld a,c:or a:call nz,to_be_implemented
          ld a,b
          3 ** rrca:and &1F ; remove decimale part 
          ld d,a
          ld bc,(volume)
; In instr code, we use 'sub' for saturation
; So we must convert +Y -> -Y
          ld a,c:neg:ld c,a
          ld a,(cur_instr)
          call New_instr_chp_down_arp_noise
      ELSE
          jr .instr_default
      END

.chipdownarp_com
; Flatten arp "table"
          ld a,(workzone + instr_arp + instr_row_size_max)
          ld (workzone + 1),a
          ld a,(workzone + instr_arp + instr_row_size_max*2)
          ld (workzone + 2),a
          ld a,(fx_rows#):ld b,a
          CHECK_ROWS()
          ld hl,workzone
          call instr_chip_append_rows_byte
          ld a,(arp_loop)
          ld b,a
          call instr_set_loop
          ret

.chipdownvib_only
; -register instr 
      IF use_instr_chip_down_vib
          ld bc,(volume)
; In instr code, we use 'sub' for saturation
; So we must convert +Y -> -Y
          ld a,c:neg:ld c,a
          ld a,(cur_instr)
          call New_instr_chp_down_vib
          jr .chipdownvib_com
      ELSE
          jr .instr_default
      END

.chipdownvib_noise
; here (sp) = nb rows (arpegio length)
; -register instr    
      IF use_instr_chip_down_vib_noise
          ld bc,(noise)
; For now we assume constant noise
          ld a,c:or a:call nz,mess ; checked beforehand
          ld a,b
          3 ** rrca:and &1F ; remove decimale part 
          ld d,a
          ld bc,(volume)
; In instr code, we use 'sub' for saturation
; So we must convert +Y -> -Y
          ld a,c:neg:ld c,a
          ld a,(cur_instr)
          call New_instr_chp_down_vib_noise
      ELSE
          jr .instr_default
      END

.chipdownvib_com
; Flatten pitch "table"
          ld hl,workzone + instr_pitch
          ld de,workzone
          ld a,(fx_rows#)
          push af
.flat
          ldi
          ldi
          ld bc,instr_row_size_max-2
          add hl,bc
          dec a
          jr nz,.flat

          pop bc
          CHECK_ROWS()
          ld hl,workzone
          call instr_chip_append_rows_word
          ld b,0        ; vib: loop at 0
          call instr_set_loop
          ret

.instr_default
      IF use_instr_default
;When noise, use ayane default instr
; --- Regular ayane instrument, prepare table
          ld de,instr_row_size_max
; -- Volume         
; For now, we don't handle "slow" instr 
; -> too much rows?
  ; (well, not anymore for chung perspective)
  ; but then must reserve & init &100 * instr_row_size_max for workzone
          ld bc,(volume)
          ld a,c:cp &FD:call nc,to_be_implemented

          ld a,b
          ld b,0        ; count nb rows 
          ld hl,workzone+instr_vol
.lpvol
          push af
; Encode XXXX0 to be flagged as volume.
          3 ** rrca:and &1E
          ld (hl),a
          pop af
          add hl,de
          inc b
          add c
          jr c,.lpvol
;Last volume could be > 0, nevermind
          push bc       ; b= nb row

; --- Register instr
          ld a,(cur_instr)
          call New_instr_ayane

; infer r7 for noise (3f or 07 if noise set)
          ld hl,workzone
          push hl
          ld b,max_rows
          call Setup_row_r7
          pop hl
      IF hack_minimala AND 0
; use the fact instrument is interrupted
          pop af        ; nb rows
; instr5: batterie. FEF8 4000 0C0
          cp 31:jr c,$+4:ld a,31
          ld b,a
      ELSE
          pop bc        ; nb rows
      END
          push bc
          CHECK_ROWS()

      IF 1-default_use_arp
; check no arp
          push bc
          push hl
          ld hl,workzone+instr_arp
          ld de,instr_row_size_max
.chk      ld a,(hl):or a:call nz,mess
          add hl,de
          djnz .chk
          pop hl
          pop bc
      END

          call instr_ayane_append_rows
          pop bc
          dec b
; Hack: Set loop to last row (end of instrument)
          call instr_set_loop
          ret
      ELSE
          call mess
 ; Must set use_instr_default = 1
      END


; ----------------------------------------
; Helpers high level
; ----------------------------------------
      IF v0l2
poke_fx
; A= fx
; B= X
; C= Y          
          or a:jr z,.arpeggio
          dec a:jp z,.chipFX1
          call to_be_implemented

.arpeggio
; Prepare full arpegio sequence.
          xor a:ld (arp_loop),a ; default 
          ld hl,workzone + instr_arp
          ld de,instr_row_size_max

          call get_arp_X
          ld a,c:or a:jr z,.arp2
          call get_arp_Y
          ld a,b
; pre-multiply
          add a
          sla c
          bit 7,c:jr nz,.arp_stale ; special chipnsfx case (Y=E or F)
;Fill entirely. Real length established in .lpvol
          ld b,max_rows/3
.lparp3
          call one_arp3
          djnz .lparp3
.fx_ret3
          ld a,3
.fx_ret
          ld (fx_rows#),a
          ret

.arp_stale
; 0 X Y Y Y Y Y...
          call one_arp3
          ld b,max_rows - 3
.lparp
          ld (hl),c:add hl,de
          djnz .lparp
          ld a,2:ld (arp_loop),a
          jr .fx_ret3

.arp2
          ld a,b
          or a:jr z,.noeff
; -- Arp 0X 
          ld b,max_rows/2
          add a
.lparp2
          ld (hl),0:add hl,de
          ld (hl),a:add hl,de
          djnz .lparp2
          ld a,2
          jr .fx_ret

.noeff
; We must set nbrows# = 1
          ld a,1
          jr .fx_ret

.chipFX1
; (partly) reproduce chip instrument
; - for vibrato/portamento, usual table
; Here: B=X 
      ; C=Y            
          ld a,c
          or a:jr nz,.no_slow_porta
      IF hack_kim9
;!! hack for kim9.chp
      END
          ld bc,-1
          ld a,1        ; will add -2 
          jr .okdirection

.no_slow_porta
          cp 8:call z,to_be_implemented ; idem going down

          ld a,b:or a:jr nz,.chipvib
;--- Fast portamento
          ld a,c
          ld bc,-1      ; up
          cp 9:jr c,.okdirection
          sub 8
      IF dev_checks
          call z,fail   ; unexpected here
      END
; mitigation for adaptive portamento
          ld bc,1
.okdirection
      IF dev_checks
          or a:call z,fail ; unexpected here
      END
.shiftlp
;bc*=pow(2,a-1)
          dec a:jr z,.shiftend
          sla c:rl b
          jr .shiftlp
.shiftend
      IF hack_4k08
  ; mitigation for octave
;04:Batterie1 applied on octave 3 (more or less)
;05:Batterie2 applied on octave 4
          ld a,(cur_instr)
          cp 4:jr nz,.okhackporta
          sla c:rl b    ; bc +16 instead of +8
.okhackporta
      END
          ld hl,workzone + instr_pitch
          ld de,0
      IF hack_minimala
; Needed length depends on how long the note is played
; For now, hardcoded!
          ld a,8
      ELSE
      IF hack_kim9
          ld a,6        ; Boum1 volume too low after that 
      ELSE
 !!! todo: compute length wrt volume fading
      END
      END
          push af
.portalp
          ld (hl),e:inc hl
          ld (hl),d
          push bc
          ld bc,instr_row_size_max - 1
          add hl,bc
          pop bc
          ex de,hl
          add hl,bc
          ex de,hl
          dec a
          jr nz,.portalp
          pop af
          jr .fx_ret


.chipvib
;--create table b**0 b**+Y b**0 b**-Y
      IF dev_checks
          inc b:dec b:call z,fail
      END
          ld a,c
      IF hack_minimala
; Hack for minimala.chp, as we don't do proportional vibrato
          cp 12:ld c,&21:jr z,.okhack
          inc a:srl a:ld c,a
      ELSE
      IF hack_4k08
; hack for 4k08.
; i don't understand when it goes up or down
          cp 1:ld c,-2:jr z,.okhack
          cp 2:ld c,-4:jr z,.okhack
; 11: leave as is
          ld c,a
      ELSE
      IF hack_kim9
 ; kim9: vib -2/+2 sur C5 (pat#18)
          ld c,-2
      END
      END
      END
.okhack
          ld a,c
          ld hl,workzone+instr_pitch
          call fillw0_row
          call fillwa_row
          call fillw0_row
          neg
          call fillwa_row
          ld a,b:add a:add a ; total nb rows
      IF dev_checks
          or a:call z,fail
      END
          jp .fx_ret

.one_arp3
          ld (hl),0:add hl,de
          ld (hl),a:add hl,de
          ld (hl),c:add hl,de
          ret
      END
; ---------------
; helpers low level
; ---------------
      IF dev_checks
_check_rows
          ld a,b
          or a:call z,mess
          cp max_rows+1:call nc,mess
          ret
      END

hex#XX2val
          ld a,"#":call consume_char
;Enchaine
hexXX2val
          push bc
          call hexX2val
          4 ** add a
          ld c,a
          call hexX2val
          add c
          pop bc
          ret

hexX2val
          ld a,(hl):inc hl
          sub "0"
          cp 10:ret c
          res 5,a       ; Convert "a"-"0" to "A"-"0"
          add 10-"A"+"0"
          ret

decXX2val
; Convert 00-99 (in ASCII)     
          push bc
          call decX2val
          add a:ld c,a:2 ** add a:add c ; *10
          ld c,a
          call decX2val
          add c
          pop bc
          ret

decXX2val_signed
; Convert +xx/-xx 
          push bc
          ld a,(hl):inc hl ; sign
          push af
          call decXX2val
          ld c,a
          pop af
          cp "+":jr z,.okval
          cp "-":call nz,fail
          ld a,c
          neg
          ld c,a
.okval
          ld a,c
          pop bc
          ret

decX2val
          ld a,(hl):inc hl
          sub "0":call c,fail
          cp 10:call nc,fail
          ret

consume_space
          ld a," "
;enchaine
consume_char
; Verify expected char and advance pointer.
; IN: A= expected char
          cp (hl):call nz,unexpectedinput
          inc hl
          ret

consume_inline
; Consume nt-string
; IN:  call consume_inline:byte "toto",0
    ;  HL: current pointer in chip
          ex de,hl
          ex (sp),hl
.lp
          ld a,(hl):or a:jr z,.done
          ld a,(de)
          cp (hl):call nz,unexpectedinput
          inc de
          inc hl
          jr .lp
.done
          ex (sp),hl    ; jump back into "nop". Nevermind
          ex de,hl
          ret

      IF v0l2
skip_char_if_present
; Only skip char if present
; In a = char to skip
          cp (hl)
          ret nz
          inc hl
          ret
      END

skip_separator
          call consume_inline:BYTE "===",0
          jr skip_nl

skip_line
; Return hl past next nl.
          call is_nl
          inc hl        ; next char no matter was
          jr nz,skip_line
; Enchaine
skip_nl
; Skip 1 or less instance of &0d or &0a or &0d, &0a or ""
; (eg doesn't check there is actually a nl)
; Note: calling is_nl repeatly would consume all NLs.
          ld a,(hl):cp &0D:jr nz,.skip0a
          inc hl
.skip0a
          ld a,(hl):cp &0A:ret nz
          inc hl
          ret

is_nl
; Peek and return Z if newline code
          ld a,(hl)
          cp &0D:ret z
          cp &0A:ret z
; also consider 00 / 1A (eof) as NL
          cp &1A:ret z
          or a
          ret

poke_a_signed
          ld (hl),a:inc hl
          ld (hl),0:bit 7,a:jr z,$+3:dec (hl)
          inc hl
          ret


fillw0_row
          push af
          xor a
          call fillwa_row
          pop af
          ret

fillwa_row
; Poke B * word A, column-wise until max_row is reached
; In: A = value (sined)
    ; B = rep
    ; C = current row
    ;HL = pos field in table
; Out: C = row+B
     ; NC when end reached
          push ix:ld ixl,b
.lp
          call poke_a_signed
          push bc
          ld bc,instr_row_size_max-2
          add hl,bc
          pop bc
          inc c
          push af
          ld a,c:cp max_rows:jr z,.full
          pop af
          djnz .lp
          scf
          jr .exit

.full
          pop af
          or a
.exit
          ld b,ixl:pop ix
          ret

      FILL -$ AND 7,&F7

notes
; "ABCDEFG" in half tones
      BYTE 9,11,0,2,4,5,7
      IF $-1 / &0100 - notes/&0100
 !! confine issue
      END

get_arp_X
; Correct arp: 
    ; D -> +24
    ; E -> -24
    ; F -> -12
;In:  B = X
;Out: B = corrected arpegio

          ld a,b:sub &0D:ret c
          ld b,24:ret z
          dec a
          ld b,-24:ret z
          ld b,-12
          ret

get_arp_Y
; Correct arp: 
    ; D -> +24
    ; E -> -24
    ; F -> -12
;In:  A = Y
;Out: C = corrected arpegio

          ld c,a
          sub &0D:ret c
          ld c,24:ret z
          dec a
          ld c,-24:ret z
          ld c,-12
          ret

; Variables (temp)
delai BYTE 
global_transpose BYTE 
song_length BYTE 
volume WORD 
noise WORD 
fx    BYTE 
XY    WORD 
fx_rows# BYTE 
arp_loop BYTE 
cur_instr BYTE 
