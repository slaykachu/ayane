; <<<<< chung: gestion chunk? + instr >>>>>
; TODO: see what's up with firmware, since we use EXX.
; 2025 Jun 14. Add instr_does_exist
; hist in journal.o
dev_checks = 1
todo  = 1
todo_later = 1          ; non urgent/critical todo
makeroom = 1
st    = 0               ; disabled for now

; We don't discriminate tables: arpegio, volume, ...
type_table_empty = 0
type_table_byte = 1
type_table_word = 2

table_header_size = 3   ; type, size in bytes, loop len

; Poc (to be completed)

; Setup ---------------
    ; Init_chung 

; Instr creation ------
    ; New_instr
    ; New_instr_ayane
    ; New_instr_ayane
    ; New_instr_chp_down_vib
    ; New_instr_chp_down_vib_noise
    ; New_instr_chp_down_arp
    ; New_instr_chp_down_arp_noise
    ; Song_select_instr
    ; Song_get_instr
    ; Setup_row_r7      
    ; instr_does_exist
    ; instr_ayane_append_rows
    ; instr_get_rows#         
    ; instr_set_rows#         
    ; instr_set_loop
    ; instr_get_loop 
    ; set_flags    

; Instr edition for instrui ----
    ; insert_empty_row
    ; instr_append_empty_row
    ; del_row
    ; select_row
    ; get_row
    ; set_row

    ; --- Helper (salo / compile) ------
    ; is_last_row

row_link = 2

; How each instr column (flags, arp, ...) is encoded
; Will allow:
   ; - indirection (table) like in 
   ; - mix-in special handling (like chipnsfx's 
; For now only used for future-proof serialisation.
column_type_default = 0 ; only used for special fx as sentinelle
column_type_const = 1   ; not used
column_type_table = 2   ; not used
column_type_table' = 3  ; table with special modulo
column_type_custom = 4  ; only type used (for serialization)
column_type_ramp = 5    ; not used (future: mimick chipnsfx)

      IMPORT "const.i"
      IMPORT "memmap.i"
      IMPORT "plyconf.i" ; for nb_fx and use_instr_chip_down_vib (tmp)

      IMPORT "ply.o"    ; For fx_set_phrase
      IMPORT "instr.o"  ; Use LSB as type.
      IMPORT "timer.o"  ; fx_end/sync_buzzer_register
      IMPORT "heap.o"   ; new_heap_chunk
      IMPORT "chunk.o"  ; new_chunk 
      IMPORT "memcpc.o"

bk_connected = &3C      ; hack: avoid "ambiguous label"

; !!!! TODO? [Optim]: to save bk connection for fx signature,
                    ; we might compile (or copy) player out of bank
             ;---> UNEEDED when player intool (rom) as well

; !!!! Scheis !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
; !!!!!! What the heck with fx interface
; !!!!!!   - Already init in instr vs direct jump
; !!!!!!   - How to enforce that?
; interface!!!  some routine needs a call to _prelude beforehanb !!!!!!
;               -> how can we know?

      IF nb_fx:ELSE
!!! We must have at least 1 fx (set ayane=1)
  ; to be able to handle fx_set_phrase
  ; Needed for 'goto next chunk' and 'goto start of phrase'
; For compile, it needs to be dynamic anyway.
; E.G.  : nb_fx = 4 for in-tool
  ; If a particular music doesn't use fx, then we remove handling
  ; dynamically.
      END


hist
; TODO: see what's up with firmware, since we use EXX.

; //// 2025 /////////////////
; ------ For v0l2 -------
; Mar   
  ; 20 Remove check instr_null (which has been removed as useless)
  ; 18 Use use_instr_chip_down_vib_noise

;==============================================
      MACRO EXPECT_EQUAL x,y
      IF x-y
   !! should be equal
      END
      ENDM

      MACRO INIT_LENGTH
      IF todo
; rename s/lenght/duration (or better term)
      END
      IF pos_flags - 1
 !! a revoir
      END
          ld (hl),a:inc l
      ENDM

      MACRO SKIP_LENGTH
          pos_flags ** inc l
      ENDM

      MACRO SKIP_LENGTH_DE
          pos_flags ** inc e
      ENDM

      MACRO CP_COPY_LENGTH
          pos_flags ** call cp_copy
      ENDM

      MACRO SKIP_RESERVED
          reserved_byte ** inc l
      ENDM

      MACRO CHECK_INSTR_PNT
      IF dev_checks
          call _check_instr_pnt
      END
      ENDM

      MACRO CHECK_SFX
;Check sfx fields n**sync_buzzer, then sfx null
;In: HL= start row instr
      IF dev_checks
          call _check_sfx
      END
      ENDM

      MACRO CHECK_SFX_DE
;Check sfx fields n**sync_buzzer, then sfx null
;In: HL= start row instr
      IF dev_checks
          ex de,hl
          call _check_sfx
          ex de,hl
      END
      ENDM


;==============================================
fatal = &BE00           ; TODO: replace by warning mecanism.
memory_full = fatal
mess  = &BE00
unexpected = &BE00
to_be_implemented
          call &BE00
;implement/handle me
          ret

      IF dev_checks
_check_instr_pnt
          push de
          ld de,tables:or a:sbc hl,de:add hl,de:call c,fail
          ld de,tables_:or a:sbc hl,de:add hl,de:call nc,fail
          pop de
          ret

_check_sfx
; Check 2 fx (possibly fx_null) and then fx_end
          push af:push bc:push hl
          ld bc,fx0_type
          add hl,bc
          ld a,MAX_FX_BY_INSTR
.lp
          push hl
          ld c,(hl):inc hl
          ld b,(hl)
          ld hl,fx_null:or a:sbc hl,bc:jr z,.ok
          ld hl,sync_buzzer_register:or a:sbc hl,bc:jr z,.ok
; for now just one type of fx possible. If not sync_buzzer, break
          call fail
.ok
          pop hl
          ld bc,instr_fx_size
          add hl,bc
          dec a
          jr nz,.lp

          ld c,(hl):inc hl
          ld b,(hl)
          ld hl,fx_end:or a:sbc hl,bc:call nz,fail

          pop hl:pop bc:pop af
          ret
      END

  ; =====================================
  ; ------ song interface ---------------
  ; =====================================

  ; all register expect A preserved

Init_chung
; in:  N/A     
          call Init_chunk_module
          call connect_bk_base
          ld hl,zero_chung
          ld de,zero_chung+1
          ld bc,zero_chung_-1
          ld (hl),0
          ldir

;enchaine
song_reset_chung
;---------------
; Part of song handled here (instr, arp, ...)
          call connect_bk_base

          ld hl,def:ld de,var:ld bc,def_size:ldir ; non-zero vars
          ex de,hl
          ld b,zero_size:xor a:call fillb

; instr_head_type = 0 marks absence of instr
; Needed to be able to pick non-contiguous instruments.
          ld hl,instr_idx
          ld de,instr_idx+1
          ld bc,instr_head_size*&0100 - 1
          ld (hl),0
          ldir

      IF todo
;TODO: free stored_table_start before hand
; !!!    memory leak
      END
; Note: can't reuse new_chunk_ext, as it put a sentinel with current
      ; track for auto-loop.
  ;- No current_track at this point! (would trigger all kind of asserts)
  ;- Wouldn't make sense for table anyway.
          call New_heap_chunk
          ret nc
          call connect_bk_base
          ld (stored_table_start),hl
          ld (stored_table_back),hl ; for l = bk
          ret           ; Carry

fill      ld (hl),a:inc l:jr nz,fill
          ret
fillb     ld (hl),a:inc hl:djnz fillb
          ret

Song_get_instr
;-------------
          call _prelude
          ld a,(va_current_instr)
          jp _postlude

instr_does_exist
;---------------
;Reselect currect instrument, just for flag!
          call Song_get_instr
;enchaine
Song_select_instr
;----------------
; In: A: inst number (from 1. 0 reserved)
    ; Note: 0 can happen when empty module (salo-nrt)
; Out: If instr exist, NZ, A = Id type instrument (for SALO) 
                         ; H = Param size (cf instr.SIGN)
                         ; L = Size row   (idem)
                     ; Z otherwise, A, HL trashed    
     ; In any case H trashed
     ; Instr selected (even in non existent)

          call _prelude
_select_instr
          ld (va_current_instr),a
          call get_instr_pnt
          ld a,(hl):or a ; Instr type <> 0? 
          ld l,a
          ld h,instr_code/&0100
          dec hl:ld a,(hl)
          dec hl:ld d,(hl)
          dec hl:ld e,(hl)
          ex de,hl
          scf
          pop de        ; stack correction
          jp _postlude_

New_instr
; Generic builder for loading and ui
; in: A= ID
    ; B= instr type 
    ; C= params# 
    ;HL= params
;Out: A= row size
          EXPECT_EQUAL(type_instr_null,0)
          EXPECT_EQUAL(type_instr_mute,1)
          EXPECT_EQUAL(type_instr_default,2)
          inc b:dec b:call z,to_be_implemented
          dec b:call z,to_be_implemented
          dec b:jr z,.default
          call unexpected

.default
; for now, expect 0 params 
          inc c:dec c:call nz,unexpected
;enchaine
New_instr_ayane
          ld e,instr_default AND &FF
;enchaine
_select_new_instr
; create new empty instr, and select it.
; In:  A = Id
    ;  E = type 
; Out: Carry if ok, instr selected
     ; NC otherwise (memory full) 
     ; A/L like Song_select_instr
          call _prelude
      IF dev_checks
          or a:call z,unexpected ; 0 reserved (for mute?)
      END
          ld l,a
          call _get_instr_pnt
          instr_head_type ** inc hl
          ld (hl),e
          instr_head_rows - instr_head_type ** inc hl
; reset table and params (00 used as default)
          ld b,instr_head_size - instr_head_rows
.raz      ld (hl),0:inc hl:djnz .raz
          jp _select_instr

      IF use_instr_chip_down_vib
;Temp hack to fit all instr in &100
      IF todo
;Anyway: should just have one version with noise
       ; -> pick/build the right routine at compile time 
          ; if noise never used
      END
New_instr_chp_down_vib
;---------------------
; Create ad-hoc instr reproducing chipnsfx intsrument with
    ; - Volume going down
    ; - No noise
    ; - Vibrato
; In  A = ID
   ;  b = initial volume (8 bits)
   ;  c = step volume to be substracted (8 bits) 
          ld e,instr_chip_down_vib AND &FF
      END
_new_instr_chp
; use generic routine to gain space
          ld d,c:ld c,b
          ld b,0        ; 3rd param: unused 
          jr New_instr_chp

      IF use_instr_chip_down_arp
New_instr_chp_down_arp
;---------------------
; Create ad-hoc instr reproducing chipnsfx intsrument with
    ; - Volume going down
    ; - No noise
    ; - Arpegio
; In  a = ID
   ;  b = initial volume (8 bits)
   ;  c = step volume to be substracted (8 bits) 
          ld e,instr_chip_down_arp AND &FF
          jr _new_instr_chp
      END

      IF use_instr_chip_down_vib_noise
New_instr_chp_down_vib_noise
;---------------------------
; Create ad-hoc instr reproducing chipnsfx intsrument with
    ; - Volume going down
    ; - Constant noise (can be off = 0)
    ; - Vibrato
; In  a = ID
   ;  b = initial volume (8 bits)
   ;  c = step volume to be substracted (8 bits) 
   ;  d = noise (set first)
          ld e,instr_chip_down_vib_noise AND &FF
          jr New_instr_chp
      END

      IF use_instr_chip_down_arp_noise
New_instr_chp_down_arp_noise
;---------------------------
; Create ad-hoc instr reproducing chipnsfx intsrument with
    ; - Volume going down
    ; - Constant noise (can be off = 0)
    ; - Arpegio
; In  a = id
   ;  b = initial volume (8 bits)
   ;  c = step volume to be substracted (8 bits) 
   ;  d = noise (set first)
          ld e,instr_chip_down_arp_noise AND &FF
      END
New_instr_chp
          call _select_new_instr
          call get_instr_pnt
          instr_head_ext ** inc hl
          ld (hl),d:inc hl
          ld (hl),c:inc hl
          ld (hl),b
          ret

instr_ayane_append_rows
;----------------------
; Ayane's version: full row.
; Only used by chipn.

          call _prelude
.rowlp
          ld a,instr_row_size_max
          call instr_append_row_
; --- when 0 is passed as fx, must be replaced by fx_end
; (as we jump to the address. well there is an assert in instr.o to
  ;check it is a proper address)
; !!! for now, fx_null + fx_null + fx_end is expected
; !!! rather than just fx_end (c.f. CHECK_SFX)
; !!! Doesn't matter since whole size is allocated anyway
      IF todo_later
; just put fx_end if no fx, and fx_null if fx only in 2nd slot
      END
          push hl
          ld hl,fx0_type-instr_row_size_max:add hl,de
          ld (hl),fx_null AND &FF:inc hl
          ld (hl),fx_null / &0100
          ld de,instr_fx_size-1:add hl,de
          ld (hl),fx_null AND &FF:inc hl
          ld (hl),fx_null / &0100
          ld de,instr_fx_size-1:add hl,de
          ld (hl),fx_end AND &FF:inc hl
          ld (hl),fx_end / &0100
          pop hl
          djnz .rowlp

          jr _postlude


instr_chip_append_rows_byte
;--------------------------
; chip version: 1 byte per row (e.g. arpegio)
          ld a,1
          jr instr_append_rows

instr_chip_append_rows_word
;--------------------------
; chip version: 1 word per row (e.g. vibrato)
          ld a,2
;enchaine
instr_append_rows
;----------------
; Set all rows in bulk (typically when importing from other tracker)
; In: hl: table with A-sized rows 
    ;  a: row size
    ;  b: nb rows
          call _prelude
.rowlp
          call instr_append_row_
          djnz .rowlp
_postlude
          scf
_postlude_fail
          pop hl
_postlude_
          pop ix:pop de:pop bc
          ret

insert_empty_row
;---------------
; In: A= row# (can't use selected_row as we need to goto previous row)
          push af
          ld b,a
          ld a,instr_row_size_max
          call allocate_new_row
          call instr_goto_row
          ld c,(hl):ld (hl),e:inc hl
          ld b,(hl):ld (hl),d
          ex de,hl
          ld (hl),c:inc hl
          ld (hl),b:inc hl
          ex de,hl
          pop af
;enchaine
select_row
;---------
; In: A= row#
    ; instr selected
          ld b,a
          inc b
          call instr_goto_row
          CHECK_INSTR_PNT()

          row_link ** inc hl
          ld (selected_row),hl
          ret

get_row
;------                  
; Copy row from ayane instrument
; IN: DE: buffer for row data
    ; select_row was called
           ; - simpler for client
           ; - avoid redoing same stuff
          ld hl,(selected_row)
          CHECK_INSTR_PNT()
          CHECK_SFX()
          jr _row_copy

instr_set_row           ; tmp hack to resolve ambiguity
set_row
;------
; Copy row to ayane instrument
; IN: DE: row data
    ; select_row was called (see /get_row/)
          ld hl,(selected_row)
          CHECK_INSTR_PNT()
          ex de,hl
          CHECK_SFX()
_row_copy
          ld bc,instr_row_size_max
          ldir
          ret


del_row
;------
; In: A= row# (same as /insert_empty_row/)

; When loop to suppressed row, link would be dangling.
; We must detect this case
          call instr_get_loop
          push af
          push bc
          ld b,a
          call instr_goto_row
          push hl
          ld e,(hl):inc hl
          ld d,(hl)
      IF todo
; - release memory
; - copy data in work buffer for CONTROL-P
      END
          ex de,hl
          CHECK_INSTR_PNT()
          ld c,(hl):inc hl
          ld b,(hl)
          pop hl
          ld (hl),c:inc hl
          ld (hl),b
; Handle corner case when was pointing to suppressed row
          pop bc
          pop af
          ret nc        ; no loop
          cp b
          ret nz        ; no
; Re-set loop
; Note: if loop was set to last row (now deleted),
      ; loop will be set to new last row.
; If we had 0 -> 1 > 1 + &8000 (loop to 1), deleting line 1 gives:
          ; 0 -> 1 + &8000 (dangling pointer)
; So, remove dangling pointer
          ld a,b
          call instr_goto_last_row
          ld b,a
          xor a
          ld (hl),a:inc hl
          ld (hl),a
;enchaine
instr_set_loop
;-------------
; Set loop link
; In: B: dest row
; If B > last row, clip to last row
; (useful for del_row corner case)
          call instr_goto_row
;Must point to existing row
          ld e,(hl):inc hl
          ld d,(hl):dec hl
          ld a,e:or d:jr nz,.ok
          ex de,hl
.ok
          call instr_goto_last_row
          ld (hl),e:inc hl
          set 7,d       ; marker loop 
          ld (hl),d
          ret

instr_get_loop
;-------------
; Get at which row the instr loops
; (for ui, salo, compile)
; IN:  Instrument selected
;OUT:  If loop, Carry  b: dest row 
    ;  Otherwise, NC, b trashed
    ;  HL, DE preserved

          push de:push hl
          call instr_goto_last_row
          ld e,(hl):inc hl
          ld d,(hl)
          res 7,d       ; de = loop pnt

; Iter all rows to convert pnt to loop pnt
          call get_instr_pnt
          instr_head_rows ** inc hl
          ld b,0
.lp
          call ld_hl_link
          jr z,.noloop
          or a:sbc hl,de:add hl,de
          jr z,.loop_met ; will trigger Carry
          inc b
          jr .lp
.noloop
          scf           ; will be canceled by ccf
.loop_met
          ccf
          pop hl:pop de
          ret

get_instr_rows
;-------------
; Get pnt to first row  (or Z if no such row)
          call get_instr_pnt
          instr_head_rows ** inc hl
;enchaine
ld_hl_link
; Read link and check it is in bank (if not null)
; IN:  Instrument selecet
    ;  HL points on link field
; Out: HL = (HL)
     ; Z iff de = 0
     ; A, BC, DE preserved
          push de
          call ld_de_link
          ex de,hl
          pop de
          ret

ld_de_link
; Read link and check it is in bank (if not null)
; IN:  HL points on link field
; Out: DE = (HL)
     ; Z iff de = 0
     ; A, BC, HL preserved
          ld e,(hl):inc hl
          ld d,(hl):dec hl
          res 7,d       ; remove loop flag
          inc d:dec d
      IF dev_checks
          ret z
          push af
          ld a,d:cp &40:call c,mess
          cp &7F:call nc,mess
          pop af
      END
          ret

instr_append_row
;---------------
; In: hl: row data
    ;  a= input row size (without link)
; Out: hl: past row source (hl += a)
     ; de: past row dest (connected)
    ; a, bc preversed
          CHECK_SFX()
instr_append_row_       ; <- access when partial row input
          call instr_append_empty_row
      IF dev_checks
          push af
          ld a,d
          cp instr_pool/&0100:call c,mess
          cp instr_pool_/&0100:call nc,mess
          pop af
      END
          row_link ** inc de
          push bc
          ld c,a
          ld b,0
          ldir
          pop bc
          ret

instr_append_empty_row
;---------------------
; In: N/A
; Out: de: row pnt in bank
    ; a, bc, hl, preversed
          push af:push bc
;No dynamic size, since only 1 type of instrument,
;and instr.o/instrui.o expect static fields for replay/editing (resp.)
          ld a,instr_row_size_max
          call allocate_new_row
          push hl
          call instr_goto_last_row
      IF dev_checks
;link can be in row itself or instr header
          ld a,h
          cp tables/&0100:call c,fail
          cp instr_idx_/&0100:call nc,fail
      END
          ld (hl),e:inc hl
          ld (hl),d
          pop hl
          pop bc:pop af
          ret

instr_set_rows#
;--------------
; Create A* empty rows (used by salo)
; In: B = nb rows
          call _prelude
      IF dev_checks
; For now just used by salo: we assume there is no rows already there
; Check this assumption
          push bc
          call instr_get_rows#
          inc c:dec c:call nz,unexpected
          pop bc
      END
.rowlp
          call instr_append_empty_row
          djnz .rowlp
          jp _postlude

row_null
; Flags=0 (e.g. noise and channel open).
; Nevermind as it is immediatly fixed in salo via set_flags.
      FILL instr_row_size_max,0

instr_goto_last_row
instr_get_rows#         ; same routine
;------------------ 
;In: Instr selected.                 
;Out: C = number of rows#
    ; HL= points to null link or last row.
          ld bc,&FF00   ; c = row counter
instr_goto_row
;------------- 
; Goto to link to desired row (stops at loop or null link)
; In: instr selected
    ; b = row#
;Out: hl= points either: 
            ; to link to next row  
            ; to null link         
    ; A preserved
; E.g., for b=0  hl=  instr_head_rows  (e.g link field of header)
          ; b=1  hl= (instr_head_rows) (e.g link field of row 0)

          push af
          call get_instr_pnt
          instr_head_rows ** inc hl
          push de
          inc b
          call .entry
          pop de
          pop af
          ret

.lp
          ld e,(hl):inc hl
          ld d,(hl):dec hl
; If link=0, stay here.
          ld a,e:or d:ret z
; Don't follow loop. Loop means we are at last row anyway.
          bit 7,d:ret nz
          inc c         ; row_counter
      IF dev_checks
          ld a,d
          cp tables/&0100:call c,mess
          cp tables_/&0100:call nc,mess
      END
          ex de,hl
.entry
          djnz .lp
          ret

set_arps
          ld bc,[instr_arp+idsz] *&0100 + 1
          jr set_column
set_pitchs
          ld bc,[instr_pitch+idsz] *&0100 + 2
          jr set_column
set_flags
          ld bc,[instr_flags+idsz] *&0100 + 1
          jr set_column
set_vols
          ld bc,[instr_vol+idsz] *&0100 + 1
          jr set_column
set_noises
          ld bc,[instr_noise+idsz] *&0100 + 1
          jr set_column
set_hard_envs
          ld bc,[instr_hard_arp+idsz] *&0100 + 3
;enchaine
set_column
; Set whole column in instrument
; Nb rows must have been set beforehand (instr_set_rows#)
; In:hl=source
    ; b=offset (field)
    ; c=width (1 to 3 bytes)
          ex de,hl
          call _prelude
          call get_instr_rows
          jr z,.okrows  ; Ease salo's code when no rows.
          ld a,b
.rowlp
          push hl
          push bc
          push af
          add l:ld l,a:jr nc,$+3:inc h
      IF dev_checks
          inc c:dec c:call nz,unexpected
      END
.copy     ld a,(de):inc de
          ld (hl),a:inc hl
          dec c
          jr nz,.copy
          pop af
          pop bc
          pop hl
          call is_last_row
          jr z,okrows
          call ld_hl_link
          jr .rowlp

.okrows
          jp _postlude

get_arps
          ld bc,[instr_arp+idsz] *&0100 + 1
          jr get_column
get_pitchs
          ld bc,[instr_pitch+idsz] *&0100 + 2
          jr get_column
get_flags
          ld bc,[instr_flags+idsz] *&0100 + 1
          jr get_column
get_vols
          ld bc,[instr_vol+idsz] *&0100 + 1
          jr get_column
get_noises
          ld bc,[instr_noise+idsz] *&0100 + 1
          jr get_column
get_hard_envs
          ld bc,[instr_hard_arp+idsz] *&0100 + 3
;enchaine
get_column
; Set whole column in instrument
; Nb rows must have been set beforehand (instr_set_rows#)
; In:hl=dest
    ; b=offset (field)
    ; c=width (1 to 3 bytes)
;Out: a=nb rows# (for convenient)
    ;hl preserved
          ex de,hl
          call _prelude
          call get_instr_rows
          jr z,.okrows
          ld a,b
.rowlp
          push hl
          push bc
          push af
          add l:ld l,a:jr nc,$+3:inc h
      IF dev_checks
          inc c:dec c:call z,unexpected
      END
.copy     ld a,(hl):inc hl
          ld (de),a:inc de
          dec c
          jr nz,.copy
          pop af
          pop bc
          pop hl
          call is_last_row
          jr z,.okrows
          call ld_hl_link
          jr rowlp
.okrows
          call instr_get_rows#
          ld a,c
          jp _postlude


is_last_row
; Also used by compile and salo
      IF need_room
 ; iterator + call back instead
      END
;in: hl: link (assumbe MSB <> 0)            
;Return Z if yes (00=end or bit7=loop)
     ; All regs but F preserved.
          push bc:ld b,a
          inc hl:ld a,(hl):dec hl
          or a
          jr z,.okz
          add a:sbc a:inc a ; Z iif bit7=1
.okz
          ld a,b:pop bc
          ret

get_instr_pnt
; In: N/A (just instr selected)
;Out:HL = header instr
    ; A preserved
          ld hl,(va_current_instr) ; for l
_get_instr_pnt
      IF instr_head_size-8
 !! review this
      END
      IF instr_idx AND &07FF
 !! review this
      END
          ld h,instr_idx / &0800
          3 ** add hl,hl
          ret

      IF 0
song_clone_instr
;--------------
;in: A source instr
;out: A new instr

;TODO: what if error ?                 
          push hl:push de:push bc
          call Song_select_instr
          ld hl,(va_instr_pnt)
          push hl
          call song_select_new_instr
          pop hl
          ld de,(va_instr_pnt)
          ld c,(hl):sl1 c:call z,&BE00
          ld b,0
          ldir

 ; !! use bk connected by previous routines
          ld a,(va_current_instr)
          pop bc:pop de:pop hl
          ret


instr_get_table_com
;------------------
; in: bc= wanted fx
;out: hl= associated table

          ld hl,(va_instr_pnt)
          ld a,l:or h:call z,err_no_instr
          ld a,(hl)     ;nb word
          inc hl
      IF dev_checks
          or a:call z,&BE00
      END

          ld ixl,a
igtc_lp
          call instr_get_fx_and_signi
; searched fx?
          ex de,hl:or a:sbc hl,bc:ex de,hl
          scf
          jr z,igtc_ok

igtc_skip
;00: no more param
;01: unused
;10: word
;11: table
          or a:jr z,igtc_skip_
          2 ** inc hl
          2 ** srl a
          dec ixl
      IF dev_checks
          call z,&BE00  ; sign must be consistent with nb words
      END
          jr igtc_skip

igtc_skip_
          dec ixl       ; word associated to adr

          jr nz,igtc_lp

          xor a         ; for NC
          ld l,a:ld h,a

igtc_ok
          call c,get_param
          pop bc        ;discard push hl
          jp _postlude_


param_offset = 5
  ; Pos of fx signature (for digging, cf instr_get_table_com)
  ;   (skip jp init_fx and signature)

instr_get_fx_and_signi
          ld e,(hl):inc hl
          ld d,(hl):inc hl
          push de
          ld a,e:sub param_offset:ld e,a
          ld a,(de)
          pop de
          ret

instr_get_signi
; out: adr *non consumed*
          push de
          ld e,(hl):inc hl
          ld d,(hl):dec hl
          ld a,e:sub param_offset:ld e,a
          ld a,(de)
          pop de
          ret

      END

get_fx_sign
; here we already point to fx_init
; out: hl+=2 (addr fx consumed)

          push de
          ld e,(hl):inc hl
          ld d,(hl):inc hl
          dec e

      IF dev_checks
;Player (and then fxs) out of bank.
          ld a,d:cp &40:call nc,mess
      END
          ld a,(de)
          pop de
          ret

get_param
          ld a,(hl):inc hl
          ld h,(hl):ld l,a
          ret

allocate_new_row
;...............
; Actually allocate + setup
; In:  A = size to reserve (without link)
;Out: DE = pointer
    ; Other registers preserved
      IF dev_checks
; !!! for now only full ayane row supported,
; !!! since we set instr_flags and fx0_type
          cp instr_row_size_max:call nz,fail
      END
          push af
          row_link ** inc a
          call allocate
          push de
          push hl
;reset link and fields   
          ld l,e
          ld h,d
.raz      ld (hl),0:inc hl:dec a:jr nz,.raz
; Sane default: noise off, channel on
          ld hl,instr_flags + row_link:add hl,de
          ld (hl),&38
; Fx are actual routine address, and must finish by fx_end.
          ld de,fx0_type-instr_flags:add hl,de
          ld (hl),fx_null AND &FF:inc hl
          ld (hl),fx_null / &0100
          ld de,instr_fx_size-1:add hl,de
          ld (hl),fx_null AND &FF:inc hl
          ld (hl),fx_null / &0100
          ld de,instr_fx_size-1:add hl,de
          ld (hl),fx_end AND &FF:inc hl
          ld (hl),fx_end / &0100
          pop hl
          pop de
          pop af
          ret

allocate
;.......
; For now, append only without mecanism to free memory        
; In:  A = size to reserve (without link)
;Out: DE = pointer
    ; A, HL preserved
          or a:call z,unexpected
          push hl
          ld de,(va_free_pnt)
          ld l,a:ld h,0:add hl,de
          push bc
          ld bc,tables_
          or a:sbc hl,bc:add hl,bc:call nc,memory_full
          pop bc
          ld (va_free_pnt),hl
          pop hl
          ret

Setup_row_r7
;-----------
; Adhoc for chipn: setup r7 according to noise value in raw table
; In: hl: table of rows (!!contiguous)
    ;  b: nb rows
          ld de,instr_flags
          add hl,de
          ex de,hl
          ld hl,instr_noise-instr_flags
          add hl,de
          ld ixl,b
          ld bc,instr_row_size_max
.lp
          ld a,(hl):or a
          ld a,&38      ; just channel open
          jr z,.oknoise
          xor a         ; everything open
.oknoise
          ld (de),a
          add hl,bc:ex de,hl
          add hl,bc:ex de,hl
          dec ixl
          jr nz,.lp
          ret

set_new_arpg
;........... 
;in: BC= table arpg in ram. (might be 0 --why???)
          call _prelude ; connection to bank not needed
          ld hl,va_arpgs#
          ld a,(hl)
          add a
          call c,memory_full
          inc (hl)
          ld l,a
          ld h,arpg_idx/&0100
          ld (hl),c:inc l
          ld (hl),b
          jp _postlude


get_arpg_from_index
;..................
;In: C=arpg idx
   ; base bk connected
          sla c:call c,err_invalid_arpg
          ld l,c
          ld h,arpg_idx/&0100
          ld c,(hl):inc l
          ld b,(hl)
          ret

      IF st
; TODO: reactivate for st128
create_arpeggio_0xy
;-------------------
;in: A= valeurs arpege 0 X Y   ;TODO: C instead?
;out: A= index table arpegio 

          call _prelude

          ld hl,buf_tmp
          push hl
          ld (hl),type_table_byte:inc l
          ld (hl),3:inc l
          ld (hl),3:inc l
          ld (hl),0:inc l
          ld b,a:and &0F
          ld c,a:xor b
          4 ** rrca
          ld (hl),a:inc l
          ld (hl),c

          pop hl
          call register_table
          call set_new_arpg ; TODO:what if mem full ?

          call check_bk_base
          ld a,(va_arpgs#) ; current arpg+1
          dec a
          jp _postlude

_new_table
; - Store passed array in bank.

;  in: HL: Data to copy.  (including header)
     ;  C: Length to copy (including header)
     ; Base bk connected
; out: Table added in stored_table_idx
     ; HL: Post data (HL+C)
     ;  A: Idx table

; Not meant to be used externally.
; Use register_table & higher level routines (st_make_table_byte...)
     ;     call _prelude
     ;     push af

;-- Store in bank 
          push ix
          push hl
          push bc
          call check_bk_base
          ld de,(stored_table_back)
          ld b,e
          ld ix,new_chunk_ext
          call append_raw_in_chunk:call nc,memory_full
          call connect_bk_base
          ld (stored_table_back),hl
;-- Update index
          ld hl,va_table#
          ld a,(hl):inc (hl)
          call _get_stored_idx
          ld (hl),e:inc hl
          ld (hl),d:inc hl
          ld (hl),b
          pop bc
          pop hl
          ld b,0:add hl,bc
          pop ix
          ret


_linked_copy_byte
; In: HL: source
    ; DE: dest
    ;  B: size
          push hl
          push bc
scp_lp
          ld a,e:inc a
          ld (de),a:inc e ;link
          ld a,(hl):inc hl
          ld (de),a:inc e ;value        
          djnz scp_lp

          pop bc
          pop hl
          ret

_linked_copy_word
          push bc:push hl
stcp2_lp
          ld a,e:inc a:ld (de),a:inc e ;link
          ld a,(hl):inc hl:ld (de),a:inc e ; LSB value        
          ld a,(hl):inc hl:ld (de),a:inc e ; MSB value        
          djnz stcp2_lp

          pop hl:pop bc
          ret
      END

new_chunk_ext
;------------
; Like new_phrase_chunk, but no phrase header needed or desirable:
; it wouldn't make sense, as it is just an extension of the phrase.
; Also: Out:  A= chunk start (needed by insert_in_chunk)

      IF dev_checks
; Assume bk phrase already connected
          call get_bk_connected
          cp BK_PHRASE:call nz,mess
      END

          call New_chunk
          ret nc
          call _install_ext
          ld a,chunk_start ; in const.i (shared with ply)
          ret

_install_ext
      IF makeroom
; Can be factorized by
; 1/ encoding size with chunk_def itself
; 2/ just passing LSB of chunk_def
      END
          push hl
          push de
          push bc
          ld a,l        ; bk for loop
          ld d,h
          ld hl,chunk_def
          ld bc,chunk_def_
;enchaine
_install_com
;header
          ld e,chead_last
          ldir
          ex de,hl
; We put link to start of chunk
; It will be copy if phrase takes more chunks,
; making looping easier
; NOTE1: lsb already set
; NOTE2: overwritten when linking to new chunk 
       ; (insert_new_chunk_from_id)
      IF phrases_across_banks
 !!! review that. Use word for id, fx_set_phrase would have to force
   ; L = phrase_start
      END
          ld (hl),h
      IF todo
; Why?
      END
          ld a,l:inc a
          pop bc
          pop de
          pop hl
          scf
          ret


err_invalid_arpg
      BRK
assert_fail
      BRK
err_invalid_ins
      BRK
err_no_instr
      BRK


_prelude
; save registers and sp (for 'exception mechanisme)
; then connect work bank
; More space-efficient, we don't need to be fast

          push de:push ix:push hl
          ld hl,6:add hl,sp
          push af
          ld a,&C3:ld (jp_ret),a ; done each time, nevermind
          ld a,(hl):ld (jp_ret+1),a:ld (hl),c:inc hl
          ld a,(hl):ld (jp_ret+2),a:ld (hl),b:inc hl
          ld (va_savesp),hl
          pop af
          pop hl
          push hl
          call connect_bk_base
          jp jp_ret

;-------------------------------------------
      IF st
st_make_table
; in: hl =source     (must be connected)
    ; a  =longueur
    ; b  =repeat pos (and flag unused here)
    ; c  =repeat length
; out: bc=address table in ram (to be plugged with fx)
     ; hl=source+longueur (post table)
     ; de trashed

          ld e,c
          ld d,type_table_byte
          jr _st_table_com


st_make_table_word      ;copy/paste word 16 bits value
;-----------------
; in: hl =source
    ; a  =longueur  (en mots !)
    ; b  =repeat pos
    ; c  =repeat length
; out: bc=new table start
     ; hl=source+longueur  

;convert ticks -> bytes
          add a
          sla b
          ld e,c
          sla e
          ld d,type_table_word
;enchaine
_st_table_com
; Here a=length in bytes  
     ; b=start loop in bytes
     ; e=loop len in bytes
     ; d=type    
          or a:call z,unexpected
          bit 7,b:call nz,unexpected ;TODO: handle flag

;Create header, and copy data + loop
;TODO: Optimize if loop reaches end

          push hl
          ld hl,buf_tmp
          ld (hl),d:inc l
          add e:call c,unexpected ; length + loop > 256
          ld (hl),a:inc l ; size with loop due to hack
          sub e         ; size to copy (no loop)
          ld (hl),c:inc l
          ld c,e
          ex de,hl
          pop hl
          push bc
          ld c,a:ld b,0
          ldir
          pop bc
          push hl       ; post table for caller

          inc c:dec c:jr z,_st_noloop
          ld l,b        ; start loop 
          table_header_size ** inc l ; in buffer
          ld h,d
          ld b,0
          ldir
_st_noloop
          ld hl,buf_tmp
          call register_table
          pop hl
          ret

register_table_from_bank
; Like register table, when source is from bank
          ld a,h:cp buf_tmp/&0100:call nz,unexpected ; sanity check
          call _table_full_len
          ld de,buf_tmp
          push de
          ldir
          ex (sp),hl
          call register_table
          pop hl
          ret

register_table
; - Store table in bank
; - Create ram version
; in:  hl = table header !! OUT OF BANK !!
; out: hl = post table
;    ; bc = address table in ram (to be plugged with fx)
     ; a, de trashed

          or a:call z,to_be_implemented ; Don't support empty table yet.
!!! review this
          call connect_bk_base ; why not _prelude?
          call _table_full_len
          call _new_table
          push hl
      BRK

_table_full_len
; In:  hl=table header
; out: bc=len
     ; a trashed
          inc hl:ld a,(hl):dec hl
          add table_header_size:call c,unexpected
          ld c,a:ld b,0
          ret
      END

;-------------------------------------------

chunk
; NB: insertion itself rewritten with this behavior:
    ; when no room, put tail in *new* chunk (doesn't try to merge)
    ; when no room even for bytes to insert,
    ;  put them in this same new chunk.  
    ; ??TODO: factorize?

; !! Customized for phrases (cf end tag EOP)

chunk_def
;--------
;Standard chunk without phrase header.
;Used for tables? and phrases continuation (hence tag_end, which will
;be overwritten for tables)
      BYTE chunk_def_+3 ;+2: next field. +2-1: word for phrase_end
      BYTE 0            ;checksum (unused now)
      BYTE 0            ; row# (mimic line# in orgams's chunk)
      IF $ - chunk_def + 2 - chunk_start ;2: next field
  !! inconsistency. check const.i
      END
; ROW sentinel: makes sense for phrases cont, not table
; duration 0 = tag eof of phrase
      IF todo
 ; check with ply.empty_phrase which also use 0
      END
      BYTE 0
      BYTE mask_fx0
      BYTE fx_set_phrase AND &FF
chunk_def_ = $ - chunk_def


; ----------------------------
vars
; Private vars alongside code

va_savesp WORD 

jp_ret    3 ** BYTE 


dbg1  WORD 
dbg2  WORD 

; ----------------------------       
; Vars in bank
      IF todo
; Move that out of bank:
   ; - easier access
   ; - free room for chunks
   ; - uniformity
; !!! Note applicable for persistent variables.
      END

save_pc = $

def
; Doesn't use org va,$$
; otherwise orgams set high $ = 7cxx, which is inconvenient
      BYTE "Aya!",0     ; sign: For sanity checks (unused for now)
      WORD tables       ; va_free_nt: pnt in free zone
def_size = $-def

      ORG va_chung
var
sign  SKIP 5
va_free_pnt WORD 

      IF $-var - def_size
 !! inconsistency
      END

zero_start              ; Not loaded, must follow def (see check below)
      IF zero_start - [var+def_size]
 !! must be contiguous to simplify init code
      END
va_current_instr BYTE 
va_arpgs# BYTE 
va_table# BYTE 
selected_row WORD 

zero_size = $-zero_start

; ---- Must be zeroed at ayane init, but not song reset ----

zero_chung
stored_table_start WORD  ; chunk id. Needed for free (unused now)
zero_chung_ = $-zero_chung

; ----
stored_table_back WORD  ; ID of last chunk for append_raw_in_chunk


      ORG buf_chung

arpg_idx SKIP &0100     ; &80 words: &100.
buf_tmp SKIP &0100      ; Out of bank exchange buffer

      SKIP buf_chung_ - $ ; poor's man limit (defined in memmap.i)

      ORG save_pc       ; for host
; Align, for more stable addresses
; -> ease debugging
; -> less re-assembling when we change just one module
      SKIP -$ AND &FF




