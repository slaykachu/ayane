; <<<<< chung: gestion chunk? + instr >>>>>
; 2025     
 ; -- alpha 1 --
  ; Nov 26. Move Song_get_instr to song
      ; 16. Move new_chunk_ext to phrase (remove dep)
          ; Remove dependency on ply
 ; -- v0aq --
  ; Sep 28. Split set_hard_envs set_hard_type / _arp / ...
              ; Rationale: Will allow type by column (const, tab...)
          ; Add set_fx0_type/get_fx0_type and co
dev_checks' = 1         ; forced for now
todo  = 1
todo_later = 1          ; non urgent/critical todo
makeroom = 1

row_link = 2

      MACRO PAD
      FILL -$ AND &1F,&F7
      ENDM

      IMPORT "const.i"
      IMPORT "memmap.i"
      IMPORT "macro.i"
      IMPORT "plyconf.i" ; for nb_fx and use_instr_chip_down_vib (tmp)

      IMPORT "instr.o"  ; Use LSB as type.
      IMPORT "timer.o"  ; fx_null/fx_end/sync_buzzer_register
      IMPORT "heap.o"   ; new_heap_chunk
      IMPORT "chunk.o"  ; new_chunk 
      IMPORT "song.o"   ; Song_get_instr
      IMPORT "memcpc.o"

      IF 0
;Doesn't need JPs for now

; Setup ---------------
          jp Init_chung

; Instr creation ------
          jp New_instr
          jp New_instr_ayane
    ; New_instr_ayane
    ; New_instr_chp_down_vib
    ; New_instr_chp_down_vib_noise
    ; New_instr_chp_down_arp
    ; New_instr_chp_down_arp_noise
          15 ** BRK
          jp Song_select_instr
          jp Song_get_instr
          jp instr_does_exist ; instrsel
; Instr edition for instrui ----

          jp instr_get_rows#
          jp instr_set_rows#
          jp instr_set_loop
          jp instr_get_loop
          jp instr_remove_loop
          jp set_flags
          jp instr_ayane_append_rows

          jp insert_empty_row
          jp instr_append_empty_row
          jp del_row
          jp select_row
          jp get_row
          jp set_row

; --- Helper (salo / compile) ------
          jp is_last_row
          jp Setup_row_r7
      END

; !!!! TODO? [Optim]: to save bk connection for fx signature,
                    ; we might compile (or copy) player out of bank
             ;---> UNEEDED when player intool (rom) as well

; !!!! Scheis !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
; !!!!!! What the heck with fx interface
; !!!!!!   - Already init in instr vs direct jump
; !!!!!!   - How to enforce that?
; interface!!!  some routine needs a call to _prelude beforehanb !!!!!!
;               -> how can we know?

      IF nb_fx:ELSE
!!! We must have at least 1 fx (set ayane=1)
  ; to be able to handle fx_set_phrase
  ; Needed for 'goto next chunk' and 'goto start of phrase'
; For compile, it needs to be dynamic anyway.
; E.G.  : nb_fx = 4 for in-tool
  ; If a particular music doesn't use fx, then we remove handling
  ; dynamically.
      END

;==============================================
      MACRO EXPECT_EQUAL x,y
      IF x-y
   !! should be equal
      END
      ENDM

      MACRO INIT_LENGTH
      IF todo
; rename s/lenght/duration (or better term)
      END
      IF pos_flags - 1
 !! a revoir
      END
          ld (hl),a:inc l
      ENDM

      MACRO SKIP_LENGTH
          pos_flags ** inc l
      ENDM

      MACRO SKIP_LENGTH_DE
          pos_flags ** inc e
      ENDM

      MACRO CP_COPY_LENGTH
          pos_flags ** call cp_copy
      ENDM

      MACRO SKIP_RESERVED
          reserved_byte ** inc l
      ENDM

      MACRO CHECK_INSTR_PNT
      IF dev_checks'
          call _check_instr_pnt
      END
      ENDM

      MACRO CHECK_INSTR_SETUP
      IF dev_checks'
          call _check_instr_setup
      END
      ENDM


      MACRO CHECK_SFX
;Check sfx fields n**sync_buzzer, then sfx null
;In: HL= start row instr
      IF dev_checks'
          call _check_sfx
      END
      ENDM

      MACRO CHECK_SFX_DE
;Check sfx fields n**sync_buzzer, then sfx null
;In: HL= start row instr
      IF dev_checks'
          ex de,hl
          call _check_sfx
          ex de,hl
      END
      ENDM


;==============================================
fatal = &BE00           ; TODO: replace by warning mecanism.
memory_full = fatal
mess  = &BE00
unexpected = &BE00
to_be_implemented
          call &BE00
;implement/handle me
          ret

      IF dev_checks'
_check_instr_pnt
          push de
          ld de,tables:or a:sbc hl,de:add hl,de:call c,fail
          ld de,tables_:or a:sbc hl,de:add hl,de:call nc,fail
          pop de
          ret

_check_instr_setup
; instr must have been created
          push af:push hl
          call get_instr_pnt
;For now, just one type of instr
          ld a,(hl):cp instr_default AND &FF
          call nz,fail
          pop hl:pop af
          ret

_check_sfx
; Check 2 fx (possibly fx_null) and then fx_end
          push af:push bc:push hl
          ld bc,fx0_type
          add hl,bc
          ld a,MAX_FX_BY_INSTR
.lp
          push hl
          ld c,(hl):inc hl
          ld b,(hl)
          ld hl,fx_null:or a:sbc hl,bc:jr z,.ok
          ld hl,sync_buzzer_register:or a:sbc hl,bc:jr z,.ok
; for now just one type of fx possible. If not sync_buzzer, break
          call fail
.ok
          pop hl
          ld bc,instr_fx_size
          add hl,bc
          dec a
          jr nz,.lp

          ld c,(hl):inc hl
          ld b,(hl)
          ld hl,fx_end:or a:sbc hl,bc:call nz,fail

          pop hl:pop bc:pop af
          ret
      END

  ; =====================================
  ; ------ song interface ---------------
  ; =====================================

  ; all register expect A preserved

Init_chung
; in:  N/A     
          call Init_chunk_module
          call connect_bk_base
          ld hl,zero_chung
          ld de,zero_chung+1
          ld bc,zero_chung_-1
          ld (hl),0
          ldir

;enchaine
song_reset_chung
;---------------
; Part of song handled here (instr, arp, ...)
          call connect_bk_base

          ld hl,def:ld de,var:ld bc,def_size:ldir ; non-zero vars
          ex de,hl
          ld b,zero_size:xor a:call fillb

; instr_head_type = 0 marks absence of instr
; Needed to be able to pick non-contiguous instruments.
          ld hl,instr_idx
          ld de,instr_idx+1
          ld bc,instr_head_size*&0100 - 1
          ld (hl),0
          ldir

      IF todo
;TODO: free stored_table_start before hand
; !!!    memory leak
      END
; Note: can't reuse new_chunk_ext, as it put a sentinel with current
      ; track for auto-loop.
  ;- No current_track at this point! (would trigger all kind of asserts)
  ;- Wouldn't make sense for table anyway.
          call New_heap_chunk
          ret nc
          call connect_bk_base
          ld (stored_table_start),hl
          ld (stored_table_back),hl ; for l = bk
          ret           ; Carry

fill      ld (hl),a:inc l:jr nz,fill
          ret
fillb     ld (hl),a:inc hl:djnz fillb
          ret

instr_does_exist
;---------------
;Reselect currect instrument, just for flag!
          call Song_get_instr
;enchaine
Song_select_instr
;----------------
; In: A: inst number (from 1. 0 reserved)
    ; Note: 0 can happen when empty module (salo-nrt)
; Out: If instr exist, NZ, A = Id type instrument (for SALO) 
                         ; H = Param size (cf instr.SIGN)
                         ; L = Size row   (idem)
                     ; Z otherwise, A, HL trashed    
     ; In any case H trashed
     ; Instr selected (even in non existent)

          call _prelude
_select_instr
          ld (va_current_instr),a
          call get_instr_pnt
          ld a,(hl):or a ; Instr type <> 0? 
          ld l,a
          ld h,instr_code/&0100
          dec hl:ld a,(hl)
          dec hl:ld d,(hl)
          dec hl:ld e,(hl)
          ex de,hl
          scf
          pop de        ; stack correction
          jp _postlude_

New_instr
; Generic builder for loading and ui
; in: A= ID
    ; B= instr type 
    ; C= params# 
    ;HL= params
;Out: A= row size
          EXPECT_EQUAL(type_instr_null,0)
          EXPECT_EQUAL(type_instr_mute,1)
          EXPECT_EQUAL(type_instr_default,2)
          inc b:dec b:call z,to_be_implemented
          dec b:call z,to_be_implemented
          dec b:jr z,.default
          call unexpected

.default
; for now, expect 0 params 
          inc c:dec c:call nz,unexpected
;enchaine
New_instr_ayane
          ld e,instr_default AND &FF
;enchaine
_select_new_instr
; create new empty instr, and select it.
; In:  A = Id
    ;  E = type 
; Out: Carry if ok, instr selected
     ; NC otherwise (memory full) 
     ; A/L like Song_select_instr
          call _prelude
      IF dev_checks'
          or a:call z,unexpected ; 0 reserved (for mute?)
      END
          ld l,a
          call _get_instr_pnt
          instr_head_type ** inc hl
          ld (hl),e
          instr_head_rows - instr_head_type ** inc hl
; reset table and params (00 used as default)
          ld b,instr_head_size - instr_head_rows
.raz      ld (hl),0:inc hl:djnz .raz
          jp _select_instr

      IF use_instr_chip_down_vib
;Temp hack to fit all instr in &100
      IF todo
;Anyway: should just have one version with noise
       ; -> pick/build the right routine at compile time 
          ; if noise never used
      END
New_instr_chp_down_vib
;---------------------
; Create ad-hoc instr reproducing chipnsfx intsrument with
    ; - Volume going down
    ; - No noise
    ; - Vibrato
; In  A = ID
   ;  b = initial volume (8 bits)
   ;  c = step volume to be substracted (8 bits) 
          ld e,instr_chip_down_vib AND &FF
      END
_new_instr_chp
; use generic routine to gain space
          ld d,c:ld c,b
          ld b,0        ; 3rd param: unused 
          jr New_instr_chp

      IF use_instr_chip_down_arp
New_instr_chp_down_arp
;---------------------
; Create ad-hoc instr reproducing chipnsfx intsrument with
    ; - Volume going down
    ; - No noise
    ; - Arpegio
; In  a = ID
   ;  b = initial volume (8 bits)
   ;  c = step volume to be substracted (8 bits) 
          ld e,instr_chip_down_arp AND &FF
          jr _new_instr_chp
      END

      IF use_instr_chip_down_vib_noise
New_instr_chp_down_vib_noise
;---------------------------
; Create ad-hoc instr reproducing chipnsfx intsrument with
    ; - Volume going down
    ; - Constant noise (can be off = 0)
    ; - Vibrato
; In  a = ID
   ;  b = initial volume (8 bits)
   ;  c = step volume to be substracted (8 bits) 
   ;  d = noise (set first)
          ld e,instr_chip_down_vib_noise AND &FF
          jr New_instr_chp
      END

      IF use_instr_chip_down_arp_noise
New_instr_chp_down_arp_noise
;---------------------------
; Create ad-hoc instr reproducing chipnsfx intsrument with
    ; - Volume going down
    ; - Constant noise (can be off = 0)
    ; - Arpegio
; In  a = id
   ;  b = initial volume (8 bits)
   ;  c = step volume to be substracted (8 bits) 
   ;  d = noise (set first)
          ld e,instr_chip_down_arp_noise AND &FF
      END
New_instr_chp
          call _select_new_instr
          call get_instr_pnt
          instr_head_ext ** inc hl
          ld (hl),d:inc hl
          ld (hl),c:inc hl
          ld (hl),b
          ret

instr_ayane_append_rows
;----------------------
; Ayane's version: full row.
; Only used by chipn.

          call _prelude
.rowlp
          ld a,instr_row_size_max
          call instr_append_row_
; --- when 0 is passed as fx, must be replaced by fx_end
; (as we jump to the address. well there is an assert in instr.o to
  ;check it is a proper address)
; !!! for now, fx_null + fx_null + fx_end is expected
; !!! rather than just fx_end (c.f. CHECK_SFX)
; !!! Doesn't matter yet since whole size is allocated anyway
      IF todo_later
; just put fx_end if no fx, and fx_null if fx only in 2nd slot
      END
          push hl
          ld hl,fx0_type-instr_row_size_max:add hl,de
          ld (hl),fx_null AND &FF:inc hl
          ld (hl),fx_null / &0100
          ld de,instr_fx_size-1:add hl,de
          ld (hl),fx_null AND &FF:inc hl
          ld (hl),fx_null / &0100
          ld de,instr_fx_size-1:add hl,de
          ld (hl),fx_end AND &FF:inc hl
          ld (hl),fx_end / &0100
          pop hl
          djnz .rowlp

          jr _postlude


instr_chip_append_rows_byte
;--------------------------
; chip version: 1 byte per row (e.g. arpegio)
          ld a,1
          jr instr_append_rows

instr_chip_append_rows_word
;--------------------------
; chip version: 1 word per row (e.g. vibrato)
          ld a,2
;enchaine
instr_append_rows
;----------------
; Set all rows in bulk (typically when importing from other tracker)
; In: hl: table with A-sized rows 
    ;  a: row size
    ;  b: nb rows
          call _prelude
.rowlp
          call instr_append_row_
          djnz .rowlp
_postlude
          scf
_postlude_fail
          pop hl
_postlude_
          pop ix:pop de:pop bc
          ret

insert_empty_row
;---------------
; In: A= row# (can't use selected_row as we need to goto previous row)
          push af
          ld b,a
          ld a,instr_row_size_max
          call allocate_new_row
          call instr_goto_row
          ld c,(hl):ld (hl),e:inc hl
          ld b,(hl):ld (hl),d
          ex de,hl
          ld (hl),c:inc hl
          ld (hl),b:inc hl
          ex de,hl
          pop af
;enchaine
select_row
;---------
; In: A= row#
    ; instr selected
          ld b,a
          inc b
          call instr_goto_row
          CHECK_INSTR_PNT()

          row_link ** inc hl
          ld (selected_row),hl
          ret

get_row
;------                  
; Copy row from ayane instrument
; IN: DE: buffer for row data
    ; select_row was called
           ; - simpler for client
           ; - avoid redoing same stuff
          ld hl,(selected_row)
          CHECK_INSTR_PNT()
          CHECK_SFX()
          jr _row_copy

instr_set_row           ; tmp hack to resolve ambiguity
set_row
;------
; Copy row to ayane instrument
; IN: DE: row data
    ; select_row was called (see /get_row/)
          ld hl,(selected_row)
          CHECK_INSTR_PNT()
          ex de,hl
          CHECK_SFX()
_row_copy
          ld bc,instr_row_size_max
          ldir
          ret


del_row
;------
; In: A= row# (same as /insert_empty_row/)

; When loop to suppressed row, link would be dangling.
; We must detect this case
          call instr_get_loop
          push af
          push bc
          ld b,a
          call instr_goto_row
          push hl
          ld e,(hl):inc hl
          ld d,(hl)
      IF todo
; - release memory
; - copy data in work buffer for CONTROL-P
      END
          ex de,hl
          CHECK_INSTR_PNT()
          ld c,(hl):inc hl
          ld b,(hl)
          pop hl
          ld (hl),c:inc hl
          ld (hl),b
; Handle corner case when was pointing to suppressed row
          pop bc
          pop af
          ret nc        ; no loop
          cp b
          ret nz        ; no
; Re-set loop
; Note: if loop was set to last row (now deleted),
      ; loop will be set to new last row.
; If we had 0 -> 1 > 1 + &8000 (loop to 1), deleting line 1 gives:
          ; 0 -> 1 + &8000 (dangling pointer)
; So, remove dangling pointer
          ld a,b
          call instr_goto_last_row
          ld b,a
          xor a
          ld (hl),a:inc hl
          ld (hl),a
;enchaine
instr_set_loop
;-------------
; Set loop link
; In: B: dest row
; If B > last row, clip to last row
; (useful for del_row corner case)
          call instr_goto_row
;Must point to existing row
          ld e,(hl):inc hl
          ld d,(hl):dec hl
          ld a,e:or d:jr nz,.ok
          ex de,hl
.ok
          call instr_goto_last_row
          ld (hl),e:inc hl
          set 7,d       ; marker loop 
          ld (hl),d
          ret

instr_remove_loop
;----------------
          call instr_goto_last_row
          xor a
          ld (hl),a:inc hl
          ld (hl),a
          ret

instr_get_loop
;-------------
; Get at which row the instr loops
; (for ui, salo, compile)
; IN:  Instrument selected
;OUT:  If loop, Carry  b: dest row 
    ;  Otherwise, NC, b trashed
    ;  HL, DE preserved

          push de:push hl
          call instr_goto_last_row
          ld e,(hl):inc hl
          ld d,(hl)
          res 7,d       ; de = loop pnt

; Iter all rows to convert pnt to loop pnt
          call get_instr_pnt
          instr_head_rows ** inc hl
          ld b,0
.lp
          call ld_hl_link
          jr z,.noloop
          or a:sbc hl,de:add hl,de
          jr z,.loop_met ; will trigger Carry
          inc b
          jr .lp
.noloop
          scf           ; will be canceled by ccf
.loop_met
          ccf
          pop hl:pop de
          ret

get_instr_rows
;-------------
; Get pnt to first row  (or Z if no such row)
          call get_instr_pnt
          instr_head_rows ** inc hl
;enchaine
ld_hl_link
; Read link and check it is in bank (if not null)
; IN:  Instrument selecet
    ;  HL points on link field
; Out: HL = (HL)
     ; Z iff de = 0
     ; A, BC, DE preserved
          push de
          call ld_de_link
          ex de,hl
          pop de
          ret

ld_de_link
; Read link and check it is in bank (if not null)
; IN:  HL points on link field
; Out: DE = (HL)
     ; Z iff de = 0
     ; A, BC, HL preserved
          ld e,(hl):inc hl
          ld d,(hl):dec hl
          res 7,d       ; remove loop flag
          inc d:dec d
      IF dev_checks'
          ret z
          push af
          ld a,d:cp &40:call c,mess
          cp &7F:call nc,mess
          pop af
      END
          ret

instr_append_row
;---------------
; In: hl: row data
    ;  a= input row size (without link)
; Out: hl: past row source (hl += a)
     ; de: past row dest (connected)
    ; a, bc preversed
          CHECK_SFX()
instr_append_row_       ; <- access when partial row input
          CHECK_INSTR_SETUP()
          call instr_append_empty_row
      IF dev_checks'
          push af
          ld a,d
          cp instr_pool/&0100:call c,mess
          cp instr_pool_/&0100:call nc,mess
          pop af
      END
          row_link ** inc de
          push bc
          ld c,a
          ld b,0
          ldir
          pop bc
          ret

instr_append_empty_row
;---------------------
; In: N/A
; Out: de: row pnt in bank
    ; a, bc, hl, preversed
          push af:push bc
;No dynamic size, since only 1 type of instrument,
;and instr.o/instrui.o expect static fields for replay/editing (resp.)
          ld a,instr_row_size_max
          call allocate_new_row
          push hl
          call instr_goto_last_row
      IF dev_checks'
;link can be in row itself or instr header
          ld a,h
          cp tables/&0100:call c,fail
          cp instr_idx_/&0100:call nc,fail
      END
          ld (hl),e:inc hl
          ld (hl),d
          pop hl
          pop bc:pop af
          ret

instr_set_rows#
;--------------
; Create A* empty rows (used by salo)
; In: B = nb rows
          call _prelude
          CHECK_INSTR_SETUP()
      IF dev_checks'
; For now just used by salo: we assume there is no rows already there
; Check this assumption
          push bc
          call instr_get_rows#
          inc c:dec c:call nz,unexpected
          pop bc
      END
.rowlp
          call instr_append_empty_row
          djnz .rowlp
          jp _postlude

row_null
; Flags=0 (e.g. noise and channel open).
; Nevermind as it is immediatly fixed in salo via set_flags.
      FILL instr_row_size_max,0

instr_goto_last_row
instr_get_rows#         ; same routine
;------------------ 
;In: Instr selected.                 
;Out: C = number of rows#
    ; HL= points to null link or last row.
          ld bc,&FF00   ; c = row counter
instr_goto_row
;------------- 
; Goto to link to desired row (stops at loop or null link)
; In: instr selected
    ; b = row#
;Out: hl= points either: 
            ; to link to next row  
            ; to null link         
    ; A preserved
; E.g., for b=0  hl=  instr_head_rows  (e.g link field of header)
          ; b=1  hl= (instr_head_rows) (e.g link field of row 0)

          CHECK_INSTR_SETUP()
          push af
          call get_instr_pnt
          instr_head_rows ** inc hl
          push de
          inc b
          call .entry
          pop de
          pop af
          ret

.lp
          ld e,(hl):inc hl
          ld d,(hl):dec hl
; If link=0, stay here.
          ld a,e:or d:ret z
; Don't follow loop. Loop means we are at last row anyway.
          bit 7,d:ret nz
          inc c         ; row_counter
      IF dev_checks'
          ld a,d
          cp tables/&0100:call c,mess
          cp tables_/&0100:call nc,mess
      END
          ex de,hl
.entry
          djnz .lp
          ret

set_arps
          ld bc,[instr_arp+idsz] *&0100 + 1
          jr set_column
set_pitchs
          ld bc,[instr_pitch+idsz] *&0100 + 2
          jr set_column
set_flags
          ld bc,[instr_flags+idsz] *&0100 + 1
          jr set_column
set_vols
          ld bc,[instr_vol+idsz] *&0100 + 1
          jr set_column
set_noises
          ld bc,[instr_noise+idsz] *&0100 + 1
          jr set_column
set_hard_types          ; includes retrig flag
          ld bc,[instr_hard_type+idsz] *&0100 + 1
          jr set_column
set_hard_arps
          ld bc,[instr_hard_arp+idsz] *&0100 + 1
          jr set_column
set_hard_pitchs
          ld bc,[instr_hard_pitch+idsz] *&0100 + 2
          jr set_column
set_fx0_types
          ld b,fx0_type+idsz
_set_column_fx_type
          ld ix,copy_fx_type_to_rout
          jr set_column_custom
set_fx0_params
          ld bc,[fx0_param+idsz] *&0100 + 1
          jr set_column
set_fx0_arps
          ld bc,[fx0_arp+idsz] *&0100 + 1
          jr set_column
set_fx0_pitchs
          ld bc,[fx0_pitch+idsz] *&0100 + 2
          jr set_column
set_fx1_types
          ld b,fx1_type+idsz
          jr _set_column_fx_type
set_fx1_params
          ld bc,[fx1_param+idsz] *&0100 + 1
          jr set_column
set_fx1_arps
          ld bc,[fx1_arp+idsz] *&0100 + 1
          jr set_column
set_fx1_pitchs
          ld bc,[fx1_pitch+idsz] *&0100 + 2
;enchaine
set_column
          ld ix,_copy_to_instr
set_column_custom
; Set whole column in instrument
; Nb rows must have been set beforehand (instr_set_rows#)
; In:hl=source
    ;ix=copy routine
    ; b=offset (field)
    ; c=width (1 to 3 bytes) (when ix=.copy) 
          ex de,hl
          call _prelude
          call _transfer_rows
          jp _postlude

_copy_to_instr
      IF dev_checks'
          inc c:dec c:call z,unexpected
      END
.cplp
          ld a,(de):inc de
          ld (hl),a:inc hl
          dec c
          jr nz,.cplp
          ret

copy_fx_type_to_rout
          ld a,(de):inc de
          call fx_type_to_rout
          ld (hl),c:inc hl
          ld (hl),b
          ret

fx_type_to_rout
; Convert type id to rout address (used by instrui)
; In:   A = type
; Out: BC = rout
          ASSERT(fx_type_none == 0)
          ld bc,fx_null
          or a
          ret z
          ld bc,sync_buzzer_register
      IF dev_checks'
          cp fx_type_sync_buzzer:call nz,unexpected
      END
          ret

copy_fx_rout_to_type
          ld c,(hl):inc hl
          ld b,(hl)
          call fx_rout_to_type
          ld (de),a:inc de
          ret

fx_rout_to_type
; Convert rout to type id (used by instrui)
; In:  BC = rout
; Out:  A = type      

          ASSERT(fx_type_none == 0)
          xor a
          push hl
          ld hl,fx_null:sbc hl,bc
          pop hl
          ret z
          ld a,fx_type_sync_buzzer
      IF dev_checks'
          push hl
          ld hl,sync_buzzer_register:or a:sbc hl,bc:call nz,unexpected
          pop hl
      END
          ret

jp_ix     jp ix

get_arps
          ld bc,[instr_arp+idsz] *&0100 + 1
          jr get_column
get_pitchs
          ld bc,[instr_pitch+idsz] *&0100 + 2
          jr get_column
get_flags
          ld bc,[instr_flags+idsz] *&0100 + 1
          jr get_column
get_vols
          ld bc,[instr_vol+idsz] *&0100 + 1
          jr get_column
get_noises
          ld bc,[instr_noise+idsz] *&0100 + 1
          jr get_column
get_hard_types          ; includes retrig flag
          ld bc,[instr_hard_type+idsz] *&0100 + 1
          jr get_column
get_hard_arps
          ld bc,[instr_hard_arp+idsz] *&0100 + 1
          jr get_column
get_hard_pitchs
          ld bc,[instr_hard_pitch+idsz] *&0100 + 2
          jr get_column
get_fx0_types
          ld b,fx0_type+idsz
_get_column_fx_type
          ld ix,copy_fx_rout_to_type
          jr get_column_custom
get_fx0_params
          ld bc,[fx0_param+idsz] *&0100 + 1
          jr get_column
get_fx0_arps
          ld bc,[fx0_arp+idsz] *&0100 + 1
          jr get_column
get_fx0_pitchs
          ld bc,[fx0_pitch+idsz] *&0100 + 2
          jr get_column
get_fx1_types
          ld b,fx1_type+idsz
          jr _get_column_fx_type
get_fx1_params
          ld bc,[fx1_param+idsz] *&0100 + 1
          jr get_column
get_fx1_arps
          ld bc,[fx1_arp+idsz] *&0100 + 1
          jr get_column
get_fx1_pitchs
          ld bc,[fx1_pitch+idsz] *&0100 + 2
;enchaine
get_column
          ld ix,_copy_from_instr
;enchaine
get_column_custom
; Set whole column in instrument
; Nb rows must have been set beforehand (instr_set_rows#)
; In:hl=dest
    ; b=offset (field)
    ; c=width (1 to 3 bytes)
;Out: a=size (width * rows#)  0 = 256
    ;hl preserved
          call _prelude
          ex de,hl
          push de
          call _transfer_rows
          ld a,e
          pop de
          sub e
          jp _postlude

_copy_from_instr
      IF dev_checks'
          inc c:dec c:call z,unexpected
      END
.cplp
          ld a,(hl):inc hl
          ld (de),a:inc de
          dec c
          jr nz,.cplp
          ret

_transfer_rows
          call get_instr_rows
          ret z         ; Ease salo's code when no rows.
.rowlp
          push hl
          push bc
          ld a,l:add b:ld l,a:jr nc,$+3:inc h
          call jp_ix
          pop bc
          pop hl
          call is_last_row
          ret z
          call ld_hl_link
          jr .rowlp

is_last_row
; Also used by compile and salo
      IF need_room
 ; iterator + call back instead
      END
;in: hl: link (assumbe MSB <> 0)            
;Return Z if yes (00=end or bit7=loop)
     ; All regs but F preserved.
          push bc:ld b,a
          inc hl:ld a,(hl):dec hl
          or a
          jr z,.okz
          add a:sbc a:inc a ; Z iif bit7=1
.okz
          ld a,b:pop bc
          ret

get_instr_pnt
; In: N/A (just instr selected)
;Out:HL = header instr
    ; A preserved
          ld hl,(va_current_instr) ; for l
_get_instr_pnt
      IF instr_head_size-8
 !! review this
      END
      IF instr_idx AND &07FF
 !! review this
      END
          ld h,instr_idx / &0800
          3 ** add hl,hl
          ret


allocate_new_row
;...............
; Actually allocate + setup
; In:  A = size to reserve (without link)
;Out: DE = pointer
    ; Other registers preserved
      IF dev_checks'
; !!! for now only full ayane row supported,
; !!! since we set instr_flags and fx0_type
          cp instr_row_size_max:call nz,fail
      END
          push af
          row_link ** inc a
          call allocate
          push de
          push hl
;reset link and fields   
          ld l,e
          ld h,d
.raz      ld (hl),0:inc hl:dec a:jr nz,.raz
; Sane default: noise off, channel on
          ld hl,instr_flags + row_link:add hl,de
          ld (hl),&38
; Fx are actual routine address, and must finish by fx_end.
          ld de,fx0_type-instr_flags:add hl,de
          ld (hl),fx_null AND &FF:inc hl
          ld (hl),fx_null / &0100
          ld de,instr_fx_size-1:add hl,de
          ld (hl),fx_null AND &FF:inc hl
          ld (hl),fx_null / &0100
          ld de,instr_fx_size-1:add hl,de
          ld (hl),fx_end AND &FF:inc hl
          ld (hl),fx_end / &0100
          pop hl
          pop de
          pop af
          ret

allocate
;.......
; For now, append only without mecanism to free memory        
; In:  A = size to reserve (without link)
;Out: DE = pointer
    ; A, HL preserved
          or a:call z,unexpected
          push hl
          ld de,(va_free_pnt)
          ld l,a:ld h,0:add hl,de
          push bc
          ld bc,tables_
          or a:sbc hl,bc:add hl,bc:call nc,memory_full
          pop bc
          ld (va_free_pnt),hl
          pop hl
          ret

Setup_row_r7
;-----------
; Adhoc for chipn: setup r7 according to noise value in raw table
; In: hl: table of rows (!!contiguous)
    ;  b: nb rows
          ld de,instr_flags
          add hl,de
          ex de,hl
          ld hl,instr_noise-instr_flags
          add hl,de
          ld ixl,b
          ld bc,instr_row_size_max
.lp
          ld a,(hl):or a
          ld a,&38      ; just channel open
          jr z,.oknoise
          xor a         ; everything open
.oknoise
          ld (de),a
          add hl,bc:ex de,hl
          add hl,bc:ex de,hl
          dec ixl
          jr nz,.lp
          ret

err_no_instr
      BRK


_prelude
; !! Must be call top_level
; save registers and sp (for 'exception mechanisme)
; then connect work bank
; More space-efficient, we don't need to be fast

          push de:push ix:push hl
          ld hl,6:add hl,sp
          push af
          ld a,&C3:ld (jp_ret),a ; done each time, nevermind
          ld a,(hl):ld (jp_ret+1),a:ld (hl),c:inc hl
          ld a,(hl):ld (jp_ret+2),a:ld (hl),b:inc hl
          ld (va_savesp),hl
          pop af
          pop hl
          push hl
          call connect_bk_base
          jp jp_ret

; ----------------------------
vars
; Private vars alongside code

va_savesp WORD 

jp_ret    3 ** BYTE 


dbg1  WORD 
dbg2  WORD 

; ----------------------------       
; Vars in bank
      IF todo
; Move that out of bank:
   ; - easier access
   ; - free room for chunks
   ; - uniformity
; !!! Note applicable for persistent variables.
      END

save_pc = $

def
; Doesn't use org va,$$
; otherwise orgams set high $ = 7cxx, which is inconvenient
      BYTE "Aya!",0     ; sign: For sanity checks (unused for now)
      WORD tables       ; va_free_nt: pnt in free zone
def_size = $-def

      ORG va_chung
var
sign  SKIP 5
va_free_pnt WORD 

      IF $-var - def_size
 !! inconsistency
      END

zero_start              ; Not loaded, must follow def (see check below)
      IF zero_start - [var+def_size]
 !! must be contiguous to simplify init code
      END
          ASSERT(va_current_instr == $)
      BYTE 
va_table# BYTE 
selected_row WORD 

zero_size = $-zero_start

; ---- Must be zeroed at ayane init, but not song reset ----

zero_chung
stored_table_start WORD  ; chunk id. Needed for free (unused now)
zero_chung_ = $-zero_chung

; ----
stored_table_back WORD  ; ID of last chunk for append_raw_in_chunk


      ORG save_pc       ; for host
; Align, for more stable addresses
; -> ease debugging
; -> less re-assembling when we change just one module
      SKIP -$ AND &FF





